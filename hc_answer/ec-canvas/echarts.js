var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
    return typeof t;
} : function(t) {
    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
};

!function(t, e) {
    "object" == ("undefined" == typeof exports ? "undefined" : _typeof(exports)) && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define([ "exports" ], e) : e(t.echarts = {});
}(void 0, function(t) {
    function e(t, e) {
        "createCanvas" === t && (Ep = null), Np[t] = e;
    }
    function A(t) {
        if (null == t || "object" != (void 0 === t ? "undefined" : _typeof(t))) return t;
        var e = t, i = Tp.call(t);
        if ("[object Array]" === i) {
            if (!f(t)) {
                e = [];
                for (var n = 0, a = t.length; n < a; n++) e[n] = A(t[n]);
            }
        } else if (Ip[i]) {
            if (!f(t)) {
                var o = t.constructor;
                if (t.constructor.from) e = o.from(t); else {
                    e = new o(t.length);
                    for (n = 0, a = t.length; n < a; n++) e[n] = A(t[n]);
                }
            }
        } else if (!Mp[i] && !f(t) && !w(t)) for (var r in e = {}, t) t.hasOwnProperty(r) && (e[r] = A(t[r]));
        return e;
    }
    function g(t, e, i) {
        if (!B(e) || !B(t)) return i ? A(e) : t;
        for (var n in e) if (e.hasOwnProperty(n)) {
            var a = t[n], o = e[n];
            !B(o) || !B(a) || N(o) || N(a) || w(o) || w(a) || r(o) || r(a) || f(o) || f(a) ? !i && n in t || (t[n] = A(e[n])) : g(a, o, i);
        }
        return t;
    }
    function u(t, e) {
        for (var i = t[0], n = 1, a = t.length; n < a; n++) i = g(i, t[n], e);
        return i;
    }
    function P(t, e) {
        for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
        return t;
    }
    function E(t, e, i) {
        for (var n in e) e.hasOwnProperty(n) && (i ? null != e[n] : null == t[n]) && (t[n] = e[n]);
        return t;
    }
    function n() {
        return Ep || (Ep = Op().getContext("2d")), Ep;
    }
    function C(t, e) {
        if (t) {
            if (t.indexOf) return t.indexOf(e);
            for (var i = 0, n = t.length; i < n; i++) if (t[i] === e) return i;
        }
        return -1;
    }
    function o(t, e) {
        function i() {}
        var n = t.prototype;
        for (var a in i.prototype = e.prototype, t.prototype = new i(), n) t.prototype[a] = n[a];
        (t.prototype.constructor = t).superClass = e;
    }
    function a(t, e, i) {
        E(t = "prototype" in t ? t.prototype : t, e = "prototype" in e ? e.prototype : e, i);
    }
    function O(t) {
        if (t) return "string" != typeof t && "number" == typeof t.length;
    }
    function R(t, e, i) {
        if (t && e) if (t.forEach && t.forEach === Ap) t.forEach(e, i); else if (t.length === +t.length) for (var n = 0, a = t.length; n < a; n++) e.call(i, t[n], n, t); else for (var o in t) t.hasOwnProperty(o) && e.call(i, t[o], o, t);
    }
    function L(t, e, i) {
        if (t && e) {
            if (t.map && t.map === kp) return t.map(e, i);
            for (var n = [], a = 0, o = t.length; a < o; a++) n.push(e.call(i, t[a], a, t));
            return n;
        }
    }
    function p(t, e, i, n) {
        if (t && e) {
            if (t.reduce && t.reduce === Pp) return t.reduce(e, i, n);
            for (var a = 0, o = t.length; a < o; a++) i = e.call(n, i, t[a], a, t);
            return i;
        }
    }
    function I(t, e, i) {
        if (t && e) {
            if (t.filter && t.filter === Cp) return t.filter(e, i);
            for (var n = [], a = 0, o = t.length; a < o; a++) e.call(i, t[a], a, t) && n.push(t[a]);
            return n;
        }
    }
    function _(t, e) {
        var i = Lp.call(arguments, 2);
        return function() {
            return t.apply(e, i.concat(Lp.call(arguments)));
        };
    }
    function z(t) {
        var e = Lp.call(arguments, 1);
        return function() {
            return t.apply(this, e.concat(Lp.call(arguments)));
        };
    }
    function N(t) {
        return "[object Array]" === Tp.call(t);
    }
    function m(t) {
        return "function" == typeof t;
    }
    function b(t) {
        return "[object String]" === Tp.call(t);
    }
    function B(t) {
        var e = void 0 === t ? "undefined" : _typeof(t);
        return "function" === e || !!t && "object" == e;
    }
    function r(t) {
        return !!Mp[Tp.call(t)];
    }
    function v(t) {
        return !!Ip[Tp.call(t)];
    }
    function w(t) {
        return "object" == (void 0 === t ? "undefined" : _typeof(t)) && "number" == typeof t.nodeType && "object" == _typeof(t.ownerDocument);
    }
    function y(t) {
        return t != t;
    }
    function V(t) {
        for (var e = 0, i = arguments.length; e < i; e++) if (null != arguments[e]) return arguments[e];
    }
    function k(t, e) {
        return null != t ? t : e;
    }
    function G(t, e, i) {
        return null != t ? t : null != e ? e : i;
    }
    function s() {
        return Function.call.apply(Lp, arguments);
    }
    function l(t) {
        if ("number" == typeof t) return [ t, t, t, t ];
        var e = t.length;
        return 2 === e ? [ t[0], t[1], t[0], t[1] ] : 3 === e ? [ t[0], t[1], t[2], t[1] ] : t;
    }
    function c(t, e) {
        if (!t) throw new Error(e);
    }
    function h(t) {
        return null == t ? null : "function" == typeof t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    }
    function d(t) {
        t[Rp] = !0;
    }
    function f(t) {
        return t[Rp];
    }
    function x(t) {
        function e(t, e) {
            i ? n.set(t, e) : n.set(e, t);
        }
        var i = N(t), n = this;
        t instanceof x ? t.each(e) : t && R(t, e);
    }
    function W(t) {
        return new x(t);
    }
    function i(t, e) {
        for (var i = new t.constructor(t.length + e.length), n = 0; n < t.length; n++) i[n] = t[n];
        var a = t.length;
        for (n = 0; n < e.length; n++) i[n + a] = e[n];
        return i;
    }
    function S() {}
    function M(t, e) {
        var i = new Bp(2);
        return null == t && (t = 0), null == e && (e = 0), i[0] = t, i[1] = e, i;
    }
    function T(t, e) {
        return t[0] = e[0], t[1] = e[1], t;
    }
    function D(t) {
        var e = new Bp(2);
        return e[0] = t[0], e[1] = t[1], e;
    }
    function F(t, e, i) {
        return t[0] = e, t[1] = i, t;
    }
    function H(t, e, i) {
        return t[0] = e[0] + i[0], t[1] = e[1] + i[1], t;
    }
    function Z(t, e, i, n) {
        return t[0] = e[0] + i[0] * n, t[1] = e[1] + i[1] * n, t;
    }
    function U(t, e, i) {
        return t[0] = e[0] - i[0], t[1] = e[1] - i[1], t;
    }
    function j(t) {
        return Math.sqrt(X(t));
    }
    function X(t) {
        return t[0] * t[0] + t[1] * t[1];
    }
    function Y(t, e, i) {
        return t[0] = e[0] * i, t[1] = e[1] * i, t;
    }
    function q(t, e) {
        var i = j(e);
        return 0 === i ? (t[0] = 0, t[1] = 0) : (t[0] = e[0] / i, t[1] = e[1] / i), t;
    }
    function K(t, e) {
        return Math.sqrt((t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1]));
    }
    function $(t, e) {
        return (t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1]);
    }
    function J(t, e, i, n) {
        return t[0] = e[0] + n * (i[0] - e[0]), t[1] = e[1] + n * (i[1] - e[1]), t;
    }
    function Q(t, e, i) {
        var n = e[0], a = e[1];
        return t[0] = i[0] * n + i[2] * a + i[4], t[1] = i[1] * n + i[3] * a + i[5], t;
    }
    function tt(t, e, i) {
        return t[0] = Math.min(e[0], i[0]), t[1] = Math.min(e[1], i[1]), t;
    }
    function et(t, e, i) {
        return t[0] = Math.max(e[0], i[0]), t[1] = Math.max(e[1], i[1]), t;
    }
    function it() {
        this.on("mousedown", this._dragStart, this), this.on("mousemove", this._drag, this), 
        this.on("mouseup", this._dragEnd, this), this.on("globalout", this._dragEnd, this);
    }
    function nt(t, e) {
        return {
            target: t,
            topTarget: e && e.topTarget
        };
    }
    function at() {}
    function ot(t, e, i) {
        if (t[t.rectHover ? "rectContain" : "contain"](e, i)) {
            for (var n, a = t; a; ) {
                if (a.clipPath && !a.clipPath.contain(e, i)) return !1;
                a.silent && (n = !0), a = a.parent;
            }
            return !n || jp;
        }
        return !1;
    }
    function rt() {
        var t = new qp(6);
        return st(t), t;
    }
    function st(t) {
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t;
    }
    function lt(t, e) {
        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], 
        t;
    }
    function ht(t, e, i) {
        var n = e[0] * i[0] + e[2] * i[1], a = e[1] * i[0] + e[3] * i[1], o = e[0] * i[2] + e[2] * i[3], r = e[1] * i[2] + e[3] * i[3], s = e[0] * i[4] + e[2] * i[5] + e[4], l = e[1] * i[4] + e[3] * i[5] + e[5];
        return t[0] = n, t[1] = a, t[2] = o, t[3] = r, t[4] = s, t[5] = l, t;
    }
    function ut(t, e, i) {
        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4] + i[0], t[5] = e[5] + i[1], 
        t;
    }
    function ct(t, e, i) {
        var n = e[0], a = e[2], o = e[4], r = e[1], s = e[3], l = e[5], h = Math.sin(i), u = Math.cos(i);
        return t[0] = n * u + r * h, t[1] = -n * h + r * u, t[2] = a * u + s * h, t[3] = -a * h + u * s, 
        t[4] = u * o + h * l, t[5] = u * l - h * o, t;
    }
    function dt(t, e, i) {
        var n = i[0], a = i[1];
        return t[0] = e[0] * n, t[1] = e[1] * a, t[2] = e[2] * n, t[3] = e[3] * a, t[4] = e[4] * n, 
        t[5] = e[5] * a, t;
    }
    function ft(t, e) {
        var i = e[0], n = e[2], a = e[4], o = e[1], r = e[3], s = e[5], l = i * r - o * n;
        return l ? (l = 1 / l, t[0] = r * l, t[1] = -o * l, t[2] = -n * l, t[3] = i * l, 
        t[4] = (n * s - r * a) * l, t[5] = (o * a - i * s) * l, t) : null;
    }
    function pt(t) {
        var e = rt();
        return lt(e, t), e;
    }
    function gt(t) {
        return 5e-5 < t || t < -5e-5;
    }
    function mt(t) {
        this._target = t.target, this._life = t.life || 1e3, this._delay = t.delay || 0, 
        this._initialized = !1, this.loop = null != t.loop && t.loop, this.gap = t.gap || 0, 
        this.easing = t.easing || "Linear", this.onframe = t.onframe, this.ondestroy = t.ondestroy, 
        this.onrestart = t.onrestart, this._pausedTime = 0, this._paused = !1;
    }
    function vt(t) {
        return (t = Math.round(t)) < 0 ? 0 : 255 < t ? 255 : t;
    }
    function yt(t) {
        return t < 0 ? 0 : 1 < t ? 1 : t;
    }
    function xt(t) {
        return vt(t.length && "%" === t.charAt(t.length - 1) ? parseFloat(t) / 100 * 255 : parseInt(t, 10));
    }
    function _t(t) {
        return yt(t.length && "%" === t.charAt(t.length - 1) ? parseFloat(t) / 100 : parseFloat(t));
    }
    function wt(t, e, i) {
        return i < 0 ? i += 1 : 1 < i && (i -= 1), 6 * i < 1 ? t + (e - t) * i * 6 : 2 * i < 1 ? e : 3 * i < 2 ? t + (e - t) * (2 / 3 - i) * 6 : t;
    }
    function bt(t, e, i) {
        return t + (e - t) * i;
    }
    function St(t, e, i, n, a) {
        return t[0] = e, t[1] = i, t[2] = n, t[3] = a, t;
    }
    function Mt(t, e) {
        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t;
    }
    function It(t, e) {
        hg && Mt(hg, e), hg = lg.put(t, hg || e.slice());
    }
    function Tt(t, e) {
        if (t) {
            e = e || [];
            var i = lg.get(t);
            if (i) return Mt(e, i);
            var n = (t += "").replace(/ /g, "").toLowerCase();
            if (n in sg) return Mt(e, sg[n]), It(t, e), e;
            if ("#" !== n.charAt(0)) {
                var a = n.indexOf("("), o = n.indexOf(")");
                if (-1 !== a && o + 1 === n.length) {
                    var r = n.substr(0, a), s = n.substr(a + 1, o - (a + 1)).split(","), l = 1;
                    switch (r) {
                      case "rgba":
                        if (4 !== s.length) return void St(e, 0, 0, 0, 1);
                        l = _t(s.pop());

                      case "rgb":
                        return 3 !== s.length ? void St(e, 0, 0, 0, 1) : (St(e, xt(s[0]), xt(s[1]), xt(s[2]), l), 
                        It(t, e), e);

                      case "hsla":
                        return 4 !== s.length ? void St(e, 0, 0, 0, 1) : (s[3] = _t(s[3]), Dt(s, e), It(t, e), 
                        e);

                      case "hsl":
                        return 3 !== s.length ? void St(e, 0, 0, 0, 1) : (Dt(s, e), It(t, e), e);

                      default:
                        return;
                    }
                }
                St(e, 0, 0, 0, 1);
            } else {
                if (4 === n.length) return 0 <= (h = parseInt(n.substr(1), 16)) && h <= 4095 ? (St(e, (3840 & h) >> 4 | (3840 & h) >> 8, 240 & h | (240 & h) >> 4, 15 & h | (15 & h) << 4, 1), 
                It(t, e), e) : void St(e, 0, 0, 0, 1);
                if (7 === n.length) {
                    var h = parseInt(n.substr(1), 16);
                    return 0 <= h && h <= 16777215 ? (St(e, (16711680 & h) >> 16, (65280 & h) >> 8, 255 & h, 1), 
                    It(t, e), e) : void St(e, 0, 0, 0, 1);
                }
            }
        }
    }
    function Dt(t, e) {
        var i = (parseFloat(t[0]) % 360 + 360) % 360 / 360, n = _t(t[1]), a = _t(t[2]), o = a <= .5 ? a * (n + 1) : a + n - a * n, r = 2 * a - o;
        return St(e = e || [], vt(255 * wt(r, o, i + 1 / 3)), vt(255 * wt(r, o, i)), vt(255 * wt(r, o, i - 1 / 3)), 1), 
        4 === t.length && (e[3] = t[3]), e;
    }
    function At(t, e) {
        var i = Tt(t);
        if (i) {
            for (var n = 0; n < 3; n++) i[n] = e < 0 ? i[n] * (1 - e) | 0 : (255 - i[n]) * e + i[n] | 0, 
            255 < i[n] ? i[n] = 255 : t[n] < 0 && (i[n] = 0);
            return Ot(i, 4 === i.length ? "rgba" : "rgb");
        }
    }
    function Ct(t) {
        var e = Tt(t);
        if (e) return ((1 << 24) + (e[0] << 16) + (e[1] << 8) + +e[2]).toString(16).slice(1);
    }
    function Lt(t, e, i) {
        if (e && e.length && 0 <= t && t <= 1) {
            i = i || [];
            var n = t * (e.length - 1), a = Math.floor(n), o = Math.ceil(n), r = e[a], s = e[o], l = n - a;
            return i[0] = vt(bt(r[0], s[0], l)), i[1] = vt(bt(r[1], s[1], l)), i[2] = vt(bt(r[2], s[2], l)), 
            i[3] = yt(bt(r[3], s[3], l)), i;
        }
    }
    function kt(t, e, i) {
        if (e && e.length && 0 <= t && t <= 1) {
            var n = t * (e.length - 1), a = Math.floor(n), o = Math.ceil(n), r = Tt(e[a]), s = Tt(e[o]), l = n - a, h = Ot([ vt(bt(r[0], s[0], l)), vt(bt(r[1], s[1], l)), vt(bt(r[2], s[2], l)), yt(bt(r[3], s[3], l)) ], "rgba");
            return i ? {
                color: h,
                leftIndex: a,
                rightIndex: o,
                value: n
            } : h;
        }
    }
    function Pt(t, e, i, n) {
        if (t = Tt(t)) return t = function(t) {
            if (t) {
                var e, i, n = t[0] / 255, a = t[1] / 255, o = t[2] / 255, r = Math.min(n, a, o), s = Math.max(n, a, o), l = s - r, h = (s + r) / 2;
                if (0 === l) i = e = 0; else {
                    i = h < .5 ? l / (s + r) : l / (2 - s - r);
                    var u = ((s - n) / 6 + l / 2) / l, c = ((s - a) / 6 + l / 2) / l, d = ((s - o) / 6 + l / 2) / l;
                    n === s ? e = d - c : a === s ? e = 1 / 3 + u - d : o === s && (e = 2 / 3 + c - u), 
                    e < 0 && (e += 1), 1 < e && (e -= 1);
                }
                var f = [ 360 * e, i, h ];
                return null != t[3] && f.push(t[3]), f;
            }
        }(t), null != e && (t[0] = (a = e, (a = Math.round(a)) < 0 ? 0 : 360 < a ? 360 : a)), 
        null != i && (t[1] = _t(i)), null != n && (t[2] = _t(n)), Ot(Dt(t), "rgba");
        var a;
    }
    function Nt(t, e) {
        if ((t = Tt(t)) && null != e) return t[3] = yt(e), Ot(t, "rgba");
    }
    function Ot(t, e) {
        if (t && t.length) {
            var i = t[0] + "," + t[1] + "," + t[2];
            return "rgba" !== e && "hsva" !== e && "hsla" !== e || (i += "," + t[3]), e + "(" + i + ")";
        }
    }
    function Et(t, e) {
        return t[e];
    }
    function Rt(t, e, i) {
        t[e] = i;
    }
    function zt(t, e, i) {
        return (e - t) * i + t;
    }
    function Bt(t, e, i) {
        return .5 < i ? e : t;
    }
    function Vt(t, e, i, n, a) {
        var o = t.length;
        if (1 == a) for (s = 0; s < o; s++) n[s] = zt(t[s], e[s], i); else for (var r = o && t[0].length, s = 0; s < o; s++) for (var l = 0; l < r; l++) n[s][l] = zt(t[s][l], e[s][l], i);
    }
    function Gt(t, e, i) {
        var n = t.length, a = e.length;
        if (n !== a) if (a < n) t.length = a; else for (r = n; r < a; r++) t.push(1 === i ? e[r] : fg.call(e[r]));
        for (var o = t[0] && t[0].length, r = 0; r < t.length; r++) if (1 === i) isNaN(t[r]) && (t[r] = e[r]); else for (var s = 0; s < o; s++) isNaN(t[r][s]) && (t[r][s] = e[r][s]);
    }
    function Wt(t, e, i) {
        if (t === e) return !0;
        var n = t.length;
        if (n !== e.length) return !1;
        if (1 === i) {
            for (o = 0; o < n; o++) if (t[o] !== e[o]) return !1;
        } else for (var a = t[0].length, o = 0; o < n; o++) for (var r = 0; r < a; r++) if (t[o][r] !== e[o][r]) return !1;
        return !0;
    }
    function Ft(t, e, i, n, a, o, r, s, l) {
        var h = t.length;
        if (1 == l) for (c = 0; c < h; c++) s[c] = Ht(t[c], e[c], i[c], n[c], a, o, r); else for (var u = t[0].length, c = 0; c < h; c++) for (var d = 0; d < u; d++) s[c][d] = Ht(t[c][d], e[c][d], i[c][d], n[c][d], a, o, r);
    }
    function Ht(t, e, i, n, a, o, r) {
        var s = .5 * (i - t), l = .5 * (n - e);
        return (2 * (e - i) + s + l) * r + (-3 * (e - i) - 2 * s - l) * o + s * a + e;
    }
    function Zt(t) {
        if (O(t)) {
            var e = t.length;
            if (O(t[0])) {
                for (var i = [], n = 0; n < e; n++) i.push(fg.call(t[n]));
                return i;
            }
            return fg.call(t);
        }
        return t;
    }
    function Ut(t) {
        return t[0] = Math.floor(t[0]), t[1] = Math.floor(t[1]), t[2] = Math.floor(t[2]), 
        "rgba(" + t.join(",") + ")";
    }
    function jt(t, e, i, n, o, a) {
        var r, s, l = t._getter, h = t._setter, u = "spline" === e, c = n.length;
        if (c) {
            var d, f = O(n[0].value), p = !1, g = !1, m = f ? O((s = (r = n)[r.length - 1].value) && s[0]) ? 2 : 1 : 0;
            n.sort(function(t, e) {
                return t.time - e.time;
            }), d = n[c - 1].time;
            for (var v = [], y = [], x = n[0].value, _ = !0, w = 0; w < c; w++) {
                v.push(n[w].time / d);
                var b = n[w].value;
                if (f && Wt(b, x, m) || !f && b === x || (_ = !1), "string" == typeof (x = b)) {
                    var S = Tt(b);
                    S ? (b = S, p = !0) : g = !0;
                }
                y.push(b);
            }
            if (a || !_) {
                var M = y[c - 1];
                for (w = 0; w < c - 1; w++) f ? Gt(y[w], M, m) : !isNaN(y[w]) || isNaN(M) || g || p || (y[w] = M);
                f && Gt(l(t._target, o), M, m);
                var I, T, D, A, C, L = 0, k = 0;
                if (p) var P = [ 0, 0, 0, 0 ];
                var N = new mt({
                    target: t._target,
                    life: d,
                    loop: t._loop,
                    delay: t._delay,
                    onframe: function(t, e) {
                        var i;
                        if (e < 0) i = 0; else if (e < k) {
                            for (i = Math.min(L + 1, c - 1); 0 <= i && !(v[i] <= e); i--) ;
                            i = Math.min(i, c - 2);
                        } else {
                            for (i = L; i < c && !(v[i] > e); i++) ;
                            i = Math.min(i - 1, c - 2);
                        }
                        k = e;
                        var n = v[(L = i) + 1] - v[i];
                        if (0 !== n) if (I = (e - v[i]) / n, u) if (D = y[i], T = y[0 === i ? i : i - 1], 
                        A = y[c - 2 < i ? c - 1 : i + 1], C = y[c - 3 < i ? c - 1 : i + 2], f) Ft(T, D, A, C, I, I * I, I * I * I, l(t, o), m); else {
                            if (p) a = Ft(T, D, A, C, I, I * I, I * I * I, P, 1), a = Ut(P); else {
                                if (g) return Bt(D, A, I);
                                a = Ht(T, D, A, C, I, I * I, I * I * I);
                            }
                            h(t, o, a);
                        } else if (f) Vt(y[i], y[i + 1], I, l(t, o), m); else {
                            var a;
                            if (p) Vt(y[i], y[i + 1], I, P, 1), a = Ut(P); else {
                                if (g) return Bt(y[i], y[i + 1], I);
                                a = zt(y[i], y[i + 1], I);
                            }
                            h(t, o, a);
                        }
                    },
                    ondestroy: i
                });
                return e && "spline" !== e && (N.easing = e), N;
            }
        }
    }
    function Xt(t, e, i, n) {
        i < 0 && (t += i, i = -i), n < 0 && (e += n, n = -n), this.x = t, this.y = e, this.width = i, 
        this.height = n;
    }
    function Yt(t, e, i, n) {
        var a = e + 1;
        if (a === i) return 1;
        if (n(t[a++], t[e]) < 0) {
            for (;a < i && n(t[a], t[a - 1]) < 0; ) a++;
            !function(t, e, i) {
                for (i--; e < i; ) {
                    var n = t[e];
                    t[e++] = t[i], t[i--] = n;
                }
            }(t, e, a);
        } else for (;a < i && 0 <= n(t[a], t[a - 1]); ) a++;
        return a - e;
    }
    function qt(t, e, i, n, a) {
        for (n === e && n++; n < i; n++) {
            for (var o, r = t[n], s = e, l = n; s < l; ) a(r, t[o = s + l >>> 1]) < 0 ? l = o : s = o + 1;
            var h = n - s;
            switch (h) {
              case 3:
                t[s + 3] = t[s + 2];

              case 2:
                t[s + 2] = t[s + 1];

              case 1:
                t[s + 1] = t[s];
                break;

              default:
                for (;0 < h; ) t[s + h] = t[s + h - 1], h--;
            }
            t[s] = r;
        }
    }
    function Kt(t, e, i, n, a, o) {
        var r = 0, s = 0, l = 1;
        if (0 < o(t, e[i + a])) {
            for (s = n - a; l < s && 0 < o(t, e[i + a + l]); ) (l = 1 + ((r = l) << 1)) <= 0 && (l = s);
            s < l && (l = s), r += a, l += a;
        } else {
            for (s = a + 1; l < s && o(t, e[i + a - l]) <= 0; ) (l = 1 + ((r = l) << 1)) <= 0 && (l = s);
            s < l && (l = s);
            var h = r;
            r = a - l, l = a - h;
        }
        for (r++; r < l; ) {
            var u = r + (l - r >>> 1);
            0 < o(t, e[i + u]) ? r = u + 1 : l = u;
        }
        return l;
    }
    function $t(t, e, i, n, a, o) {
        var r = 0, s = 0, l = 1;
        if (o(t, e[i + a]) < 0) {
            for (s = a + 1; l < s && o(t, e[i + a - l]) < 0; ) (l = 1 + ((r = l) << 1)) <= 0 && (l = s);
            s < l && (l = s);
            var h = r;
            r = a - l, l = a - h;
        } else {
            for (s = n - a; l < s && 0 <= o(t, e[i + a + l]); ) (l = 1 + ((r = l) << 1)) <= 0 && (l = s);
            s < l && (l = s), r += a, l += a;
        }
        for (r++; r < l; ) {
            var u = r + (l - r >>> 1);
            o(t, e[i + u]) < 0 ? l = u : r = u + 1;
        }
        return l;
    }
    function Jt(p, g) {
        function e(t) {
            var e = r[t], i = s[t], n = r[t + 1], a = s[t + 1];
            s[t] = i + a, t === l - 3 && (r[t + 1] = r[t + 2], s[t + 1] = s[t + 2]), l--;
            var o = $t(p[n], p, e, i, 0, g);
            e += o, 0 != (i -= o) && 0 !== (a = Kt(p[e + i - 1], p, n, a, a - 1, g)) && (i <= a ? function(t, e, i, n) {
                var a = 0;
                for (a = 0; a < e; a++) v[a] = p[t + a];
                var o = 0, r = i, s = t;
                if (p[s++] = p[r++], 0 != --n) if (1 !== e) {
                    for (var l, h, u, c = m; ;) {
                        h = l = 0, u = !1;
                        do {
                            if (g(p[r], v[o]) < 0) {
                                if (p[s++] = p[r++], h++, (l = 0) == --n) {
                                    u = !0;
                                    break;
                                }
                            } else if (p[s++] = v[o++], l++, h = 0, 1 == --e) {
                                u = !0;
                                break;
                            }
                        } while ((l | h) < c);
                        if (u) break;
                        do {
                            if (0 !== (l = $t(p[r], v, o, e, 0, g))) {
                                for (a = 0; a < l; a++) p[s + a] = v[o + a];
                                if (s += l, o += l, (e -= l) <= 1) {
                                    u = !0;
                                    break;
                                }
                            }
                            if (p[s++] = p[r++], 0 == --n) {
                                u = !0;
                                break;
                            }
                            if (0 !== (h = Kt(v[o], p, r, n, 0, g))) {
                                for (a = 0; a < h; a++) p[s + a] = p[r + a];
                                if (s += h, r += h, 0 == (n -= h)) {
                                    u = !0;
                                    break;
                                }
                            }
                            if (p[s++] = v[o++], 1 == --e) {
                                u = !0;
                                break;
                            }
                            c--;
                        } while (Cg <= l || Cg <= h);
                        if (u) break;
                        c < 0 && (c = 0), c += 2;
                    }
                    if ((m = c) < 1 && (m = 1), 1 === e) {
                        for (a = 0; a < n; a++) p[s + a] = p[r + a];
                        p[s + n] = v[o];
                    } else {
                        if (0 === e) throw new Error();
                        for (a = 0; a < e; a++) p[s + a] = v[o + a];
                    }
                } else {
                    for (a = 0; a < n; a++) p[s + a] = p[r + a];
                    p[s + n] = v[o];
                } else for (a = 0; a < e; a++) p[s + a] = v[o + a];
            }(e, i, n, a) : function(t, e, i, n) {
                var a = 0;
                for (a = 0; a < n; a++) v[a] = p[i + a];
                var o = t + e - 1, r = n - 1, s = i + n - 1, l = 0, h = 0;
                if (p[s--] = p[o--], 0 != --e) if (1 !== n) {
                    for (var u = m; ;) {
                        var c = 0, d = 0, f = !1;
                        do {
                            if (g(v[r], p[o]) < 0) {
                                if (p[s--] = p[o--], c++, (d = 0) == --e) {
                                    f = !0;
                                    break;
                                }
                            } else if (p[s--] = v[r--], d++, c = 0, 1 == --n) {
                                f = !0;
                                break;
                            }
                        } while ((c | d) < u);
                        if (f) break;
                        do {
                            if (0 != (c = e - $t(v[r], p, t, e, e - 1, g))) {
                                for (e -= c, h = 1 + (s -= c), l = 1 + (o -= c), a = c - 1; 0 <= a; a--) p[h + a] = p[l + a];
                                if (0 === e) {
                                    f = !0;
                                    break;
                                }
                            }
                            if (p[s--] = v[r--], 1 == --n) {
                                f = !0;
                                break;
                            }
                            if (0 != (d = n - Kt(p[o], v, 0, n, n - 1, g))) {
                                for (n -= d, h = 1 + (s -= d), l = 1 + (r -= d), a = 0; a < d; a++) p[h + a] = v[l + a];
                                if (n <= 1) {
                                    f = !0;
                                    break;
                                }
                            }
                            if (p[s--] = p[o--], 0 == --e) {
                                f = !0;
                                break;
                            }
                            u--;
                        } while (Cg <= c || Cg <= d);
                        if (f) break;
                        u < 0 && (u = 0), u += 2;
                    }
                    if ((m = u) < 1 && (m = 1), 1 === n) {
                        for (h = 1 + (s -= e), l = 1 + (o -= e), a = e - 1; 0 <= a; a--) p[h + a] = p[l + a];
                        p[s] = v[r];
                    } else {
                        if (0 === n) throw new Error();
                        for (l = s - (n - 1), a = 0; a < n; a++) p[l + a] = v[a];
                    }
                } else {
                    for (h = 1 + (s -= e), l = 1 + (o -= e), a = e - 1; 0 <= a; a--) p[h + a] = p[l + a];
                    p[s] = v[r];
                } else for (l = s - (n - 1), a = 0; a < n; a++) p[l + a] = v[a];
            }(e, i, n, a));
        }
        var r, s, m = Cg, l = 0, v = [];
        r = [], s = [], this.mergeRuns = function() {
            for (;1 < l; ) {
                var t = l - 2;
                if (1 <= t && s[t - 1] <= s[t] + s[t + 1] || 2 <= t && s[t - 2] <= s[t] + s[t - 1]) s[t - 1] < s[t + 1] && t--; else if (s[t] > s[t + 1]) break;
                e(t);
            }
        }, this.forceMergeRuns = function() {
            for (;1 < l; ) {
                var t = l - 2;
                0 < t && s[t - 1] < s[t + 1] && t--, e(t);
            }
        }, this.pushRun = function(t, e) {
            r[l] = t, s[l] = e, l += 1;
        };
    }
    function Qt(t, e, i, n) {
        i || (i = 0), n || (n = t.length);
        var a = n - i;
        if (!(a < 2)) {
            var o = 0;
            if (a < Ag) return void qt(t, i, n, i + (o = Yt(t, i, n, e)), e);
            var r = new Jt(t, e), s = function(t) {
                for (var e = 0; Ag <= t; ) e |= 1 & t, t >>= 1;
                return t + e;
            }(a);
            do {
                if ((o = Yt(t, i, n, e)) < s) {
                    var l = a;
                    s < l && (l = s), qt(t, i, i + l, i + o, e), o = l;
                }
                r.pushRun(i, o), r.mergeRuns(), a -= o, i += o;
            } while (0 !== a);
            r.forceMergeRuns();
        }
    }
    function te(t, e) {
        return t.zlevel === e.zlevel ? t.z === e.z ? t.z2 - e.z2 : t.z - e.z : t.zlevel - e.zlevel;
    }
    function ee() {
        return !1;
    }
    function ie(t, e, i) {
        var n = Op(), a = e.getWidth(), o = e.getHeight(), r = n.style;
        return r && (r.position = "absolute", r.left = 0, r.top = 0, r.width = a + "px", 
        r.height = o + "px", n.setAttribute("data-zr-dom-id", t)), n.width = a * i, n.height = o * i, 
        n;
    }
    function ne(t) {
        if ("string" == typeof t) {
            var e = Wg.get(t);
            return e && e.image;
        }
        return t;
    }
    function ae(t, e, i, n, a) {
        if (t) {
            if ("string" == typeof t) {
                if (e && e.__zrImageSrc === t || !i) return e;
                var o = Wg.get(t), r = {
                    hostEl: i,
                    cb: n,
                    cbPayload: a
                };
                return o ? !re(e = o.image) && o.pending.push(r) : (!e && (e = new Image()), e.onload = oe, 
                Wg.put(t, e.__cachedImgObj = {
                    image: e,
                    pending: [ r ]
                }), e.src = e.__zrImageSrc = t), e;
            }
            return t;
        }
        return e;
    }
    function oe() {
        var t = this.__cachedImgObj;
        this.onload = this.__cachedImgObj = null;
        for (var e = 0; e < t.pending.length; e++) {
            var i = t.pending[e], n = i.cb;
            n && n(this, i.cbPayload), i.hostEl.dirty();
        }
        t.pending.length = 0;
    }
    function re(t) {
        return t && t.width && t.height;
    }
    function se(t, e) {
        var i, n, a = t + ":" + (e = e || jg);
        if (Fg[a]) return Fg[a];
        for (var o = (t + "").split("\n"), r = 0, s = 0, l = o.length; s < l; s++) r = Math.max((i = o[s], 
        n = e, Xg.measureText(i, n)).width, r);
        return Zg < Hg && (Hg = 0, Fg = {}), Hg++, Fg[a] = r;
    }
    function le(t, e, i, n, a, o, r) {
        return o ? (l = n, h = ye(t, {
            rich: o,
            truncate: r,
            font: e,
            textAlign: s = i,
            textPadding: a
        }), u = h.outerWidth, c = h.outerHeight, new Xt(he(0, u, s), ue(0, c, l), u, c)) : function(t, e, i, n, a, o) {
            var r = ve(t, e, a, o), s = se(t, e);
            a && (s += a[1] + a[3]);
            var l = r.outerHeight, h = new Xt(he(0, s, i), ue(0, l, n), s, l);
            return h.lineHeight = r.lineHeight, h;
        }(t, e, i, n, a, r);
        var s, l, h, u, c;
    }
    function he(t, e, i) {
        return "right" === i ? t -= e : "center" === i && (t -= e / 2), t;
    }
    function ue(t, e, i) {
        return "middle" === i ? t -= e / 2 : "bottom" === i && (t -= e), t;
    }
    function ce(t, e, i) {
        var n = e.x, a = e.y, o = e.height, r = e.width, s = o / 2, l = "left", h = "top";
        switch (t) {
          case "left":
            n -= i, a += s, l = "right", h = "middle";
            break;

          case "right":
            n += i + r, a += s, h = "middle";
            break;

          case "top":
            n += r / 2, a -= i, l = "center", h = "bottom";
            break;

          case "bottom":
            n += r / 2, a += o + i, l = "center";
            break;

          case "inside":
            n += r / 2, a += s, l = "center", h = "middle";
            break;

          case "insideLeft":
            n += i, a += s, h = "middle";
            break;

          case "insideRight":
            n += r - i, a += s, l = "right", h = "middle";
            break;

          case "insideTop":
            n += r / 2, a += i, l = "center";
            break;

          case "insideBottom":
            n += r / 2, a += o - i, l = "center", h = "bottom";
            break;

          case "insideTopLeft":
            n += i, a += i;
            break;

          case "insideTopRight":
            n += r - i, a += i, l = "right";
            break;

          case "insideBottomLeft":
            n += i, a += o - i, h = "bottom";
            break;

          case "insideBottomRight":
            n += r - i, a += o - i, l = "right", h = "bottom";
        }
        return {
            x: n,
            y: a,
            textAlign: l,
            textVerticalAlign: h
        };
    }
    function de(t, e, i, n, a) {
        if (!e) return "";
        var o = (t + "").split("\n");
        a = fe(e, i, n, a);
        for (var r = 0, s = o.length; r < s; r++) o[r] = pe(o[r], a);
        return o.join("\n");
    }
    function fe(t, e, i, n) {
        (n = P({}, n)).font = e;
        i = k(i, "...");
        n.maxIterations = k(n.maxIterations, 2);
        var a = n.minChar = k(n.minChar, 0);
        n.cnCharWidth = se("国", e);
        var o = n.ascCharWidth = se("a", e);
        n.placeholder = k(n.placeholder, "");
        for (var r = t = Math.max(0, t - 1), s = 0; s < a && o <= r; s++) r -= o;
        var l = se(i);
        return r < l && (i = "", l = 0), r = t - l, n.ellipsis = i, n.ellipsisWidth = l, 
        n.contentWidth = r, n.containerWidth = t, n;
    }
    function pe(t, e) {
        var i = e.containerWidth, n = e.font, a = e.contentWidth;
        if (!i) return "";
        var o = se(t, n);
        if (o <= i) return t;
        for (var r = 0; ;r++) {
            if (o <= a || r >= e.maxIterations) {
                t += e.ellipsis;
                break;
            }
            var s = 0 === r ? ge(t, a, e.ascCharWidth, e.cnCharWidth) : 0 < o ? Math.floor(t.length * a / o) : 0;
            o = se(t = t.substr(0, s), n);
        }
        return "" === t && (t = e.placeholder), t;
    }
    function ge(t, e, i, n) {
        for (var a = 0, o = 0, r = t.length; o < r && a < e; o++) {
            var s = t.charCodeAt(o);
            a += 0 <= s && s <= 127 ? i : n;
        }
        return o;
    }
    function me(t) {
        return se("国", t);
    }
    function ve(t, e, i, n) {
        null != t && (t += "");
        var a = me(e), o = t ? t.split("\n") : [], r = o.length * a, s = r;
        if (i && (s += i[0] + i[2]), t && n) {
            var l = n.outerHeight, h = n.outerWidth;
            if (null != l && l < s) t = "", o = []; else if (null != h) for (var u = fe(h - (i ? i[1] + i[3] : 0), e, n.ellipsis, {
                minChar: n.minChar,
                placeholder: n.placeholder
            }), c = 0, d = o.length; c < d; c++) o[c] = pe(o[c], u);
        }
        return {
            lines: o,
            height: r,
            outerHeight: s,
            lineHeight: a
        };
    }
    function ye(t, e) {
        var i = {
            lines: [],
            width: 0,
            height: 0
        };
        if (null != t && (t += ""), !t) return i;
        for (var n, a = Ug.lastIndex = 0; null != (n = Ug.exec(t)); ) {
            var o = n.index;
            a < o && xe(i, t.substring(a, o)), xe(i, n[2], n[1]), a = Ug.lastIndex;
        }
        a < t.length && xe(i, t.substring(a, t.length));
        var r = i.lines, s = 0, l = 0, h = [], u = e.textPadding, c = e.truncate, d = c && c.outerWidth, f = c && c.outerHeight;
        for (u && (null != d && (d -= u[1] + u[3]), null != f && (f -= u[0] + u[2])), A = 0; A < r.length; A++) {
            for (var p = r[A], g = 0, m = 0, v = 0; v < p.tokens.length; v++) {
                var y = (C = p.tokens[v]).styleName && e.rich[C.styleName] || {}, x = C.textPadding = y.textPadding, _ = C.font = y.font || e.font, w = C.textHeight = k(y.textHeight, me(_));
                if (x && (w += x[0] + x[2]), C.height = w, C.lineHeight = G(y.textLineHeight, e.textLineHeight, w), 
                C.textAlign = y && y.textAlign || e.textAlign, C.textVerticalAlign = y && y.textVerticalAlign || "middle", 
                null != f && s + C.lineHeight > f) return {
                    lines: [],
                    width: 0,
                    height: 0
                };
                C.textWidth = se(C.text, _);
                var b = y.textWidth, S = null == b || "auto" === b;
                if ("string" == typeof b && "%" === b.charAt(b.length - 1)) C.percentWidth = b, 
                h.push(C), b = 0; else {
                    if (S) {
                        b = C.textWidth;
                        var M = y.textBackgroundColor, I = M && M.image;
                        I && re(I = ne(I)) && (b = Math.max(b, I.width * w / I.height));
                    }
                    var T = x ? x[1] + x[3] : 0;
                    b += T;
                    var D = null != d ? d - m : null;
                    null != D && D < b && (!S || D < T ? (C.text = "", C.textWidth = b = 0) : (C.text = de(C.text, D - T, _, c.ellipsis, {
                        minChar: c.minChar
                    }), C.textWidth = se(C.text, _), b = C.textWidth + T));
                }
                m += C.width = b, y && (g = Math.max(g, C.lineHeight));
            }
            p.width = m, s += p.lineHeight = g, l = Math.max(l, m);
        }
        i.outerWidth = i.width = k(e.textWidth, l), i.outerHeight = i.height = k(e.textHeight, s), 
        u && (i.outerWidth += u[1] + u[3], i.outerHeight += u[0] + u[2]);
        for (var A = 0; A < h.length; A++) {
            var C = h[A], L = C.percentWidth;
            C.width = parseInt(L, 10) / 100 * l;
        }
        return i;
    }
    function xe(t, e, i) {
        for (var n = "" === e, a = e.split("\n"), o = t.lines, r = 0; r < a.length; r++) {
            var s = a[r], l = {
                styleName: i,
                text: s,
                isLineHolder: !s && !n
            };
            if (r) o.push({
                tokens: [ l ]
            }); else {
                var h = (o[o.length - 1] || (o[0] = {
                    tokens: []
                })).tokens, u = h.length;
                1 === u && h[0].isLineHolder ? h[0] = l : (s || !u || n) && h.push(l);
            }
        }
    }
    function _e(t) {
        var e = (t.fontSize || t.fontFamily) && [ t.fontStyle, t.fontWeight, (t.fontSize || 12) + "px", t.fontFamily || "sans-serif" ].join(" ");
        return e && h(e) || t.textFont || t.font;
    }
    function we(t, e) {
        var i, n, a, o, r, s = e.x, l = e.y, h = e.width, u = e.height, c = e.r;
        h < 0 && (s += h, h = -h), u < 0 && (l += u, u = -u), "number" == typeof c ? i = n = a = o = c : c instanceof Array ? 1 === c.length ? i = n = a = o = c[0] : 2 === c.length ? (i = a = c[0], 
        n = o = c[1]) : 3 === c.length ? (i = c[0], n = o = c[1], a = c[2]) : (i = c[0], 
        n = c[1], a = c[2], o = c[3]) : i = n = a = o = 0, h < i + n && (i *= h / (r = i + n), 
        n *= h / r), h < a + o && (a *= h / (r = a + o), o *= h / r), u < n + a && (n *= u / (r = n + a), 
        a *= u / r), u < i + o && (i *= u / (r = i + o), o *= u / r), t.moveTo(s + i, l), 
        t.lineTo(s + h - n, l), 0 !== n && t.arc(s + h - n, l + n, n, -Math.PI / 2, 0), 
        t.lineTo(s + h, l + u - a), 0 !== a && t.arc(s + h - a, l + u - a, a, 0, Math.PI / 2), 
        t.lineTo(s + o, l + u), 0 !== o && t.arc(s + o, l + u - o, o, Math.PI / 2, Math.PI), 
        t.lineTo(s, l + i), 0 !== i && t.arc(s + i, l + i, i, Math.PI, 1.5 * Math.PI);
    }
    function be(t) {
        return Se(t), R(t.rich, Se), t;
    }
    function Se(t) {
        if (t) {
            t.font = _e(t);
            var e = t.textAlign;
            "middle" === e && (e = "center"), t.textAlign = null == e || Yg[e] ? e : "left";
            var i = t.textVerticalAlign || t.textBaseline;
            "center" === i && (i = "middle"), t.textVerticalAlign = null == i || qg[i] ? i : "top", 
            t.textPadding && (t.textPadding = l(t.textPadding));
        }
    }
    function Me(t, e, i, n, a) {
        var o, r, s, l, h, u;
        n.rich ? (r = e, s = i, l = n, h = a, (u = (o = t).__textCotentBlock) && !o.__dirty || (u = o.__textCotentBlock = ye(s, l)), 
        function(t, e, i, n, a) {
            var o = i.width, r = i.outerWidth, s = i.outerHeight, l = n.textPadding, h = Le(s, n, a), u = h.baseX, c = h.baseY, d = h.textAlign, f = h.textVerticalAlign;
            Ie(e, n, a, u, c);
            var p = he(u, r, d), g = ue(c, s, f), m = p, v = g;
            l && (m += l[3], v += l[0]);
            var y = m + o;
            De(n) && Ae(t, e, n, p, g, r, s);
            for (var x = 0; x < i.lines.length; x++) {
                for (var _, w = i.lines[x], b = w.tokens, S = b.length, M = w.lineHeight, I = w.width, T = 0, D = m, A = y, C = S - 1; T < S && (!(_ = b[T]).textAlign || "left" === _.textAlign); ) Te(t, e, _, n, M, v, D, "left"), 
                I -= _.width, D += _.width, T++;
                for (;0 <= C && "right" === (_ = b[C]).textAlign; ) Te(t, e, _, n, M, v, A, "right"), 
                I -= _.width, A -= _.width, C--;
                for (D += (o - (D - m) - (y - A) - I) / 2; T <= C; ) Te(t, e, _ = b[T], n, M, v, D + _.width / 2, "center"), 
                D += _.width, T++;
                v += M;
            }
        }(o, r, u, l, h)) : function(t, e, i, n, a) {
            var o = ke(e, "font", n.font || jg), r = n.textPadding, s = t.__textCotentBlock;
            s && !t.__dirty || (s = t.__textCotentBlock = ve(i, o, r, n.truncate));
            var l = s.outerHeight, h = s.lines, u = s.lineHeight, c = Le(l, n, a), d = c.baseX, f = c.baseY, p = c.textAlign, g = c.textVerticalAlign;
            Ie(e, n, a, d, f);
            var m = ue(f, l, g), v = d, y = m, x = De(n);
            if (x || r) {
                var _ = se(i, o);
                r && (_ += r[1] + r[3]);
                var w = he(d, _, p);
                x && Ae(t, e, n, w, m, _, l), r && (v = Ee(d, p, r), y += r[0]);
            }
            ke(e, "textAlign", p || "left"), ke(e, "textBaseline", "middle"), ke(e, "shadowBlur", n.textShadowBlur || 0), 
            ke(e, "shadowColor", n.textShadowColor || "transparent"), ke(e, "shadowOffsetX", n.textShadowOffsetX || 0), 
            ke(e, "shadowOffsetY", n.textShadowOffsetY || 0), y += u / 2;
            var b = n.textStrokeWidth, S = Pe(n.textStroke, b), M = Ne(n.textFill);
            S && (ke(e, "lineWidth", b), ke(e, "strokeStyle", S)), M && ke(e, "fillStyle", M);
            for (var I = 0; I < h.length; I++) S && e.strokeText(h[I], v, y), M && e.fillText(h[I], v, y), 
            y += u;
        }(t, e, i, n, a);
    }
    function Ie(t, e, i, n, a) {
        if (i && e.textRotation) {
            var o = e.textOrigin;
            "center" === o ? (n = i.width / 2 + i.x, a = i.height / 2 + i.y) : o && (n = o[0] + i.x, 
            a = o[1] + i.y), t.translate(n, a), t.rotate(-e.textRotation), t.translate(-n, -a);
        }
    }
    function Te(t, e, i, n, a, o, r, s) {
        var l = n.rich[i.styleName] || {}, h = i.textVerticalAlign, u = o + a / 2;
        "top" === h ? u = o + i.height / 2 : "bottom" === h && (u = o + a - i.height / 2), 
        !i.isLineHolder && De(l) && Ae(t, e, l, "right" === s ? r - i.width : "center" === s ? r - i.width / 2 : r, u - i.height / 2, i.width, i.height);
        var c = i.textPadding;
        c && (r = Ee(r, s, c), u -= i.height / 2 - c[2] - i.textHeight / 2), ke(e, "shadowBlur", G(l.textShadowBlur, n.textShadowBlur, 0)), 
        ke(e, "shadowColor", l.textShadowColor || n.textShadowColor || "transparent"), ke(e, "shadowOffsetX", G(l.textShadowOffsetX, n.textShadowOffsetX, 0)), 
        ke(e, "shadowOffsetY", G(l.textShadowOffsetY, n.textShadowOffsetY, 0)), ke(e, "textAlign", s), 
        ke(e, "textBaseline", "middle"), ke(e, "font", i.font || jg);
        var d = Pe(l.textStroke || n.textStroke, p), f = Ne(l.textFill || n.textFill), p = k(l.textStrokeWidth, n.textStrokeWidth);
        d && (ke(e, "lineWidth", p), ke(e, "strokeStyle", d), e.strokeText(i.text, r, u)), 
        f && (ke(e, "fillStyle", f), e.fillText(i.text, r, u));
    }
    function De(t) {
        return t.textBackgroundColor || t.textBorderWidth && t.textBorderColor;
    }
    function Ae(t, e, i, n, a, o, r) {
        var s = i.textBackgroundColor, l = i.textBorderWidth, h = i.textBorderColor, u = b(s);
        if (ke(e, "shadowBlur", i.textBoxShadowBlur || 0), ke(e, "shadowColor", i.textBoxShadowColor || "transparent"), 
        ke(e, "shadowOffsetX", i.textBoxShadowOffsetX || 0), ke(e, "shadowOffsetY", i.textBoxShadowOffsetY || 0), 
        u || l && h) {
            e.beginPath();
            var c = i.textBorderRadius;
            c ? we(e, {
                x: n,
                y: a,
                width: o,
                height: r,
                r: c
            }) : e.rect(n, a, o, r), e.closePath();
        }
        if (u) ke(e, "fillStyle", s), e.fill(); else if (B(s)) {
            var d = s.image;
            (d = ae(d, null, t, Ce, s)) && re(d) && e.drawImage(d, n, a, o, r);
        }
        l && h && (ke(e, "lineWidth", l), ke(e, "strokeStyle", h), e.stroke());
    }
    function Ce(t, e) {
        e.image = t;
    }
    function Le(t, e, i) {
        var n = e.x || 0, a = e.y || 0, o = e.textAlign, r = e.textVerticalAlign;
        if (i) {
            var s = e.textPosition;
            if (s instanceof Array) n = i.x + Oe(s[0], i.width), a = i.y + Oe(s[1], i.height); else {
                var l = ce(s, i, e.textDistance);
                n = l.x, a = l.y, o = o || l.textAlign, r = r || l.textVerticalAlign;
            }
            var h = e.textOffset;
            h && (n += h[0], a += h[1]);
        }
        return {
            baseX: n,
            baseY: a,
            textAlign: o,
            textVerticalAlign: r
        };
    }
    function ke(t, e, i) {
        return t[e] = Pg(t, e, i), t[e];
    }
    function Pe(t, e) {
        return null == t || e <= 0 || "transparent" === t || "none" === t ? null : t.image || t.colorStops ? "#000" : t;
    }
    function Ne(t) {
        return null == t || "none" === t ? null : t.image || t.colorStops ? "#000" : t;
    }
    function Oe(t, e) {
        return "string" == typeof t ? 0 <= t.lastIndexOf("%") ? parseFloat(t) / 100 * e : parseFloat(t) : t;
    }
    function Ee(t, e, i) {
        return "right" === e ? t - i[1] : "center" === e ? t + i[3] / 2 - i[1] / 2 : t + i[3];
    }
    function Re(t, e) {
        return null != t && (t || e.textBackgroundColor || e.textBorderWidth && e.textBorderColor || e.textPadding);
    }
    function ze(t) {
        for (var e in t = t || {}, xg.call(this, t), t) t.hasOwnProperty(e) && "style" !== e && (this[e] = t[e]);
        this.style = new Og(t.style, this), this._rect = null, this.__clipPaths = [];
    }
    function Be(t) {
        ze.call(this, t);
    }
    function Ve(t) {
        return parseInt(t, 10);
    }
    function Ge(t, e, i, n) {
        return i = i || {}, n || !Sp.canvasSupported ? We(t, e, i) : Sp.browser.firefox && null != e.layerX && e.layerX !== e.offsetX ? (i.zrX = e.layerX, 
        i.zrY = e.layerY) : null != e.offsetX ? (i.zrX = e.offsetX, i.zrY = e.offsetY) : We(t, e, i), 
        i;
    }
    function We(t, e, i) {
        var n, a = (n = t).getBoundingClientRect ? n.getBoundingClientRect() : {
            left: 0,
            top: 0
        };
        i.zrX = e.clientX - a.left, i.zrY = e.clientY - a.top;
    }
    function Fe(t, e, i) {
        if (null != (e = e || window.event).zrX) return e;
        var n = e.type;
        if (n && 0 <= n.indexOf("touch")) {
            var a = "touchend" != n ? e.targetTouches[0] : e.changedTouches[0];
            a && Ge(t, a, e, i);
        } else Ge(t, e, e, i), e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;
        var o = e.button;
        return null == e.which && void 0 !== o && im.test(e.type) && (e.which = 1 & o ? 1 : 2 & o ? 3 : 4 & o ? 2 : 0), 
        e;
    }
    function He(t, e, i) {
        em ? t.addEventListener(e, i) : t.attachEvent("on" + e, i);
    }
    function Ze(t) {
        return 1 < t.which;
    }
    function Ue(t) {
        var e = t[1][0] - t[0][0], i = t[1][1] - t[0][1];
        return Math.sqrt(e * e + i * i);
    }
    function je(t) {
        return "mousewheel" === t && Sp.browser.firefox ? "DOMMouseScroll" : t;
    }
    function Xe(t, e, i) {
        var n = t._gestureMgr;
        "start" === i && n.clear();
        var a = n.recognize(e, t.handler.findHover(e.zrX, e.zrY, null).target, t.dom);
        if ("end" === i && n.clear(), a) {
            var o = a.type;
            e.gestureEvent = o, t.handler.dispatchToElement({
                target: a.target
            }, o, a.event);
        }
    }
    function Ye(t) {
        t._touching = !0, clearTimeout(t._touchTimer), t._touchTimer = setTimeout(function() {
            t._touching = !1;
        }, 700);
    }
    function qe(t) {
        var e = t.pointerType;
        return "pen" === e || "touch" === e;
    }
    function Ke(i) {
        function t(t, e) {
            R(t, function(t) {
                He(i, je(t), e._handlers[t]);
            }, e);
        }
        var n;
        Up.call(this), this.dom = i, this._touching = !1, this._touchTimer, this._gestureMgr = new om(), 
        this._handlers = {}, n = this, R(lm, function(t) {
            n._handlers[t] = _(cm[t], n);
        }), R(um, function(t) {
            n._handlers[t] = _(cm[t], n);
        }), R(sm, function(t) {
            var e, i;
            n._handlers[t] = (e = cm[t], i = n, function() {
                if (!i._touching) return e.apply(i, arguments);
            });
        }), Sp.pointerEventsSupported ? t(um, this) : (Sp.touchEventsSupported && t(lm, this), 
        t(sm, this));
    }
    function $e(t, e) {
        var i = new mm(bp(), t, e);
        return gm[i.id] = i;
    }
    function Je(t, e) {
        pm[t] = e;
    }
    function Qe(t) {
        return t instanceof Array ? t : null == t ? [] : [ t ];
    }
    function ti(t, e, i) {
        if (t) {
            t[e] = t[e] || {}, t.emphasis = t.emphasis || {}, t.emphasis[e] = t.emphasis[e] || {};
            for (var n = 0, a = i.length; n < a; n++) {
                var o = i[n];
                !t.emphasis[e].hasOwnProperty(o) && t[e].hasOwnProperty(o) && (t.emphasis[e][o] = t[e][o]);
            }
        }
    }
    function ei(t) {
        return !xm(t) || _m(t) || t instanceof Date ? t : t.value;
    }
    function ii(t, a) {
        a = (a || []).slice();
        var o = L(t || [], function(t, e) {
            return {
                exist: t
            };
        });
        return ym(a, function(t, e) {
            if (xm(t)) {
                for (i = 0; i < o.length; i++) if (!o[i].option && null != t.id && o[i].exist.id === t.id + "") return o[i].option = t, 
                void (a[e] = null);
                for (var i = 0; i < o.length; i++) {
                    var n = o[i].exist;
                    if (!(o[i].option || null != n.id && null != t.id || null == t.name || oi(t) || oi(n) || n.name !== t.name + "")) return o[i].option = t, 
                    void (a[e] = null);
                }
            }
        }), ym(a, function(t, e) {
            if (xm(t)) {
                for (var i = 0; i < o.length; i++) {
                    var n = o[i].exist;
                    if (!o[i].option && !oi(n) && null == t.id) {
                        o[i].option = t;
                        break;
                    }
                }
                i >= o.length && o.push({
                    option: t
                });
            }
        }), o;
    }
    function ni(t) {
        var r = W();
        ym(t, function(t, e) {
            var i = t.exist;
            i && r.set(i.id, t);
        }), ym(t, function(t, e) {
            var i = t.option;
            c(!i || null == i.id || !r.get(i.id) || r.get(i.id) === t, "id duplicates: " + (i && i.id)), 
            i && null != i.id && r.set(i.id, t), !t.keyInfo && (t.keyInfo = {});
        }), ym(t, function(t, e) {
            var i = t.exist, n = t.option, a = t.keyInfo;
            if (xm(n)) {
                if (a.name = null != n.name ? n.name + "" : i ? i.name : wm + e, i) a.id = i.id; else if (null != n.id) a.id = n.id + ""; else for (var o = 0; a.id = "\0" + a.name + "\0" + o++, 
                r.get(a.id); ) ;
                r.set(a.id, t);
            }
        });
    }
    function ai(t) {
        var e = t.name;
        return !(!e || !e.indexOf(wm));
    }
    function oi(t) {
        return xm(t) && t.id && 0 === (t.id + "").indexOf("\0_ec_\0");
    }
    function ri(e, t) {
        return null != t.dataIndexInside ? t.dataIndexInside : null != t.dataIndex ? N(t.dataIndex) ? L(t.dataIndex, function(t) {
            return e.indexOfRawIndex(t);
        }) : e.indexOfRawIndex(t.dataIndex) : null != t.name ? N(t.name) ? L(t.name, function(t) {
            return e.indexOfName(t);
        }) : e.indexOfName(t.name) : void 0;
    }
    function si() {
        var e = "__\0ec_inner_" + Sm++ + "_" + Math.random().toFixed(5);
        return function(t) {
            return t[e] || (t[e] = {});
        };
    }
    function li(s, l, h) {
        if (b(l)) {
            var t = {};
            t[l + "Index"] = 0, l = t;
        }
        var e = h && h.defaultMainType;
        !e || hi(l, e + "Index") || hi(l, e + "Id") || hi(l, e + "Name") || (l[e + "Index"] = 0);
        var u = {};
        return ym(l, function(t, e) {
            t = l[e];
            if ("dataIndex" !== e && "dataIndexInside" !== e) {
                var i = e.match(/^(\w+)(Index|Id|Name)$/) || [], n = i[1], a = (i[2] || "").toLowerCase();
                if (!(!n || !a || null == t || "index" === a && "none" === t || h && h.includeMainTypes && C(h.includeMainTypes, n) < 0)) {
                    var o = {
                        mainType: n
                    };
                    "index" === a && "all" === t || (o[a] = t);
                    var r = s.queryComponents(o);
                    u[n + "Models"] = r, u[n + "Model"] = r[0];
                }
            } else u[e] = t;
        }), u;
    }
    function hi(t, e) {
        return t && t.hasOwnProperty(e);
    }
    function ui(t, e, i) {
        t.setAttribute ? t.setAttribute(e, i) : t[e] = i;
    }
    function ci(t) {
        var e = {
            main: "",
            sub: ""
        };
        return t && (t = t.split(Mm), e.main = t[0] || "", e.sub = t[1] || ""), e;
    }
    function di(t, e) {
        (t.$constructor = t).extend = function(t) {
            var e = this, i = function() {
                t.$constructor ? t.$constructor.apply(this, arguments) : e.apply(this, arguments);
            };
            return P(i.prototype, t), i.extend = this.extend, i.superCall = pi, i.superApply = gi, 
            o(i, this), i.superClass = e, i;
        };
    }
    function fi(t) {
        var e = [ "__\0is_clz", Tm++, Math.random().toFixed(3) ].join("_");
        t.prototype[e] = !0, t.isInstance = function(t) {
            return !(!t || !t[e]);
        };
    }
    function pi(t, e) {
        var i = s(arguments, 2);
        return this.superClass.prototype[e].apply(t, i);
    }
    function gi(t, e, i) {
        return this.superClass.prototype[e].apply(t, i);
    }
    function mi(i, t) {
        t = t || {};
        var o = {};
        if (i.registerClass = function(t, e) {
            return e && (c(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(a = e), 'componentType "' + a + '" illegal'), 
            (e = ci(e)).sub ? e.sub !== Im && ((i = e, n = o[i.main], n && n[Im] || ((n = o[i.main] = {})[Im] = !0), 
            n)[e.sub] = t) : o[e.main] = t), t;
            var i, n, a;
        }, i.getClass = function(t, e, i) {
            var n = o[t];
            if (n && n[Im] && (n = e ? n[e] : null), i && !n) throw new Error(e ? "Component " + t + "." + (e || "") + " not exists. Load it first." : t + ".type should be specified.");
            return n;
        }, i.getClassesByMainType = function(t) {
            t = ci(t);
            var i = [], e = o[t.main];
            return e && e[Im] ? R(e, function(t, e) {
                e !== Im && i.push(t);
            }) : i.push(e), i;
        }, i.hasClass = function(t) {
            return t = ci(t), !!o[t.main];
        }, i.getAllClassMainTypes = function() {
            var i = [];
            return R(o, function(t, e) {
                i.push(e);
            }), i;
        }, i.hasSubTypes = function(t) {
            t = ci(t);
            var e = o[t.main];
            return e && e[Im];
        }, i.parseClassType = ci, t.registerWhenExtend) {
            var n = i.extend;
            n && (i.extend = function(t) {
                var e = n.call(this, t);
                return i.registerClass(e, t.type);
            });
        }
        return i;
    }
    function vi(t) {
        return -Om < t && t < Om;
    }
    function yi(t) {
        return Om < t || t < -Om;
    }
    function xi(t, e, i, n, a) {
        var o = 1 - a;
        return o * o * (o * t + 3 * a * e) + a * a * (a * n + 3 * o * i);
    }
    function _i(t, e, i, n, a) {
        var o = 1 - a;
        return 3 * (((e - t) * o + 2 * (i - e) * a) * o + (n - i) * a * a);
    }
    function wi(t, e, i, n, a) {
        var o = 6 * i - 12 * e + 6 * t, r = 9 * e + 3 * n - 3 * t - 9 * i, s = 3 * e - 3 * t, l = 0;
        if (vi(r)) yi(o) && 0 <= (c = -s / o) && c <= 1 && (a[l++] = c); else {
            var h = o * o - 4 * r * s;
            if (vi(h)) a[0] = -o / (2 * r); else if (0 < h) {
                var u = Nm(h), c = (-o + u) / (2 * r), d = (-o - u) / (2 * r);
                0 <= c && c <= 1 && (a[l++] = c), 0 <= d && d <= 1 && (a[l++] = d);
            }
        }
        return l;
    }
    function bi(t, e, i, n, a, o) {
        var r = (e - t) * a + t, s = (i - e) * a + e, l = (n - i) * a + i, h = (s - r) * a + r, u = (l - s) * a + s, c = (u - h) * a + h;
        o[0] = t, o[1] = r, o[2] = h, o[3] = c, o[4] = c, o[5] = u, o[6] = l, o[7] = n;
    }
    function Si(t, e, i, n) {
        var a = 1 - n;
        return a * (a * t + 2 * n * e) + n * n * i;
    }
    function Mi(t, e, i, n) {
        return 2 * ((1 - n) * (e - t) + n * (i - e));
    }
    function Ii(t, e, i) {
        var n = t + i - 2 * e;
        return 0 === n ? .5 : (t - e) / n;
    }
    function Ti(t, e, i, n, a) {
        var o = (e - t) * n + t, r = (i - e) * n + e, s = (r - o) * n + o;
        a[0] = t, a[1] = o, a[2] = s, a[3] = s, a[4] = r, a[5] = i;
    }
    function Di(t, e, i) {
        if (0 !== t.length) {
            var n, a = t[0], o = a[0], r = a[0], s = a[1], l = a[1];
            for (n = 1; n < t.length; n++) a = t[n], o = Wm(o, a[0]), r = Fm(r, a[0]), s = Wm(s, a[1]), 
            l = Fm(l, a[1]);
            e[0] = o, e[1] = s, i[0] = r, i[1] = l;
        }
    }
    function Ai(t, e, i, n, a, o) {
        a[0] = Wm(t, i), a[1] = Wm(e, n), o[0] = Fm(t, i), o[1] = Fm(e, n);
    }
    function Ci(t, e, i, n, a, o, r, s, l, h) {
        var u, c = wi, d = xi, f = c(t, i, a, r, qm);
        for (l[0] = 1 / 0, l[1] = 1 / 0, h[0] = -1 / 0, h[1] = -1 / 0, u = 0; u < f; u++) {
            var p = d(t, i, a, r, qm[u]);
            l[0] = Wm(p, l[0]), h[0] = Fm(p, h[0]);
        }
        for (f = c(e, n, o, s, Km), u = 0; u < f; u++) {
            var g = d(e, n, o, s, Km[u]);
            l[1] = Wm(g, l[1]), h[1] = Fm(g, h[1]);
        }
        l[0] = Wm(t, l[0]), h[0] = Fm(t, h[0]), l[0] = Wm(r, l[0]), h[0] = Fm(r, h[0]), 
        l[1] = Wm(e, l[1]), h[1] = Fm(e, h[1]), l[1] = Wm(s, l[1]), h[1] = Fm(s, h[1]);
    }
    function Li(t, e, i, n, a, o, r, s, l) {
        var h = tt, u = et, c = Math.abs(a - o);
        if (c % Um < 1e-4 && 1e-4 < c) return s[0] = t - i, s[1] = e - n, l[0] = t + i, 
        void (l[1] = e + n);
        if (jm[0] = Zm(a) * i + t, jm[1] = Hm(a) * n + e, Xm[0] = Zm(o) * i + t, Xm[1] = Hm(o) * n + e, 
        h(s, jm, Xm), u(l, jm, Xm), (a %= Um) < 0 && (a += Um), (o %= Um) < 0 && (o += Um), 
        o < a && !r ? o += Um : a < o && r && (a += Um), r) {
            var d = o;
            o = a, a = d;
        }
        for (var f = 0; f < o; f += Math.PI / 2) a < f && (Ym[0] = Zm(f) * i + t, Ym[1] = Hm(f) * n + e, 
        h(s, Ym, s), u(l, Ym, l));
    }
    function ki(t, e, i, n, a, o, r) {
        if (0 === a) return !1;
        var s, l = a;
        if (e + l < r && n + l < r || r < e - l && r < n - l || t + l < o && i + l < o || o < t - l && o < i - l) return !1;
        if (t === i) return Math.abs(o - t) <= l / 2;
        var h = (s = (e - n) / (t - i)) * o - r + (t * n - i * e) / (t - i);
        return h * h / (s * s + 1) <= l / 2 * l / 2;
    }
    function Pi(t, e, i, n, a, o, r, s, l, h, u) {
        if (0 === l) return !1;
        var c = l;
        return !(e + c < u && n + c < u && o + c < u && s + c < u || u < e - c && u < n - c && u < o - c && u < s - c || t + c < h && i + c < h && a + c < h && r + c < h || h < t - c && h < i - c && h < a - c && h < r - c) && function(t, e, i, n, a, o, r, s, l, h, u) {
            var c, d, f, p, g, m = .005, v = 1 / 0;
            Bm[0] = l, Bm[1] = h;
            for (var y = 0; y < 1; y += .05) Vm[0] = xi(t, i, a, r, y), Vm[1] = xi(e, n, o, s, y), 
            (p = Fp(Bm, Vm)) < v && (c = y, v = p);
            v = 1 / 0;
            for (var x = 0; x < 32 && !(m < Em); x++) d = c - m, f = c + m, Vm[0] = xi(t, i, a, r, d), 
            Vm[1] = xi(e, n, o, s, d), p = Fp(Vm, Bm), 0 <= d && p < v ? (c = d, v = p) : (Gm[0] = xi(t, i, a, r, f), 
            Gm[1] = xi(e, n, o, s, f), g = Fp(Gm, Bm), f <= 1 && g < v ? (c = f, v = g) : m *= .5);
            return u && (u[0] = xi(t, i, a, r, c), u[1] = xi(e, n, o, s, c)), Nm(v);
        }(t, e, i, n, a, o, r, s, h, u, null) <= c / 2;
    }
    function Ni(t, e, i, n, a, o, r, s, l) {
        if (0 === r) return !1;
        var h = r;
        return !(e + h < l && n + h < l && o + h < l || l < e - h && l < n - h && l < o - h || t + h < s && i + h < s && a + h < s || s < t - h && s < i - h && s < a - h) && function(t, e, i, n, a, o, r, s, l) {
            var h, u = .005, c = 1 / 0;
            Bm[0] = r, Bm[1] = s;
            for (var d = 0; d < 1; d += .05) Vm[0] = Si(t, i, a, d), Vm[1] = Si(e, n, o, d), 
            (m = Fp(Bm, Vm)) < c && (h = d, c = m);
            c = 1 / 0;
            for (var f = 0; f < 32 && !(u < Em); f++) {
                var p = h - u, g = h + u;
                Vm[0] = Si(t, i, a, p), Vm[1] = Si(e, n, o, p);
                var m = Fp(Vm, Bm);
                if (0 <= p && m < c) h = p, c = m; else {
                    Gm[0] = Si(t, i, a, g), Gm[1] = Si(e, n, o, g);
                    var v = Fp(Gm, Bm);
                    g <= 1 && v < c ? (h = g, c = v) : u *= .5;
                }
            }
            return l && (l[0] = Si(t, i, a, h), l[1] = Si(e, n, o, h)), Nm(c);
        }(t, e, i, n, a, o, s, l, null) <= h / 2;
    }
    function Oi(t) {
        return (t %= uv) < 0 && (t += uv), t;
    }
    function Ei(t, e, i, n, a, o, r, s, l) {
        if (0 === r) return !1;
        var h = r;
        s -= t, l -= e;
        var u = Math.sqrt(s * s + l * l);
        if (i < u - h || u + h < i) return !1;
        if (Math.abs(n - a) % cv < 1e-4) return !0;
        if (o) {
            var c = n;
            n = Oi(a), a = Oi(c);
        } else n = Oi(n), a = Oi(a);
        a < n && (a += cv);
        var d = Math.atan2(l, s);
        return d < 0 && (d += cv), n <= d && d <= a || n <= d + cv && d + cv <= a;
    }
    function Ri(t, e, i, n, a, o) {
        if (e < o && n < o || o < e && o < n) return 0;
        if (n === e) return 0;
        var r = n < e ? 1 : -1, s = (o - e) / (n - e);
        return 1 !== s && 0 !== s || (r = n < e ? .5 : -.5), a < s * (i - t) + t ? r : 0;
    }
    function zi(t, e, i, n, a, o, r, s, l, h) {
        if (e < h && n < h && o < h && s < h || h < e && h < n && h < o && h < s) return 0;
        var u, c = function(t, e, i, n, a, o) {
            var r = n + 3 * (e - i) - t, s = 3 * (i - 2 * e + t), l = 3 * (e - t), h = t - a, u = s * s - 3 * r * l, c = s * l - 9 * r * h, d = l * l - 3 * s * h, f = 0;
            if (vi(u) && vi(c)) vi(s) ? o[0] = 0 : 0 <= (M = -l / s) && M <= 1 && (o[f++] = M); else {
                var p = c * c - 4 * u * d;
                if (vi(p)) {
                    var g = c / u, m = -g / 2;
                    0 <= (M = -s / r + g) && M <= 1 && (o[f++] = M), 0 <= m && m <= 1 && (o[f++] = m);
                } else if (0 < p) {
                    var v = Nm(p), y = u * s + 1.5 * r * (-c + v), x = u * s + 1.5 * r * (-c - v);
                    0 <= (M = (-s - ((y = y < 0 ? -Pm(-y, zm) : Pm(y, zm)) + (x = x < 0 ? -Pm(-x, zm) : Pm(x, zm)))) / (3 * r)) && M <= 1 && (o[f++] = M);
                } else {
                    var _ = (2 * u * s - 3 * r * c) / (2 * Nm(u * u * u)), w = Math.acos(_) / 3, b = Nm(u), S = Math.cos(w), M = (-s - 2 * b * S) / (3 * r), I = (m = (-s + b * (S + Rm * Math.sin(w))) / (3 * r), 
                    (-s + b * (S - Rm * Math.sin(w))) / (3 * r));
                    0 <= M && M <= 1 && (o[f++] = M), 0 <= m && m <= 1 && (o[f++] = m), 0 <= I && I <= 1 && (o[f++] = I);
                }
            }
            return f;
        }(e, n, o, s, h, gv);
        if (0 === c) return 0;
        for (var d, f, p = 0, g = -1, m = 0; m < c; m++) {
            var v = gv[m], y = 0 === v || 1 === v ? .5 : 1;
            xi(t, i, a, r, v) < l || (g < 0 && (g = wi(e, n, o, s, mv), mv[1] < mv[0] && 1 < g && (void 0, 
            u = mv[0], mv[0] = mv[1], mv[1] = u), d = xi(e, n, o, s, mv[0]), 1 < g && (f = xi(e, n, o, s, mv[1]))), 
            2 == g ? v < mv[0] ? p += d < e ? y : -y : v < mv[1] ? p += f < d ? y : -y : p += s < f ? y : -y : v < mv[0] ? p += d < e ? y : -y : p += s < d ? y : -y);
        }
        return p;
    }
    function Bi(t, e, i, n, a, o, r, s) {
        if (e < s && n < s && o < s || s < e && s < n && s < o) return 0;
        var l = function(t, e, i, n, a) {
            var o = t - 2 * e + i, r = 2 * (e - t), s = t - n, l = 0;
            if (vi(o)) yi(r) && 0 <= (c = -s / r) && c <= 1 && (a[l++] = c); else {
                var h = r * r - 4 * o * s;
                if (vi(h)) 0 <= (c = -r / (2 * o)) && c <= 1 && (a[l++] = c); else if (0 < h) {
                    var u = Nm(h), c = (-r + u) / (2 * o), d = (-r - u) / (2 * o);
                    0 <= c && c <= 1 && (a[l++] = c), 0 <= d && d <= 1 && (a[l++] = d);
                }
            }
            return l;
        }(e, n, o, s, gv);
        if (0 === l) return 0;
        var h = Ii(e, n, o);
        if (0 <= h && h <= 1) {
            for (var u = 0, c = Si(e, n, o, h), d = 0; d < l; d++) f = 0 === gv[d] || 1 === gv[d] ? .5 : 1, 
            (p = Si(t, i, a, gv[d])) < r || (gv[d] < h ? u += c < e ? f : -f : u += o < c ? f : -f);
            return u;
        }
        var f = 0 === gv[0] || 1 === gv[0] ? .5 : 1, p = Si(t, i, a, gv[0]);
        return p < r ? 0 : o < e ? f : -f;
    }
    function Vi(t, e, i, n, a, o, r, s) {
        if ((s -= e) > i || s < -i) return 0;
        h = Math.sqrt(i * i - s * s), gv[0] = -h, gv[1] = h;
        var l = Math.abs(n - a);
        if (l < 1e-4) return 0;
        if (l % fv < 1e-4) return a = fv, p = o ? 1 : -1, r >= gv[n = 0] + t && r <= gv[1] + t ? p : 0;
        if (o) {
            var h = n;
            n = Oi(a), a = Oi(h);
        } else n = Oi(n), a = Oi(a);
        a < n && (a += fv);
        for (var u = 0, c = 0; c < 2; c++) {
            var d = gv[c];
            if (r < d + t) {
                var f = Math.atan2(s, d), p = o ? 1 : -1;
                f < 0 && (f = fv + f), (n <= f && f <= a || n <= f + fv && f + fv <= a) && (f > Math.PI / 2 && f < 1.5 * Math.PI && (p = -p), 
                u += p);
            }
        }
        return u;
    }
    function Gi(t, e, i, n, a) {
        for (var o = 0, r = 0, s = 0, l = 0, h = 0, u = 0; u < t.length; ) {
            var c = t[u++];
            switch (c === dv.M && 1 < u && (i || (o += Ri(r, s, l, h, n, a))), 1 == u && (l = r = t[u], 
            h = s = t[u + 1]), c) {
              case dv.M:
                r = l = t[u++], s = h = t[u++];
                break;

              case dv.L:
                if (i) {
                    if (ki(r, s, t[u], t[u + 1], e, n, a)) return !0;
                } else o += Ri(r, s, t[u], t[u + 1], n, a) || 0;
                r = t[u++], s = t[u++];
                break;

              case dv.C:
                if (i) {
                    if (Pi(r, s, t[u++], t[u++], t[u++], t[u++], t[u], t[u + 1], e, n, a)) return !0;
                } else o += zi(r, s, t[u++], t[u++], t[u++], t[u++], t[u], t[u + 1], n, a) || 0;
                r = t[u++], s = t[u++];
                break;

              case dv.Q:
                if (i) {
                    if (Ni(r, s, t[u++], t[u++], t[u], t[u + 1], e, n, a)) return !0;
                } else o += Bi(r, s, t[u++], t[u++], t[u], t[u + 1], n, a) || 0;
                r = t[u++], s = t[u++];
                break;

              case dv.A:
                var d = t[u++], f = t[u++], p = t[u++], g = t[u++], m = t[u++], v = t[u++], y = (t[u++], 
                1 - t[u++]), x = Math.cos(m) * p + d, _ = Math.sin(m) * g + f;
                1 < u ? o += Ri(r, s, x, _, n, a) : (l = x, h = _);
                var w = (n - d) * g / p + d;
                if (i) {
                    if (Ei(d, f, g, m, m + v, y, e, w, a)) return !0;
                } else o += Vi(d, f, g, m, m + v, y, w, a);
                r = Math.cos(m + v) * p + d, s = Math.sin(m + v) * g + f;
                break;

              case dv.R:
                l = r = t[u++], h = s = t[u++];
                x = l + t[u++], _ = h + t[u++];
                if (i) {
                    if (ki(l, h, x, h, e, n, a) || ki(x, h, x, _, e, n, a) || ki(x, _, l, _, e, n, a) || ki(l, _, l, h, e, n, a)) return !0;
                } else o += Ri(x, h, x, _, n, a), o += Ri(l, _, l, h, n, a);
                break;

              case dv.Z:
                if (i) {
                    if (ki(r, s, l, h, e, n, a)) return !0;
                } else o += Ri(r, s, l, h, n, a);
                r = l, s = h;
            }
        }
        return i || (b = s, S = h, Math.abs(b - S) < pv) || (o += Ri(r, s, l, h, n, a) || 0), 
        0 !== o;
        var b, S;
    }
    function Wi(t) {
        ze.call(this, t), this.path = null;
    }
    function Fi(t, e, i, n, a, o, r, s, l, h, u) {
        var c = l * (Cv / 180), d = Av(c) * (t - i) / 2 + Dv(c) * (e - n) / 2, f = -1 * Dv(c) * (t - i) / 2 + Av(c) * (e - n) / 2, p = d * d / (r * r) + f * f / (s * s);
        1 < p && (r *= Tv(p), s *= Tv(p));
        var g = (a === o ? -1 : 1) * Tv((r * r * (s * s) - r * r * (f * f) - s * s * (d * d)) / (r * r * (f * f) + s * s * (d * d))) || 0, m = g * r * f / s, v = g * -s * d / r, y = (t + i) / 2 + Av(c) * m - Dv(c) * v, x = (e + n) / 2 + Dv(c) * m + Av(c) * v, _ = Pv([ 1, 0 ], [ (d - m) / r, (f - v) / s ]), w = [ (d - m) / r, (f - v) / s ], b = [ (-1 * d - m) / r, (-1 * f - v) / s ], S = Pv(w, b);
        kv(w, b) <= -1 && (S = Cv), 1 <= kv(w, b) && (S = 0), 0 === o && 0 < S && (S -= 2 * Cv), 
        1 === o && S < 0 && (S += 2 * Cv), u.addData(h, y, x, r, s, _, S, c, o);
    }
    function Hi(t, e) {
        var i = function(t) {
            if (!t) return [];
            var e, i = t.replace(/-/g, " -").replace(/  /g, " ").replace(/ /g, ",").replace(/,,/g, ",");
            for (e = 0; e < Iv.length; e++) i = i.replace(new RegExp(Iv[e], "g"), "|" + Iv[e]);
            var n, a = i.split("|"), o = 0, r = 0, s = new hv(), l = hv.CMD;
            for (e = 1; e < a.length; e++) {
                var h, u = a[e], c = u.charAt(0), d = 0, f = u.slice(1).replace(/e,-/g, "e-").split(",");
                0 < f.length && "" === f[0] && f.shift();
                for (var p = 0; p < f.length; p++) f[p] = parseFloat(f[p]);
                for (;d < f.length && !isNaN(f[d]) && !isNaN(f[0]); ) {
                    var g, m, v, y, x, _, w, b = o, S = r;
                    switch (c) {
                      case "l":
                        o += f[d++], r += f[d++], h = l.L, s.addData(h, o, r);
                        break;

                      case "L":
                        o = f[d++], r = f[d++], h = l.L, s.addData(h, o, r);
                        break;

                      case "m":
                        o += f[d++], r += f[d++], h = l.M, s.addData(h, o, r), c = "l";
                        break;

                      case "M":
                        o = f[d++], r = f[d++], h = l.M, s.addData(h, o, r), c = "L";
                        break;

                      case "h":
                        o += f[d++], h = l.L, s.addData(h, o, r);
                        break;

                      case "H":
                        o = f[d++], h = l.L, s.addData(h, o, r);
                        break;

                      case "v":
                        r += f[d++], h = l.L, s.addData(h, o, r);
                        break;

                      case "V":
                        r = f[d++], h = l.L, s.addData(h, o, r);
                        break;

                      case "C":
                        h = l.C, s.addData(h, f[d++], f[d++], f[d++], f[d++], f[d++], f[d++]), o = f[d - 2], 
                        r = f[d - 1];
                        break;

                      case "c":
                        h = l.C, s.addData(h, f[d++] + o, f[d++] + r, f[d++] + o, f[d++] + r, f[d++] + o, f[d++] + r), 
                        o += f[d - 2], r += f[d - 1];
                        break;

                      case "S":
                        g = o, m = r;
                        var M = s.len(), I = s.data;
                        n === l.C && (g += o - I[M - 4], m += r - I[M - 3]), h = l.C, b = f[d++], S = f[d++], 
                        o = f[d++], r = f[d++], s.addData(h, g, m, b, S, o, r);
                        break;

                      case "s":
                        g = o, m = r, M = s.len(), I = s.data, n === l.C && (g += o - I[M - 4], m += r - I[M - 3]), 
                        h = l.C, b = o + f[d++], S = r + f[d++], o += f[d++], r += f[d++], s.addData(h, g, m, b, S, o, r);
                        break;

                      case "Q":
                        b = f[d++], S = f[d++], o = f[d++], r = f[d++], h = l.Q, s.addData(h, b, S, o, r);
                        break;

                      case "q":
                        b = f[d++] + o, S = f[d++] + r, o += f[d++], r += f[d++], h = l.Q, s.addData(h, b, S, o, r);
                        break;

                      case "T":
                        g = o, m = r, M = s.len(), I = s.data, n === l.Q && (g += o - I[M - 4], m += r - I[M - 3]), 
                        o = f[d++], r = f[d++], h = l.Q, s.addData(h, g, m, o, r);
                        break;

                      case "t":
                        g = o, m = r, M = s.len(), I = s.data, n === l.Q && (g += o - I[M - 4], m += r - I[M - 3]), 
                        o += f[d++], r += f[d++], h = l.Q, s.addData(h, g, m, o, r);
                        break;

                      case "A":
                        v = f[d++], y = f[d++], x = f[d++], _ = f[d++], w = f[d++], Fi(b = o, S = r, o = f[d++], r = f[d++], _, w, v, y, x, h = l.A, s);
                        break;

                      case "a":
                        v = f[d++], y = f[d++], x = f[d++], _ = f[d++], w = f[d++], Fi(b = o, S = r, o += f[d++], r += f[d++], _, w, v, y, x, h = l.A, s);
                    }
                }
                "z" !== c && "Z" !== c || (h = l.Z, s.addData(h)), n = h;
            }
            return s.toStatic(), s;
        }(t);
        return (e = e || {}).buildPath = function(t) {
            if (t.setData) t.setData(i.data), (e = t.getContext()) && t.rebuildPath(e); else {
                var e = t;
                i.rebuildPath(e);
            }
        }, e.applyTransform = function(t) {
            Mv(i, t), this.dirty(!0);
        }, e;
    }
    function Zi(t, e, i, n, a, o, r) {
        var s = .5 * (i - t), l = .5 * (n - e);
        return (2 * (e - i) + s + l) * r + (-3 * (e - i) - 2 * s - l) * o + s * a + e;
    }
    function Ui(t, e, i) {
        var n = e.points, a = e.smooth;
        if (n && 2 <= n.length) {
            if (a && "spline" !== a) {
                var o = function(t, e, i, n) {
                    var a, o, r, s, l = [], h = [], u = [], c = [];
                    if (n) {
                        r = [ 1 / 0, 1 / 0 ], s = [ -1 / 0, -1 / 0 ];
                        for (var d = 0, f = t.length; d < f; d++) tt(r, r, t[d]), et(s, s, t[d]);
                        tt(r, r, n[0]), et(s, s, n[1]);
                    }
                    for (var d = 0, f = t.length; d < f; d++) {
                        var p = t[d];
                        if (i) a = t[d ? d - 1 : f - 1], o = t[(d + 1) % f]; else {
                            if (0 === d || d === f - 1) {
                                l.push(D(t[d]));
                                continue;
                            }
                            a = t[d - 1], o = t[d + 1];
                        }
                        U(h, o, a), Y(h, h, e);
                        var g = K(p, a), m = K(p, o), v = g + m;
                        0 !== v && (g /= v, m /= v), Y(u, h, -g), Y(c, h, m);
                        var y = H([], p, u), x = H([], p, c);
                        n && (et(y, y, r), tt(y, y, s), et(x, x, r), tt(x, x, s)), l.push(y), l.push(x);
                    }
                    return i && l.push(l.shift()), l;
                }(n, a, i, e.smoothConstraint);
                t.moveTo(n[0][0], n[0][1]);
                for (var r = n.length, s = 0; s < (i ? r : r - 1); s++) {
                    var l = o[2 * s], h = o[2 * s + 1], u = n[(s + 1) % r];
                    t.bezierCurveTo(l[0], l[1], h[0], h[1], u[0], u[1]);
                }
            } else {
                "spline" === a && (n = function(t, e) {
                    for (var i = t.length, n = [], a = 0, o = 1; o < i; o++) a += K(t[o - 1], t[o]);
                    var r = a / 2;
                    for (r = r < i ? i : r, o = 0; o < r; o++) {
                        var s, l, h, u = o / (r - 1) * (e ? i : i - 1), c = Math.floor(u), d = u - c, f = t[c % i];
                        e ? (s = t[(c - 1 + i) % i], l = t[(c + 1) % i], h = t[(c + 2) % i]) : (s = t[0 === c ? c : c - 1], 
                        l = t[i - 2 < c ? i - 1 : c + 1], h = t[i - 3 < c ? i - 1 : c + 2]);
                        var p = d * d, g = d * p;
                        n.push([ Zi(s[0], f[0], l[0], h[0], d, p, g), Zi(s[1], f[1], l[1], h[1], d, p, g) ]);
                    }
                    return n;
                }(n, i)), t.moveTo(n[0][0], n[0][1]);
                s = 1;
                for (var c = n.length; s < c; s++) t.lineTo(n[s][0], n[s][1]);
            }
            i && t.closePath();
        }
    }
    function ji(t, e, i) {
        var n = t.cpx2, a = t.cpy2;
        return null === n || null === a ? [ (i ? _i : xi)(t.x1, t.cpx1, t.cpx2, t.x2, e), (i ? _i : xi)(t.y1, t.cpy1, t.cpy2, t.y2, e) ] : [ (i ? Mi : Si)(t.x1, t.cpx1, t.x2, e), (i ? Mi : Si)(t.y1, t.cpy1, t.y2, e) ];
    }
    function Xi(t) {
        ze.call(this, t), this._displayables = [], this._temporaryDisplayables = [], this._cursor = 0, 
        this.notClear = !0;
    }
    function Yi(t) {
        return Wi.extend(t);
    }
    function qi(t, e, i, n) {
        var a = new Wi(Hi(t, e)), o = a.getBoundingRect();
        return i && ("center" === n && (i = $i(i, o)), Ji(a, i)), a;
    }
    function Ki(t, i, n) {
        var a = new Be({
            style: {
                image: t,
                x: i.x,
                y: i.y,
                width: i.width,
                height: i.height
            },
            onload: function(t) {
                if ("center" === n) {
                    var e = {
                        width: t.width,
                        height: t.height
                    };
                    a.setStyle($i(i, e));
                }
            }
        });
        return a;
    }
    function $i(t, e) {
        var i, n = e.width / e.height, a = t.height * n;
        return i = a <= t.width ? t.height : (a = t.width) / n, {
            x: t.x + t.width / 2 - a / 2,
            y: t.y + t.height / 2 - i / 2,
            width: a,
            height: i
        };
    }
    function Ji(t, e) {
        if (t.applyTransform) {
            var i = t.getBoundingRect().calculateTransform(e);
            t.applyTransform(i);
        }
    }
    function Qi(t) {
        var e = t.shape, i = t.style.lineWidth;
        return $v(2 * e.x1) === $v(2 * e.x2) && (e.x1 = e.x2 = en(e.x1, i, !0)), $v(2 * e.y1) === $v(2 * e.y2) && (e.y1 = e.y2 = en(e.y1, i, !0)), 
        t;
    }
    function tn(t) {
        var e = t.shape, i = t.style.lineWidth, n = e.x, a = e.y, o = e.width, r = e.height;
        return e.x = en(e.x, i, !0), e.y = en(e.y, i, !0), e.width = Math.max(en(n + o, i, !1) - e.x, 0 === o ? 0 : 1), 
        e.height = Math.max(en(a + r, i, !1) - e.y, 0 === r ? 0 : 1), t;
    }
    function en(t, e, i) {
        var n = $v(2 * t);
        return (n + $v(e)) % 2 == 0 ? n / 2 : (n + (i ? 1 : -1)) / 2;
    }
    function nn(t) {
        return null != t && "none" != t;
    }
    function an(t) {
        return "string" == typeof t ? At(t, -.1) : t;
    }
    function on(t) {
        if (t.__hoverStlDirty) {
            var e = t.style.stroke, i = t.style.fill, n = t.__hoverStl;
            n.fill = n.fill || (nn(i) ? an(i) : null), n.stroke = n.stroke || (nn(e) ? an(e) : null);
            var a = {};
            for (var o in n) null != n[o] && (a[o] = t.style[o]);
            t.__normalStl = a, t.__hoverStlDirty = !1;
        }
    }
    function rn(t) {
        if (!t.__isHover) {
            if (on(t), t.useHoverLayer) t.__zr && t.__zr.addHover(t, t.__hoverStl); else {
                var e = t.style, i = e.insideRollbackOpt;
                i && ((a = (n = e).insideRollback) && (n.textFill = a.textFill, n.textStroke = a.textStroke, 
                n.textStrokeWidth = a.textStrokeWidth)), e.extendFrom(t.__hoverStl), i && (wn(e, e.insideOriginalTextPosition, i), 
                null == e.textFill && (e.textFill = i.autoColor)), t.dirty(!1), t.z2 += 1;
            }
            t.__isHover = !0;
        }
        var n, a;
    }
    function sn(t) {
        if (t.__isHover) {
            var e = t.__normalStl;
            t.useHoverLayer ? t.__zr && t.__zr.removeHover(t) : (e && t.setStyle(e), t.z2 -= 1), 
            t.__isHover = !1;
        }
    }
    function ln(t) {
        "group" === t.type ? t.traverse(function(t) {
            "group" !== t.type && rn(t);
        }) : rn(t);
    }
    function hn(t) {
        "group" === t.type ? t.traverse(function(t) {
            "group" !== t.type && sn(t);
        }) : sn(t);
    }
    function un(t, e) {
        t.__hoverStl = t.hoverStyle || e || {}, t.__hoverStlDirty = !0, t.__isHover && on(t);
    }
    function cn(t) {
        this.__hoverSilentOnTouch && t.zrByTouch || !this.__isEmphasis && ln(this);
    }
    function dn(t) {
        this.__hoverSilentOnTouch && t.zrByTouch || !this.__isEmphasis && hn(this);
    }
    function fn() {
        this.__isEmphasis = !0, ln(this);
    }
    function pn() {
        this.__isEmphasis = !1, hn(this);
    }
    function gn(t, e, i) {
        t.__hoverSilentOnTouch = i && i.hoverSilentOnTouch, "group" === t.type ? t.traverse(function(t) {
            "group" !== t.type && un(t, e);
        }) : un(t, e), t.on("mouseover", cn).on("mouseout", dn), t.on("emphasis", fn).on("normal", pn);
    }
    function mn(t, e, i, n, a, o, r) {
        var s, l = (a = a || ty).labelFetcher, h = a.labelDataIndex, u = a.labelDimIndex, c = i.getShallow("show"), d = n.getShallow("show");
        (c || d) && (l && (s = l.getFormattedLabel(h, "normal", null, u)), null == s && (s = m(a.defaultText) ? a.defaultText(h, a) : a.defaultText));
        var f = c ? s : null, p = d ? k(l ? l.getFormattedLabel(h, "emphasis", null, u) : null, s) : null;
        null == f && null == p || (vn(t, i, o, a), vn(e, n, r, a, !0)), t.text = f, e.text = p;
    }
    function vn(t, e, i, n, a) {
        return yn(t, e, n, a), i && P(t, i), t.host && t.host.dirty && t.host.dirty(!1), 
        t;
    }
    function yn(t, e, i, n) {
        if ((i = i || ty).isRectText) {
            var a = e.getShallow("position") || (n ? null : "inside");
            "outside" === a && (a = "top"), t.textPosition = a, t.textOffset = e.getShallow("offset");
            var o = e.getShallow("rotate");
            null != o && (o *= Math.PI / 180), t.textRotation = o, t.textDistance = k(e.getShallow("distance"), n ? null : 5);
        }
        var r, s = e.ecModel, l = s && s.option.textStyle, h = function(t) {
            for (var e; t && t !== t.ecModel; ) {
                var i = (t.option || ty).rich;
                if (i) for (var n in e = e || {}, i) i.hasOwnProperty(n) && (e[n] = 1);
                t = t.parentModel;
            }
            return e;
        }(e);
        if (h) for (var u in r = {}, h) if (h.hasOwnProperty(u)) {
            var c = e.getModel([ "rich", u ]);
            xn(r[u] = {}, c, l, i, n);
        }
        return t.rich = r, xn(t, e, l, i, n, !0), i.forceRich && !i.textStyle && (i.textStyle = {}), 
        t;
    }
    function xn(t, e, i, n, a, o) {
        if (i = !a && i || ty, t.textFill = _n(e.getShallow("color"), n) || i.color, t.textStroke = _n(e.getShallow("textBorderColor"), n) || i.textBorderColor, 
        t.textStrokeWidth = k(e.getShallow("textBorderWidth"), i.textBorderWidth), !a) {
            if (o) {
                var r = t.textPosition;
                t.insideRollback = wn(t, r, n), t.insideOriginalTextPosition = r, t.insideRollbackOpt = n;
            }
            null == t.textFill && (t.textFill = n.autoColor);
        }
        t.fontStyle = e.getShallow("fontStyle") || i.fontStyle, t.fontWeight = e.getShallow("fontWeight") || i.fontWeight, 
        t.fontSize = e.getShallow("fontSize") || i.fontSize, t.fontFamily = e.getShallow("fontFamily") || i.fontFamily, 
        t.textAlign = e.getShallow("align"), t.textVerticalAlign = e.getShallow("verticalAlign") || e.getShallow("baseline"), 
        t.textLineHeight = e.getShallow("lineHeight"), t.textWidth = e.getShallow("width"), 
        t.textHeight = e.getShallow("height"), t.textTag = e.getShallow("tag"), o && n.disableBox || (t.textBackgroundColor = _n(e.getShallow("backgroundColor"), n), 
        t.textPadding = e.getShallow("padding"), t.textBorderColor = _n(e.getShallow("borderColor"), n), 
        t.textBorderWidth = e.getShallow("borderWidth"), t.textBorderRadius = e.getShallow("borderRadius"), 
        t.textBoxShadowColor = e.getShallow("shadowColor"), t.textBoxShadowBlur = e.getShallow("shadowBlur"), 
        t.textBoxShadowOffsetX = e.getShallow("shadowOffsetX"), t.textBoxShadowOffsetY = e.getShallow("shadowOffsetY")), 
        t.textShadowColor = e.getShallow("textShadowColor") || i.textShadowColor, t.textShadowBlur = e.getShallow("textShadowBlur") || i.textShadowBlur, 
        t.textShadowOffsetX = e.getShallow("textShadowOffsetX") || i.textShadowOffsetX, 
        t.textShadowOffsetY = e.getShallow("textShadowOffsetY") || i.textShadowOffsetY;
    }
    function _n(t, e) {
        return "auto" !== t ? t : e && e.autoColor ? e.autoColor : null;
    }
    function wn(t, e, i) {
        var n, a = i.useInsideStyle;
        return null == t.textFill && !1 !== a && (!0 === a || i.isRectText && e && "string" == typeof e && 0 <= e.indexOf("inside")) && (n = {
            textFill: null,
            textStroke: t.textStroke,
            textStrokeWidth: t.textStrokeWidth
        }, t.textFill = "#fff", null == t.textStroke && (t.textStroke = i.autoColor, null == t.textStrokeWidth && (t.textStrokeWidth = 2))), 
        n;
    }
    function bn(t, e) {
        var i = e || e.getModel("textStyle");
        return h([ t.fontStyle || i && i.getShallow("fontStyle") || "", t.fontWeight || i && i.getShallow("fontWeight") || "", (t.fontSize || i && i.getShallow("fontSize") || 12) + "px", t.fontFamily || i && i.getShallow("fontFamily") || "sans-serif" ].join(" "));
    }
    function Sn(t, e, i, n, a, o) {
        if ("function" == typeof a && (o = a, a = null), n && n.isAnimationEnabled()) {
            var r = t ? "Update" : "", s = n.getShallow("animationDuration" + r), l = n.getShallow("animationEasing" + r), h = n.getShallow("animationDelay" + r);
            "function" == typeof h && (h = h(a, n.getAnimationDelayParams ? n.getAnimationDelayParams(e, a) : null)), 
            "function" == typeof s && (s = s(a)), 0 < s ? e.animateTo(i, s, h || 0, l, o, !!o) : (e.stopAnimation(), 
            e.attr(i), o && o());
        } else e.stopAnimation(), e.attr(i), o && o();
    }
    function Mn(t, e, i, n, a) {
        Sn(!0, t, e, i, n, a);
    }
    function In(t, e, i, n, a) {
        Sn(!1, t, e, i, n, a);
    }
    function Tn(t, e) {
        for (var i = st([]); t && t !== e; ) ht(i, t.getLocalTransform(), i), t = t.parent;
        return i;
    }
    function Dn(t, e, i) {
        return e && !O(e) && (e = Jp.getLocalTransform(e)), i && (e = ft([], e)), Q([], t, e);
    }
    function An(t, e, i) {
        var n = 0 === e[4] || 0 === e[5] || 0 === e[0] ? 1 : Math.abs(2 * e[4] / e[0]), a = 0 === e[4] || 0 === e[5] || 0 === e[2] ? 1 : Math.abs(2 * e[4] / e[2]), o = [ "left" === t ? -n : "right" === t ? n : 0, "top" === t ? -a : "bottom" === t ? a : 0 ];
        return o = Dn(o, e, i), Math.abs(o[0]) > Math.abs(o[1]) ? 0 < o[0] ? "right" : "left" : 0 < o[1] ? "bottom" : "top";
    }
    function Cn(t, e, n, i) {
        function a(t) {
            var e = {
                position: D(t.position),
                rotation: t.rotation
            };
            return t.shape && (e.shape = P({}, t.shape)), e;
        }
        if (t && e) {
            var o = (r = {}, t.traverse(function(t) {
                !t.isGroup && t.anid && (r[t.anid] = t);
            }), r);
            e.traverse(function(t) {
                if (!t.isGroup && t.anid) {
                    var e = o[t.anid];
                    if (e) {
                        var i = a(t);
                        t.attr(a(e)), Mn(t, i, n, t.dataIndex);
                    }
                }
            });
        }
        var r;
    }
    function Ln(t, n) {
        return L(t, function(t) {
            var e = t[0];
            e = Jv(e, n.x), e = Qv(e, n.x + n.width);
            var i = t[1];
            return i = Jv(i, n.y), [ e, i = Qv(i, n.y + n.height) ];
        });
    }
    function kn(t, e, i) {
        var n = (e = P({
            rectHover: !0
        }, e)).style = {
            strokeNoScale: !0
        };
        if (i = i || {
            x: -1,
            y: -1,
            width: 2,
            height: 2
        }, t) return 0 === t.indexOf("image://") ? (n.image = t.slice(8), E(n, i), new Be(e)) : qi(t.replace("path://", ""), e, i, "center");
    }
    function Pn(t, e, i) {
        this.parentModel = e, this.ecModel = i, this.option = t;
    }
    function Nn(t, e, i) {
        for (var n = 0; n < e.length && (!e[n] || null != (t = t && "object" == (void 0 === t ? "undefined" : _typeof(t)) ? t[e[n]] : null)); n++) ;
        return null == t && i && (t = i.get(e)), t;
    }
    function On(t, e) {
        var i = ly(t).getParent;
        return i ? i.call(t, e) : t.parentModel;
    }
    function En(t) {
        return [ t || "", cy++, Math.random().toFixed(5) ].join("_");
    }
    function Rn(t, e, i, n) {
        var a = e[1] - e[0], o = i[1] - i[0];
        if (0 === a) return 0 === o ? i[0] : (i[0] + i[1]) / 2;
        if (n) if (0 < a) {
            if (t <= e[0]) return i[0];
            if (t >= e[1]) return i[1];
        } else {
            if (t >= e[0]) return i[0];
            if (t <= e[1]) return i[1];
        } else {
            if (t === e[0]) return i[0];
            if (t === e[1]) return i[1];
        }
        return (t - e[0]) / a * o + i[0];
    }
    function zn(t, e) {
        switch (t) {
          case "center":
          case "middle":
            t = "50%";
            break;

          case "left":
          case "top":
            t = "0%";
            break;

          case "right":
          case "bottom":
            t = "100%";
        }
        return "string" == typeof t ? (i = t, i.replace(/^\s+/, "").replace(/\s+$/, "")).match(/%$/) ? parseFloat(t) / 100 * e : parseFloat(t) : null == t ? NaN : +t;
        var i;
    }
    function Bn(t, e, i) {
        return null == e && (e = 10), e = Math.min(Math.max(0, e), 20), t = (+t).toFixed(e), 
        i ? t : +t;
    }
    function Vn(t) {
        return t.sort(function(t, e) {
            return t - e;
        }), t;
    }
    function Gn(t) {
        if (t = +t, isNaN(t)) return 0;
        for (var e = 1, i = 0; Math.round(t * e) / e !== t; ) e *= 10, i++;
        return i;
    }
    function Wn(t) {
        var e = t.toString(), i = e.indexOf("e");
        if (0 < i) {
            var n = +e.slice(i + 1);
            return n < 0 ? -n : 0;
        }
        var a = e.indexOf(".");
        return a < 0 ? 0 : e.length - 1 - a;
    }
    function Fn(t, e) {
        var i = Math.log, n = Math.LN10, a = Math.floor(i(t[1] - t[0]) / n), o = Math.round(i(Math.abs(e[1] - e[0])) / n), r = Math.min(Math.max(-a + o, 0), 20);
        return isFinite(r) ? r : 20;
    }
    function Hn(t, e, i) {
        if (!t[e]) return 0;
        var n = p(t, function(t, e) {
            return t + (isNaN(e) ? 0 : e);
        }, 0);
        if (0 === n) return 0;
        for (var a = Math.pow(10, i), o = L(t, function(t) {
            return (isNaN(t) ? 0 : t) / n * a * 100;
        }), r = 100 * a, s = L(o, function(t) {
            return Math.floor(t);
        }), l = p(s, function(t, e) {
            return t + e;
        }, 0), h = L(o, function(t, e) {
            return t - s[e];
        }); l < r; ) {
            for (var u = Number.NEGATIVE_INFINITY, c = null, d = 0, f = h.length; d < f; ++d) h[d] > u && (u = h[d], 
            c = d);
            ++s[c], h[c] = 0, ++l;
        }
        return s[e] / a;
    }
    function Zn(t) {
        var e = 2 * Math.PI;
        return (t % e + e) % e;
    }
    function Un(t) {
        return -dy < t && t < dy;
    }
    function jn(t) {
        if (t instanceof Date) return t;
        if ("string" == typeof t) {
            var e = py.exec(t);
            if (!e) return new Date(NaN);
            if (e[8]) {
                var i = +e[4] || 0;
                return "Z" !== e[8].toUpperCase() && (i -= e[8].slice(0, 3)), new Date(Date.UTC(+e[1], +(e[2] || 1) - 1, +e[3] || 1, i, +(e[5] || 0), +e[6] || 0, +e[7] || 0));
            }
            return new Date(+e[1], +(e[2] || 1) - 1, +e[3] || 1, +e[4] || 0, +(e[5] || 0), +e[6] || 0, +e[7] || 0);
        }
        return null == t ? new Date(NaN) : new Date(Math.round(t));
    }
    function Xn(t) {
        return Math.pow(10, Yn(t));
    }
    function Yn(t) {
        return Math.floor(Math.log(t) / Math.LN10);
    }
    function qn(t, e) {
        var i = Yn(t), n = Math.pow(10, i), a = t / n;
        return t = (e ? a < 1.5 ? 1 : a < 2.5 ? 2 : a < 4 ? 3 : a < 7 ? 5 : 10 : a < 1 ? 1 : a < 2 ? 2 : a < 3 ? 3 : a < 5 ? 5 : 10) * n, 
        -20 <= i ? +t.toFixed(i < 0 ? -i : 0) : t;
    }
    function Kn(t) {
        t.sort(function(t, e) {
            return function t(e, i, n) {
                return e.interval[n] < i.interval[n] || e.interval[n] === i.interval[n] && (e.close[n] - i.close[n] == (n ? -1 : 1) || !n && t(e, i, 1));
            }(t, e, 0) ? -1 : 1;
        });
        for (var e = -1 / 0, i = 1, n = 0; n < t.length; ) {
            for (var a = t[n].interval, o = t[n].close, r = 0; r < 2; r++) a[r] <= e && (a[r] = e, 
            o[r] = r ? 1 : 1 - i), e = a[r], i = o[r];
            a[0] === a[1] && o[0] * o[1] != 1 ? t.splice(n, 1) : n++;
        }
        return t;
    }
    function $n(t) {
        return 0 <= t - parseFloat(t);
    }
    function Jn(t) {
        return isNaN(t) ? "-" : (t = (t + "").split("."))[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (1 < t.length ? "." + t[1] : "");
    }
    function Qn(t, e) {
        return t = (t || "").toLowerCase().replace(/-(.)/g, function(t, e) {
            return e.toUpperCase();
        }), e && t && (t = t.charAt(0).toUpperCase() + t.slice(1)), t;
    }
    function ta(t) {
        return null == t ? "" : (t + "").replace(vy, function(t, e) {
            return yy[e];
        });
    }
    function ea(t, e, i) {
        N(e) || (e = [ e ]);
        var n = e.length;
        if (!n) return "";
        for (var a = e[0].$vars || [], o = 0; o < a.length; o++) {
            var r = xy[o];
            t = t.replace(_y(r), _y(r, 0));
        }
        for (var s = 0; s < n; s++) for (var l = 0; l < a.length; l++) {
            var h = e[s][a[l]];
            t = t.replace(_y(xy[l], s), i ? ta(h) : h);
        }
        return t;
    }
    function ia(i, t, n) {
        return R(t, function(t, e) {
            i = i.replace("{" + e + "}", n ? ta(t) : t);
        }), i;
    }
    function na(t, e) {
        var i = (t = b(t) ? {
            color: t,
            extraCssText: e
        } : t || {}).color, n = t.type;
        e = t.extraCssText;
        return i ? "subItem" === n ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' + ta(i) + ";" + (e || "") + '"></span>' : '<span style="display:inline-block;margin-right:5px;border-radius:10px;width:10px;height:10px;background-color:' + ta(i) + ";" + (e || "") + '"></span>' : "";
    }
    function aa(t, e) {
        return "0000".substr(0, e - (t += "").length) + t;
    }
    function oa(t, e, i) {
        "week" !== t && "month" !== t && "quarter" !== t && "half-year" !== t && "year" !== t || (t = "MM-dd\nyyyy");
        var n = jn(e), a = i ? "UTC" : "", o = n["get" + a + "FullYear"](), r = n["get" + a + "Month"]() + 1, s = n["get" + a + "Date"](), l = n["get" + a + "Hours"](), h = n["get" + a + "Minutes"](), u = n["get" + a + "Seconds"](), c = n["get" + a + "Milliseconds"]();
        return t.replace("MM", aa(r, 2)).replace("M", r).replace("yyyy", o).replace("yy", o % 100).replace("dd", aa(s, 2)).replace("d", s).replace("hh", aa(l, 2)).replace("h", l).replace("mm", aa(h, 2)).replace("m", h).replace("ss", aa(u, 2)).replace("s", u).replace("SSS", aa(c, 3));
    }
    function ra(t) {
        return t ? t.charAt(0).toUpperCase() + t.substr(1) : t;
    }
    function sa(u, c, d, f, p) {
        var g = 0, m = 0;
        null == f && (f = 1 / 0), null == p && (p = 1 / 0);
        var v = 0;
        c.eachChild(function(t, e) {
            var i, n, a = t.position, o = t.getBoundingRect(), r = c.childAt(e + 1), s = r && r.getBoundingRect();
            if ("horizontal" === u) {
                var l = o.width + (s ? -s.x + o.x : 0);
                (i = g + l) > f || t.newline ? (g = 0, i = l, m += v + d, v = o.height) : v = Math.max(v, o.height);
            } else {
                var h = o.height + (s ? -s.y + o.y : 0);
                (n = m + h) > p || t.newline ? (g += v + d, m = 0, n = h, v = o.width) : v = Math.max(v, o.width);
            }
            t.newline || (a[0] = g, a[1] = m, "horizontal" === u ? g = i + d : m = n + d);
        });
    }
    function la(t, e, i) {
        i = my(i || 0);
        var n = e.width, a = e.height, o = zn(t.left, n), r = zn(t.top, a), s = zn(t.right, n), l = zn(t.bottom, a), h = zn(t.width, n), u = zn(t.height, a), c = i[2] + i[0], d = i[1] + i[3], f = t.aspect;
        switch (isNaN(h) && (h = n - s - d - o), isNaN(u) && (u = a - l - c - r), null != f && (isNaN(h) && isNaN(u) && (n / a < f ? h = .8 * n : u = .8 * a), 
        isNaN(h) && (h = f * u), isNaN(u) && (u = h / f)), isNaN(o) && (o = n - s - h - d), 
        isNaN(r) && (r = a - l - u - c), t.left || t.right) {
          case "center":
            o = n / 2 - h / 2 - i[3];
            break;

          case "right":
            o = n - h - d;
        }
        switch (t.top || t.bottom) {
          case "middle":
          case "center":
            r = a / 2 - u / 2 - i[0];
            break;

          case "bottom":
            r = a - u - c;
        }
        o = o || 0, r = r || 0, isNaN(h) && (h = n - d - o - (s || 0)), isNaN(u) && (u = a - c - r - (l || 0));
        var p = new Xt(o + i[3], r + i[0], h, u);
        return p.margin = i, p;
    }
    function ha(t, e, i, n, a) {
        var o = !a || !a.hv || a.hv[0], r = !a || !a.hv || a.hv[1], s = a && a.boundingMode || "all";
        if (o || r) {
            var l;
            if ("raw" === s) l = "group" === t.type ? new Xt(0, 0, +e.width || 0, +e.height || 0) : t.getBoundingRect(); else if (l = t.getBoundingRect(), 
            t.needLocalTransform()) {
                var h = t.getLocalTransform();
                (l = l.clone()).applyTransform(h);
            }
            e = la(E({
                width: l.width,
                height: l.height
            }, e), i, n);
            var u = t.position, c = o ? e.x - l.x : 0, d = r ? e.y - l.y : 0;
            t.attr("position", "raw" === s ? [ c, d ] : [ u[0] + c, u[1] + d ]);
        }
    }
    function ua(l, h, t) {
        function e(t, e) {
            var i = {}, n = 0, a = {}, o = 0;
            if (My(t, function(t) {
                a[t] = l[t];
            }), My(t, function(t) {
                u(h, t) && (i[t] = a[t] = h[t]), c(i, t) && n++, c(a, t) && o++;
            }), d[e]) return c(h, t[1]) ? a[t[2]] = null : c(h, t[2]) && (a[t[1]] = null), a;
            if (2 !== o && n) {
                if (2 <= n) return i;
                for (var r = 0; r < t.length; r++) {
                    var s = t[r];
                    if (!u(i, s) && u(l, s)) {
                        i[s] = l[s];
                        break;
                    }
                }
                return i;
            }
            return a;
        }
        function u(t, e) {
            return t.hasOwnProperty(e);
        }
        function c(t, e) {
            return null != t[e] && "auto" !== t[e];
        }
        function i(t, e, i) {
            My(t, function(t) {
                e[t] = i[t];
            });
        }
        !B(t) && (t = {});
        var d = t.ignoreSize;
        !N(d) && (d = [ d, d ]);
        var n = e(Ty[0], 0), a = e(Ty[1], 1);
        i(Ty[0], l, n), i(Ty[1], l, a);
    }
    function ca(t) {
        return da({}, t);
    }
    function da(e, i) {
        return i && e && My(Iy, function(t) {
            i.hasOwnProperty(t) && (e[t] = i[t]);
        }), e;
    }
    function fa(t) {
        var e = t.get("coordinateSystem"), i = {
            coordSysName: e,
            coordSysDims: [],
            axisMap: W(),
            categoryAxisMap: W()
        }, n = Oy[e];
        if (n) return n(t, i, i.axisMap, i.categoryAxisMap), i;
    }
    function pa(t) {
        return "category" === t.get("type");
    }
    function ga(t) {
        this.fromDataset = t.fromDataset, this.data = t.data || (t.sourceFormat === By ? {} : []), 
        this.sourceFormat = t.sourceFormat || Vy, this.seriesLayoutBy = t.seriesLayoutBy || Wy, 
        this.dimensionsDefine = t.dimensionsDefine, this.encodeDefine = t.encodeDefine && W(t.encodeDefine), 
        this.startIndex = t.startIndex || 0, this.dimensionsDetectCount = t.dimensionsDetectCount;
    }
    function ma(t) {
        var e = t.option, i = e.data, n = v(i) ? Gy : Ey, a = !1, o = e.seriesLayoutBy, r = e.sourceHeader, s = e.dimensions, l = function(t) {
            var e = t.option;
            if (!e.data) return t.ecModel.getComponent("dataset", e.datasetIndex || 0);
        }(t);
        if (l) {
            var h = l.option;
            i = h.source, n = Hy(l).sourceFormat, a = !0, o = o || h.seriesLayoutBy, null == r && (r = h.sourceHeader), 
            s = s || h.dimensions;
        }
        var u = function(t, e, i, n, a) {
            if (!t) return {
                dimensionsDefine: va(a)
            };
            var o, r, s, l;
            if (e === Ry) "auto" === n || null == n ? ya(function(t) {
                null != t && "-" !== t && (b(t) ? null == r && (r = 1) : r = 0);
            }, i, t, 10) : r = n ? 1 : 0, a || 1 !== r || (a = [], ya(function(t, e) {
                a[e] = null != t ? t : "";
            }, i, t)), o = a ? a.length : i === Fy ? t.length : t[0] ? t[0].length : null; else if (e === zy) a || (a = function(t) {
                for (var e, i = 0; i < t.length && !(e = t[i++]); ) ;
                if (e) {
                    var n = [];
                    return R(e, function(t, e) {
                        n.push(e);
                    }), n;
                }
            }(t), s = !0); else if (e === By) a || (a = [], s = !0, R(t, function(t, e) {
                a.push(e);
            })); else if (e === Ey) {
                var h = ei(t[0]);
                o = N(h) && h.length || 1;
            }
            return s && R(a, function(t, e) {
                "name" === (B(t) ? t.name : t) && (l = e);
            }), {
                startIndex: r,
                dimensionsDefine: va(a),
                dimensionsDetectCount: o,
                potentialNameDimIndex: l
            };
        }(i, n, o, r, s), c = e.encode;
        !c && l && (c = function(t, e, i, n, a, o) {
            var r = fa(t), s = {}, l = [], h = [], u = t.subType, c = W([ "pie", "map", "funnel" ]), d = W([ "line", "bar", "pictorialBar", "scatter", "effectScatter", "candlestick", "boxplot" ]);
            if (r && null != d.get(u)) {
                var f = t.ecModel, p = Hy(f).datasetMap, g = e.uid + "_" + a, m = p.get(g) || p.set(g, {
                    categoryWayDim: 1,
                    valueWayDim: 0
                });
                R(r.coordSysDims, function(t) {
                    if (null == r.firstCategoryDimIndex) e = m.valueWayDim++, s[t] = e, h.push(e); else if (r.categoryAxisMap.get(t)) s[t] = 0, 
                    l.push(0); else {
                        var e = m.categoryWayDim++;
                        s[t] = e, h.push(e);
                    }
                });
            } else if (null != c.get(u)) {
                for (var v, y = 0; y < 5 && null == v; y++) xa(i, n, a, o.dimensionsDefine, o.startIndex, y) || (v = y);
                if (null != v) {
                    s.value = v;
                    var x = o.potentialNameDimIndex || Math.max(v - 1, 0);
                    h.push(x), l.push(x);
                }
            }
            return l.length && (s.itemName = l), h.length && (s.seriesName = h), s;
        }(t, l, i, n, o, u)), Hy(t).source = new ga({
            data: i,
            fromDataset: a,
            seriesLayoutBy: o,
            sourceFormat: n,
            dimensionsDefine: u.dimensionsDefine,
            startIndex: u.startIndex,
            dimensionsDetectCount: u.dimensionsDetectCount,
            encodeDefine: c
        });
    }
    function va(t) {
        if (t) {
            var n = W();
            return L(t, function(t, e) {
                if (null == (t = P({}, B(t) ? t : {
                    name: t
                })).name) return t;
                t.name += "", null == t.displayName && (t.displayName = t.name);
                var i = n.get(t.name);
                return i ? t.name += "-" + i.count++ : n.set(t.name, {
                    count: 1
                }), t;
            });
        }
    }
    function ya(t, e, i, n) {
        if (null == n && (n = 1 / 0), e === Fy) for (o = 0; o < i.length && o < n; o++) t(i[o] ? i[o][0] : null, o); else for (var a = i[0] || [], o = 0; o < a.length && o < n; o++) t(a[o], o);
    }
    function xa(t, e, i, n, a, o) {
        function r(t) {
            return (null == t || !isFinite(t) || "" === t) && (!(!b(t) || "-" === t) || void 0);
        }
        var s, l;
        if (v(t)) return !1;
        if (n && (l = B(l = n[o]) ? l.name : l), e === Ry) if (i === Fy) {
            for (var h = t[o], u = 0; u < (h || []).length && u < 5; u++) if (null != (s = r(h[a + u]))) return s;
        } else for (u = 0; u < t.length && u < 5; u++) {
            var c = t[a + u];
            if (c && null != (s = r(c[o]))) return s;
        } else if (e === zy) {
            if (!l) return;
            for (u = 0; u < t.length && u < 5; u++) if ((d = t[u]) && null != (s = r(d[l]))) return s;
        } else if (e === By) {
            if (!l) return;
            if (!(h = t[l]) || v(h)) return !1;
            for (u = 0; u < h.length && u < 5; u++) if (null != (s = r(h[u]))) return s;
        } else if (e === Ey) for (u = 0; u < t.length && u < 5; u++) {
            var d = t[u], f = ei(d);
            if (!N(f)) return !1;
            if (null != (s = r(f[o]))) return s;
        }
        return !1;
    }
    function _a(t) {
        var i, e, n;
        t = t, this.option = {}, this.option[Zy] = 1, this._componentsMap = W({
            series: []
        }), this._seriesIndices, this._seriesIndicesMap, i = t, e = this._theme.option, 
        n = i.color && !i.colorLayer, R(e, function(t, e) {
            "colorLayer" === e && n || Cy.hasClass(e) || ("object" == (void 0 === t ? "undefined" : _typeof(t)) ? i[e] = i[e] ? g(i[e], t, !1) : A(t) : null == i[e] && (i[e] = t));
        }), g(t, ky, !1), this.mergeOption(t);
    }
    function wa(t, e) {
        t._seriesIndicesMap = W(t._seriesIndices = L(e, function(t) {
            return t.componentIndex;
        }) || []);
    }
    function ba(t, e) {
        return e.hasOwnProperty("subType") ? I(t, function(t) {
            return t.subType === e.subType;
        }) : t;
    }
    function Sa(e) {
        R(jy, function(t) {
            this[t] = _(e[t], e);
        }, this);
    }
    function Ma() {
        this._coordinateSystems = [];
    }
    function Ia(t) {
        this._api = t, this._timelineOptions = [], this._mediaList = [], this._mediaDefault, 
        this._currentMediaIndices = [], this._optionBackup, this._newBaseOption;
    }
    function Ta(t, e, i) {
        var l = {
            width: e,
            height: i,
            aspectratio: e / i
        }, h = !0;
        return R(t, function(t, e) {
            var i, n, a, o = e.match(Jy);
            if (o && o[1] && o[2]) {
                var r = o[1], s = o[2].toLowerCase();
                i = l[s], n = t, ("min" === (a = r) ? n <= i : "max" === a ? i <= n : i === n) || (h = !1);
            }
        }), h;
    }
    function Da(t) {
        var e = t && t.itemStyle;
        if (e) for (var i = 0, n = ex.length; i < n; i++) {
            var a = ex[i], o = e.normal, r = e.emphasis;
            o && o[a] && (t[a] = t[a] || {}, t[a].normal ? g(t[a].normal, o[a]) : t[a].normal = o[a], 
            o[a] = null), r && r[a] && (t[a] = t[a] || {}, t[a].emphasis ? g(t[a].emphasis, r[a]) : t[a].emphasis = r[a], 
            r[a] = null);
        }
    }
    function Aa(t, e, i) {
        if (t && t[e] && (t[e].normal || t[e].emphasis)) {
            var n = t[e].normal, a = t[e].emphasis;
            n && (i ? (t[e].normal = t[e].emphasis = null, E(t[e], n)) : t[e] = n), a && (t.emphasis = t.emphasis || {}, 
            t.emphasis[e] = a);
        }
    }
    function Ca(t) {
        Aa(t, "itemStyle"), Aa(t, "lineStyle"), Aa(t, "areaStyle"), Aa(t, "label"), Aa(t, "labelLine"), 
        Aa(t, "upperLabel"), Aa(t, "edgeLabel");
    }
    function La(t, e) {
        var i = tx(t) && t[e], n = tx(i) && i.textStyle;
        if (n) for (var a = 0, o = bm.length; a < o; a++) {
            e = bm[a];
            n.hasOwnProperty(e) && (i[e] = n[e]);
        }
    }
    function ka(t) {
        t && (Ca(t), La(t, "label"), t.emphasis && La(t.emphasis, "label"));
    }
    function Pa(t) {
        return N(t) ? t : t ? [ t ] : [];
    }
    function Na(t) {
        return (N(t) ? t[0] : t) || {};
    }
    function Oa(e) {
        R(nx, function(t) {
            t[0] in e && !(t[1] in e) && (e[t[1]] = e[t[0]]);
        });
    }
    function Ea(m) {
        R(m, function(u, c) {
            var d = [], f = [ NaN, NaN ], t = [ u.stackResultDimension, u.stackedOverDimension ], p = u.data, g = u.isStackedByIndex, e = p.map(t, function(t, e, i) {
                var n, a, o = p.get(u.stackedDimension, i);
                if (isNaN(o)) return f;
                g ? a = p.getRawIndex(i) : n = p.get(u.stackedByDimension, i);
                for (var r = NaN, s = c - 1; 0 <= s; s--) {
                    var l = m[s];
                    if (g || (a = l.data.rawIndexOf(l.stackedByDimension, n)), 0 <= a) {
                        var h = l.data.getByRawIndex(l.stackResultDimension, a);
                        if (0 <= o && 0 < h || o <= 0 && h < 0) {
                            o += h, r = h;
                            break;
                        }
                    }
                }
                return d[0] = o, d[1] = r, d;
            });
            p.hostModel.setData(e), u.data = e;
        });
    }
    function Ra(t, e) {
        ga.isInstance(t) || (t = ga.seriesDataToSource(t)), this._source = t;
        var i = this._data = t.data, n = t.sourceFormat;
        n === Gy && (this._offset = 0, this._dimSize = e, this._data = i), P(this, sx[n === Ry ? n + "_" + t.seriesLayoutBy : n]);
    }
    function za() {
        return this._data.length;
    }
    function Ba(t) {
        return this._data[t];
    }
    function Va(t) {
        for (var e = 0; e < t.length; e++) this._data.push(t[e]);
    }
    function Ga(t, e, i, n) {
        return null != i ? t[i] : t;
    }
    function Wa(t, e, i, n) {
        return Fa(t[n], this._dimensionInfos[e]);
    }
    function Fa(t, e) {
        var i = e && e.type;
        if ("ordinal" === i) {
            var n = e && e.ordinalMeta;
            return n ? n.parseAndCollect(t) : t;
        }
        return "time" === i && "number" != typeof t && null != t && "-" !== t && (t = +jn(t)), 
        null == t || "" === t ? NaN : +t;
    }
    function Ha(t, e, i) {
        if (t) {
            var n = t.getRawDataItem(e);
            if (null != n) {
                var a, o, r = t.getProvider().getSource().sourceFormat, s = t.getDimensionInfo(i);
                return s && (a = s.name, o = s.index), lx[r](n, e, o, a);
            }
        }
    }
    function Za(t, e, i) {
        if (t) {
            var n = t.getProvider().getSource().sourceFormat;
            if (n === Ey || n === zy) {
                var a = t.getRawDataItem(e);
                return n !== Ey || B(a) || (a = null), a ? a[i] : void 0;
            }
        }
    }
    function Ua(t) {
        return new ja(t);
    }
    function ja(t) {
        t = t || {}, this._reset = t.reset, this._plan = t.plan, this._count = t.count, 
        this._onDirty = t.onDirty, this._dirty = !0, this.context;
    }
    function Xa(t) {
        var i, n, e = t.name;
        ai(t) || (t.name = (i = t.getRawData(), n = [], R(i.mapDimension("seriesName", !0), function(t) {
            var e = i.getDimensionInfo(t);
            e.displayName && n.push(e.displayName);
        }), n.join(" ") || e));
    }
    function Ya(t) {
        return t.model.getRawData().count();
    }
    function qa(t) {
        var e = t.model;
        return e.setData(e.getRawData().cloneShallow()), Ka;
    }
    function Ka(t, e) {
        t.end > e.outputData.count() && e.model.getRawData().cloneShallow(e.outputData);
    }
    function $a(e, i) {
        R(e.CHANGABLE_METHODS, function(t) {
            e.wrapMethod(t, z(Ja, i));
        });
    }
    function Ja(t) {
        var e = Qa(t);
        e && e.setOutputEnd(this.count());
    }
    function Qa(t) {
        var e = (t.ecModel || {}).scheduler, i = e && e.getPipeline(t.uid);
        if (i) {
            var n = i.currentTask;
            if (n) {
                var a = n.agentStubMap;
                a && (n = a.get(t.uid));
            }
            return n;
        }
    }
    function to() {
        this.group = new Dg(), this.uid = En("viewChart"), this.renderTask = Ua({
            plan: no,
            reset: ao
        }), this.renderTask.context = {
            view: this
        };
    }
    function eo(t, e) {
        if (t && (t.trigger(e), "group" === t.type)) for (var i = 0; i < t.childCount(); i++) eo(t.childAt(i), e);
    }
    function io(e, t, i) {
        var n = ri(e, t);
        null != n ? R(Qe(n), function(t) {
            eo(e.getItemGraphicEl(t), i);
        }) : e.eachItemGraphicEl(function(t) {
            eo(t, i);
        });
    }
    function no(t) {
        return xx(t.model);
    }
    function ao(t) {
        var e = t.model, i = t.ecModel, n = t.api, a = t.payload, o = e.pipelineContext.canProgressiveRender, r = t.view, s = a && yx(a).updateMethod, l = o ? "incrementalPrepareRender" : s && r[s] ? s : "render";
        return "render" !== l && r[l](e, i, n, a), bx[l];
    }
    function oo(t, i, n) {
        function a() {
            c = new Date().getTime(), d = null, t.apply(s, l || []);
        }
        var o, r, s, l, h, u = 0, c = 0, d = null;
        i = i || 0;
        var e = function() {
            o = new Date().getTime(), s = this, l = arguments;
            var t = h || i, e = h || n;
            h = null, r = o - (e ? u : c) - t, clearTimeout(d), e ? d = setTimeout(a, t) : 0 <= r ? a() : d = setTimeout(a, -r), 
            u = o;
        };
        return e.clear = function() {
            d && (clearTimeout(d), d = null);
        }, e.debounceNextCall = function(t) {
            h = t;
        }, e;
    }
    function ro(t, e, i, n) {
        var a = t[e];
        if (a) {
            var o = a[Sx] || a, r = a[Ix];
            if (a[Mx] !== i || r !== n) {
                if (null == i || !n) return t[e] = o;
                (a = t[e] = oo(o, i, "debounce" === n))[Sx] = o, a[Ix] = n, a[Mx] = i;
            }
            return a;
        }
    }
    function so(t, e) {
        var i = t[e];
        i && i[Sx] && (t[e] = i[Sx]);
    }
    function lo(t, e, i, n) {
        this.ecInstance = t, this.api = e, this.unfinished;
        i = this._dataProcessorHandlers = i.slice(), n = this._visualHandlers = n.slice();
        this._allHandlers = i.concat(n), this._stageTaskMap = W();
    }
    function ho(l, t, h, u, c) {
        function d(t, e) {
            return t.setDirty && (!t.dirtyMap || t.dirtyMap.get(e.__pipeline.id));
        }
        var f;
        c = c || {}, R(t, function(n, t) {
            if (!c.visualType || c.visualType === n.visualType) {
                var e = l._stageTaskMap.get(n.uid), i = e.seriesTaskMap, a = e.overallTask;
                if (a) {
                    var o, r = a.agentStubMap;
                    r.each(function(t) {
                        d(c, t) && (t.dirty(), o = !0);
                    }), o && a.dirty(), kx(a, u);
                    var s = l.getPerformArgs(a, c.block);
                    r.each(function(t) {
                        t.perform(s);
                    }), f |= a.perform(s);
                } else i && i.each(function(t, e) {
                    d(c, t) && t.dirty();
                    var i = l.getPerformArgs(t, c.block);
                    i.skip = !n.performRawSeries && h.isSeriesFiltered(t.context.model), kx(t, u), f |= t.perform(i);
                });
            }
        }), l.unfinished |= f;
    }
    function uo(t) {
        t.overallReset(t.ecModel, t.api, t.payload);
    }
    function co(t, e) {
        return t.overallProgress && fo;
    }
    function fo() {
        this.agent.dirty(), this.getDownstream().dirty();
    }
    function po() {
        this.agent && this.agent.dirty();
    }
    function go(t) {
        return t.plan && t.plan(t.model, t.ecModel, t.api, t.payload);
    }
    function mo(t) {
        if (t.useClearVisual && t.data.clearAllVisual(), (t.resetDefines = Qe(t.reset(t.model, t.ecModel, t.api, t.payload))).length) return vo;
    }
    function vo(t, e) {
        for (var i = e.data, n = e.resetDefines, a = 0; a < n.length; a++) {
            var o = n[a];
            if (o && o.dataEach) for (var r = t.start; r < t.end; r++) o.dataEach(i, r); else o && o.progress && o.progress(t, i);
        }
    }
    function yo(t) {
        return t.data.count();
    }
    function xo(t, e, i) {
        var n = e.uid, a = t._pipelineMap.get(n);
        !a.head && (a.head = i), a.tail && a.tail.pipe(i), (a.tail = i).__idxInPipeline = a.count++, 
        i.__pipeline = a;
    }
    function _o(t, e) {
        for (var i in e.prototype) t[i] = S;
    }
    function wo(n) {
        return function(t, e, i) {
            t = t && t.toLowerCase(), Up.prototype[n].call(this, t, e, i);
        };
    }
    function bo() {
        Up.call(this);
    }
    function So(t, e, i) {
        function n(t, e) {
            return t.__prio - e.__prio;
        }
        i = i || {}, "string" == typeof e && (e = n_[e]), this.id, this.group, this._dom = t;
        var a = this._zr = $e(t, {
            renderer: i.renderer || "canvas",
            devicePixelRatio: i.devicePixelRatio,
            width: i.width,
            height: i.height
        });
        this._throttledZrFlush = oo(_(a.flush, a), 17), (e = A(e)) && ox(e, !0), this._theme = e, 
        this._chartsViews = [], this._chartsMap = {}, this._componentsViews = [], this._componentsMap = {}, 
        this._coordSysMgr = new Ma();
        var o, r, s, l, h = this._api = (r = (o = this)._coordSysMgr, P(new Sa(o), {
            getCoordinateSystems: _(r.getCoordinateSystems, r),
            getComponentByElement: function(t) {
                for (;t; ) {
                    var e = t.__ecComponentInfo;
                    if (null != e) return o._model.getComponent(e.mainType, e.index);
                    t = t.parent;
                }
            }
        }));
        Qt(i_, n), Qt(Qx, n), this._scheduler = new lo(this, h, Qx, i_), Up.call(this), 
        this._messageCenter = new bo(), this._initEvents(), this.resize = _(this.resize, this), 
        this._pendingActions = [], a.animation.on("frame", this._onframe, this), l = this, 
        (s = a).on("rendered", function() {
            l.trigger("rendered"), !s.animation.isFinished() || l[jx] || l._scheduler.unfinished || l._pendingActions.length || l.trigger("finished");
        }), d(this);
    }
    function Mo(t, e, i) {
        var n, a = this._model, o = this._coordSysMgr.getCoordinateSystems();
        e = li(a, e);
        for (var r = 0; r < o.length; r++) {
            var s = o[r];
            if (s[t] && null != (n = s[t](a, e, i))) return n;
        }
    }
    function Io(t) {
        var e = t._model, i = t._scheduler;
        i.restorePipelines(e), i.prepareStageTasks(), ko(t, "component", e, i), ko(t, "chart", e, i), 
        i.plan();
    }
    function To(i, e, n, a, t) {
        function o(t) {
            t && t.__alive && t[e] && t[e](t.__model, r, i._api, n);
        }
        var r = i._model;
        if (a) {
            var s = {};
            s[a + "Id"] = n[a + "Id"], s[a + "Index"] = n[a + "Index"], s[a + "Name"] = n[a + "Name"];
            var l = {
                mainType: a,
                query: s
            };
            t && (l.subType = t), r && r.eachComponent(l, function(t, e) {
                o(i["series" === a ? "_chartsMap" : "_componentsMap"][t.__viewId]);
            }, i);
        } else Gx(i._componentsViews.concat(i._chartsViews), o);
    }
    function Do(t, e) {
        var i = t._chartsMap, n = t._scheduler;
        e.eachSeries(function(t) {
            n.updateStreamModes(t, i[t.__viewId]);
        });
    }
    function Ao(e, t) {
        var i = e.type, n = e.escapeConnect, a = $x[i], o = a.actionInfo, r = (o.update || "update").split(":"), s = r.pop();
        r = null != r[0] && Hx(r[0]), this[Ux] = !0;
        var l = [ e ], h = !1;
        e.batch && (h = !0, l = L(e.batch, function(t) {
            return (t = E(P({}, t), e)).batch = null, t;
        }));
        var u, c = [], d = "highlight" === i || "downplay" === i;
        Gx(l, function(t) {
            (u = (u = a.action(t, this._model, this._api)) || P({}, t)).type = o.event || u.type, 
            c.push(u), d ? To(this, s, t, "series") : r && To(this, s, t, r.main, r.sub);
        }, this), "none" === s || d || r || (this[jx] ? (Io(this), qx.update.call(this, e), 
        this[jx] = !1) : qx[s].call(this, e)), u = h ? {
            type: o.event || i,
            escapeConnect: n,
            batch: c
        } : c[0], this[Ux] = !1, !t && this._messageCenter.trigger(u.type, u);
    }
    function Co(t) {
        for (var e = this._pendingActions; e.length; ) {
            var i = e.shift();
            Ao.call(this, i, t);
        }
    }
    function Lo(t) {
        !t && this.trigger("updated");
    }
    function ko(t, e, a, o) {
        function i(t) {
            var e = "_ec_" + t.id + "_" + t.type, i = l[e];
            if (!i) {
                var n = Hx(t.type);
                (i = new (r ? gx.getClass(n.main, n.sub) : to.getClass(n.sub))()).init(a, u), l[e] = i, 
                s.push(i), h.add(i.group);
            }
            t.__viewId = i.__id = e, i.__alive = !0, i.__model = t, i.group.__ecComponentInfo = {
                mainType: t.mainType,
                index: t.componentIndex
            }, !r && o.prepareView(i, t, a, u);
        }
        for (var r = "component" === e, s = r ? t._componentsViews : t._chartsViews, l = r ? t._componentsMap : t._chartsMap, h = t._zr, u = t._api, n = 0; n < s.length; n++) s[n].__alive = !1;
        for (r ? a.eachComponent(function(t, e) {
            "series" !== t && i(e);
        }) : a.eachSeries(i), n = 0; n < s.length; ) {
            var c = s[n];
            c.__alive ? n++ : (!r && c.renderTask.dispose(), h.remove(c.group), c.dispose(a, u), 
            s.splice(n, 1), delete l[c.__id], c.__id = c.group.__ecComponentInfo = null);
        }
    }
    function Po(t) {
        t.clearColorPalette(), t.eachSeries(function(t) {
            t.clearColorPalette();
        });
    }
    function No(t, e, i, n) {
        var a, o, r, s, l;
        a = t, o = e, r = i, s = n, Gx(l || a._componentsViews, function(t) {
            var e = t.__model;
            t.render(e, o, r, s), Ro(e, t);
        }), Gx(t._chartsViews, function(t) {
            t.__alive = !1;
        }), Oo(t, e, i, n), Gx(t._chartsViews, function(t) {
            t.__alive || t.remove(e, i);
        });
    }
    function Oo(o, t, e, r, s) {
        var l, i, n, a, h, u = o._scheduler;
        t.eachSeries(function(t) {
            var e = o._chartsMap[t.__viewId];
            e.__alive = !0;
            var i, n, a = e.renderTask;
            u.updatePayload(a, r), s && s.get(t.uid) && a.dirty(), l |= a.perform(u.getPerformArgs(a)), 
            e.group.silent = !!t.get("silent"), Ro(t, e), i = e, n = t.get("blendMode") || null, 
            i.group.traverse(function(t) {
                t.isGroup || t.style.blend !== n && t.setStyle("blend", n), t.eachPendingDisplayable && t.eachPendingDisplayable(function(t) {
                    t.setStyle("blend", n);
                });
            });
        }), u.unfinished |= l, i = o._zr, n = t, a = i.storage, h = 0, a.traverse(function(t) {
            t.isGroup || h++;
        }), h > n.get("hoverLayerThreshold") && !Sp.node && a.traverse(function(t) {
            t.isGroup || (t.useHoverLayer = !0);
        }), Ax(o._zr.dom, t);
    }
    function Eo(e, i) {
        Gx(e_, function(t) {
            t(e, i);
        });
    }
    function Ro(t, e) {
        var i = t.get("z"), n = t.get("zlevel");
        e.group.traverse(function(t) {
            "group" !== t.type && (null != i && (t.z = i), null != n && (t.zlevel = n));
        });
    }
    function zo(t) {
        r_[t] = !1;
    }
    function Bo(t) {
        return o_[(e = t, i = h_, e.getAttribute ? e.getAttribute(i) : e[i])];
        var e, i;
    }
    function Vo(t, e) {
        n_[t] = e;
    }
    function Go(t) {
        t_.push(t);
    }
    function Wo(t, e) {
        jo(Qx, t, e, 1e3);
    }
    function Fo(t, e, i) {
        "function" == typeof e && (i = e, e = "");
        var n = Fx(t) ? t.type : [ t, t = {
            event: e
        } ][0];
        t.event = (t.event || n).toLowerCase(), e = t.event, Vx(Xx.test(n) && Xx.test(e)), 
        $x[n] || ($x[n] = {
            action: i,
            actionInfo: t
        }), Jx[e] = n;
    }
    function Ho(t, e) {
        Ma.register(t, e);
    }
    function Zo(t, e) {
        jo(i_, t, e, 1e3, "layout");
    }
    function Uo(t, e) {
        jo(i_, t, e, 3e3, "visual");
    }
    function jo(t, e, i, n, a) {
        (Wx(e) || Fx(e)) && (i = e, e = n);
        var o = lo.wrapStageHandler(i, a);
        return o.__prio = e, o.__raw = i, t.push(o), o;
    }
    function Xo(t, e) {
        a_[t] = e;
    }
    function Yo(t) {
        return Cy.extend(t);
    }
    function qo(t) {
        return gx.extend(t);
    }
    function Ko(t) {
        return px.extend(t);
    }
    function $o(t) {
        return to.extend(t);
    }
    function Jo(t) {
        return u_[t];
    }
    function Qo(t) {
        return t;
    }
    function tr(t, e, i, n, a) {
        this._old = t, this._new = e, this._oldKeyGetter = i || Qo, this._newKeyGetter = n || Qo, 
        this.context = a;
    }
    function er(t, e, i, n, a) {
        for (var o = 0; o < t.length; o++) {
            var r = "_ec_" + a[n](t[o], o), s = e[r];
            null == s ? (i.push(r), e[r] = o) : (s.length || (e[r] = s = [ s ]), s.push(o));
        }
    }
    function ir(t) {
        return "category" === t ? "ordinal" : "time" === t ? "time" : "float";
    }
    function nr(t) {
        return 65535 < t._rawCount ? m_ : v_;
    }
    function ar(e, i) {
        R(y_.concat(i.__wrappedMethods || []), function(t) {
            i.hasOwnProperty(t) && (e[t] = i[t]);
        }), e.__wrappedMethods = i.__wrappedMethods;
    }
    function or(t) {
        return t;
    }
    function rr(t) {
        return t < this._count && 0 <= t ? this._indices[t] : -1;
    }
    function sr(t, e) {
        var i = t._idList[e];
        return null == i && (i = t._getIdFromStore(e)), null == i && (i = "e\0\0" + e), 
        i;
    }
    function lr(t) {
        return N(t) || (t = [ t ]), t;
    }
    function hr(t, e) {
        var i = t.dimensions, n = new x_(L(i, t.getDimensionInfo, t), t.hostModel);
        ar(n, t);
        for (var a = n._storage = {}, o = t._storage, r = P({}, t._rawExtent), s = 0; s < i.length; s++) {
            var l = i[s];
            o[l] && (0 <= C(e, l) ? (a[l] = ur(o[l]), r[l] = [ 1 / 0, -1 / 0 ]) : a[l] = o[l]);
        }
        return n;
    }
    function ur(t) {
        for (var e = new Array(t.length), i = 0; i < t.length; i++) e[i] = (n = t[i], a = void 0, 
        (a = n.constructor) === Array ? n.slice() : new a(n));
        var n, a;
        return e;
    }
    function cr(t, e, i) {
        function l(t, e, i) {
            null != d_.get(e) ? t.otherDims[e] = i : (t.coordDim = e, t.coordDimIndex = i, o.set(e, !0));
        }
        ga.isInstance(e) || (e = ga.seriesDataToSource(e)), i = i || {}, t = (t || []).slice();
        for (var n = (i.dimsDef || []).slice(), h = W(i.encodeDef), a = W(), o = W(), u = [], r = function(t, e, i, n) {
            var a = Math.max(t.dimensionsDetectCount || 1, e.length, i.length, n || 0);
            return R(e, function(t) {
                var e = t.dimsDef;
                e && (a = Math.max(a, e.length));
            }), a;
        }(e, t, n, i.dimCount), s = 0; s < r; s++) {
            var c = n[s] = P({}, B(n[s]) ? n[s] : {
                name: n[s]
            }), d = c.name, f = u[s] = {
                otherDims: {}
            };
            null != d && null == a.get(d) && (f.name = f.displayName = d, a.set(d, s)), null != c.type && (f.type = c.type), 
            null != c.displayName && (f.displayName = c.displayName);
        }
        h.each(function(t, i) {
            t = Qe(t).slice();
            var n = h.set(i, []);
            R(t, function(t, e) {
                b(t) && (t = a.get(t)), null != t && t < r && (n[e] = t, l(u[t], i, e));
            });
        });
        var p = 0;
        R(t, function(n, t) {
            var a, o, r;
            if (b(n)) a = n, n = {}; else {
                a = n.name;
                var e = n.ordinalMeta;
                n.ordinalMeta = null, (n = A(n)).ordinalMeta = e, o = n.dimsDef, r = n.otherDims, 
                n.name = n.coordDim = n.coordDimIndex = n.dimsDef = n.otherDims = null;
            }
            var i = Qe(h.get(a));
            if (!i.length) for (var s = 0; s < (o && o.length || 1); s++) {
                for (;p < u.length && null != u[p].coordDim; ) p++;
                p < u.length && i.push(p++);
            }
            R(i, function(t, e) {
                var i = u[t];
                l(E(i, n), a, e), null == i.name && o && (i.name = i.displayName = o[e]), r && E(i.otherDims, r);
            });
        });
        var g, m, v = i.generateCoord, y = i.generateCoordCount, x = null != y;
        y = v ? y || 1 : 0;
        for (var _ = v || "value", w = 0; w < r; w++) null == (f = u[w] = u[w] || {}).coordDim && (f.coordDim = dr(_, o, x), 
        f.coordDimIndex = 0, (!v || y <= 0) && (f.isExtraCoord = !0), y--), null == f.name && (f.name = dr(f.coordDim, a)), 
        null == f.type && (g = e, m = w, f.name, xa(g.data, g.sourceFormat, g.seriesLayoutBy, g.dimensionsDefine, g.startIndex, m)) && (f.type = "ordinal");
        return u;
    }
    function dr(t, e, i) {
        if (i || null != e.get(t)) {
            for (var n = 0; null != e.get(t + n); ) n++;
            t += n;
        }
        return e.set(t, !0), t;
    }
    function fr(t, i, e) {
        var n, a, o, r, s = (e = e || {}).byIndex, l = e.stackedCoordDimension, h = !(!t || !t.get("stack"));
        if (R(i, function(t, e) {
            b(t) && (i[e] = t = {
                name: t
            }), h && !t.isExtraCoord && (s || n || !t.ordinalMeta || (n = t), a || "ordinal" === t.type || "time" === t.type || l && l !== t.coordDim || (a = t));
        }), a && (s || n)) {
            o = "__\0ecstackresult", r = "__\0ecstackedover", n && (n.createInvertedIndices = !0);
            var u = a.coordDim, c = a.type, d = 0;
            R(i, function(t) {
                t.coordDim === u && d++;
            }), i.push({
                name: o,
                coordDim: u,
                coordDimIndex: d,
                type: c,
                isExtraCoord: !0,
                isCalculationCoord: !0
            }), d++, i.push({
                name: r,
                coordDim: r,
                coordDimIndex: d,
                type: c,
                isExtraCoord: !0,
                isCalculationCoord: !0
            });
        }
        return {
            stackedDimension: a && a.name,
            stackedByDimension: n && n.name,
            isStackedByIndex: s,
            stackedOverDimension: r,
            stackResultDimension: o
        };
    }
    function pr(t, e, i) {
        return e && e === t.getCalculationInfo("stackedDimension") && (null != i ? i === t.getCalculationInfo("stackedByDimension") : t.getCalculationInfo("isStackedByIndex"));
    }
    function gr(t, e, i) {
        i = i || {}, ga.isInstance(t) || (t = ga.seriesDataToSource(t));
        var n, a = e.get("coordinateSystem"), o = Ma.get(a), r = fa(e);
        r && (n = L(r.coordSysDims, function(t) {
            var e = {
                name: t
            }, i = r.axisMap.get(t);
            if (i) {
                var n = i.get("type");
                e.type = ir(n);
            }
            return e;
        })), n || (n = o && (o.getDimensionsInfo ? o.getDimensionsInfo() : o.dimensions.slice()) || [ "x", "y" ]);
        var s, l, h = b_(t, {
            coordDimensions: n,
            generateCoord: i.generateCoord
        });
        r && R(h, function(t, e) {
            var i = t.coordDim, n = r.categoryAxisMap.get(i);
            n && (null == s && (s = e), t.ordinalMeta = n.getOrdinalMeta()), null != t.otherDims.itemName && (l = !0);
        }), l || null == s || (h[s].otherDims.itemName = 0);
        var u = fr(e, h), c = new x_(h, e);
        c.setCalculationInfo(u);
        var d = null != s && function(t) {
            if (t.sourceFormat === Ey) {
                var e = function(t) {
                    for (var e = 0; e < t.length && null == t[e]; ) e++;
                    return t[e];
                }(t.data || []);
                return null != e && !N(ei(e));
            }
        }(t) ? function(t, e, i, n) {
            return n === s ? i : this.defaultDimValueGetter(t, e, i, n);
        } : null;
        return c.hasItemOption = !1, c.initData(t, null, d), c;
    }
    function mr(t) {
        this._setting = t || {}, this._extent = [ 1 / 0, -1 / 0 ], this._interval = 0, this.init && this.init.apply(this, arguments);
    }
    function vr(t) {
        this.categories = t.categories || [], this._needCollect = t.needCollect, this._deduplication = t.deduplication, 
        this._map;
    }
    function yr(t) {
        return t._map || (t._map = W(t.categories));
    }
    function xr(t) {
        return B(t) && null != t.value ? t.value : t + "";
    }
    function _r(t) {
        return Wn(t) + 2;
    }
    function wr(t, e, i) {
        t[e] = Math.max(Math.min(t[e], i[1]), i[0]);
    }
    function br(t, e) {
        !isFinite(t[0]) && (t[0] = e[0]), !isFinite(t[1]) && (t[1] = e[1]), wr(t, 0, e), 
        wr(t, 1, e), t[0] > t[1] && (t[0] = t[1]);
    }
    function Sr(t) {
        return t.get("stack") || C_ + t.seriesIndex;
    }
    function Mr(t) {
        return t.dim + t.index;
    }
    function Ir(t, e) {
        return Tr(L(t, function(t) {
            var e = t.getData(), i = t.coordinateSystem.getBaseAxis(), n = i.getExtent(), a = "category" === i.type ? i.getBandWidth() : Math.abs(n[1] - n[0]) / e.count();
            return {
                bandWidth: a,
                barWidth: zn(t.get("barWidth"), a),
                barMaxWidth: zn(t.get("barMaxWidth"), a),
                barGap: t.get("barGap"),
                barCategoryGap: t.get("barCategoryGap"),
                axisKey: Mr(i),
                stackId: Sr(t)
            };
        }), e);
    }
    function Tr(t, e) {
        var c = {};
        R(t, function(t, e) {
            var i = t.axisKey, n = t.bandWidth, a = c[i] || {
                bandWidth: n,
                remainedWidth: n,
                autoWidthCount: 0,
                categoryGap: "20%",
                gap: "30%",
                stacks: {}
            }, o = a.stacks;
            c[i] = a;
            var r = t.stackId;
            o[r] || a.autoWidthCount++, o[r] = o[r] || {
                width: 0,
                maxWidth: 0
            };
            var s = t.barWidth;
            s && !o[r].width && (o[r].width = s, s = Math.min(a.remainedWidth, s), a.remainedWidth -= s);
            var l = t.barMaxWidth;
            l && (o[r].maxWidth = l);
            var h = t.barGap;
            null != h && (a.gap = h);
            var u = t.barCategoryGap;
            null != u && (a.categoryGap = u);
        });
        var d = {};
        return R(c, function(t, i) {
            d[i] = {};
            var e = t.stacks, n = t.bandWidth, a = zn(t.categoryGap, n), o = zn(t.gap, 1), r = t.remainedWidth, s = t.autoWidthCount, l = (r - a) / (s + (s - 1) * o);
            l = Math.max(l, 0), R(e, function(t, e) {
                var i = t.maxWidth;
                i && i < l && (i = Math.min(i, r), t.width && (i = Math.min(i, t.width)), r -= i, 
                t.width = i, s--);
            }), l = (r - a) / (s + (s - 1) * o), l = Math.max(l, 0);
            var h, u = 0;
            R(e, function(t, e) {
                t.width || (t.width = l), u += (h = t).width * (1 + o);
            }), h && (u -= h.width * o);
            var c = -u / 2;
            R(e, function(t, e) {
                d[i][e] = d[i][e] || {
                    offset: c,
                    width: t.width
                }, c += t.width * (1 + o);
            });
        }), d;
    }
    function Dr(t, e, i) {
        var n = [];
        e.eachSeriesByType(t, function(t) {
            t.coordinateSystem && "cartesian2d" === t.coordinateSystem.type && n.push(t);
        });
        var T = Ir(n), D = {};
        R(n, function(t) {
            var e = t.getData(), i = t.coordinateSystem, n = i.getBaseAxis(), a = Sr(t), o = T[Mr(n)][a], r = o.offset, s = o.width, l = i.getOtherAxis(n), h = t.get("barMinHeight") || 0;
            D[a] = D[a] || [], e.setLayout({
                offset: r,
                size: s
            });
            for (var u = e.mapDimension(l.dim), c = e.mapDimension(n.dim), d = pr(e, u, c), f = l.isHorizontal(), p = 0 <= C(n.getAxesOnZeroOf(), l) || d ? l.toGlobalCoord(l.dataToCoord(0)) : l.getGlobalExtent()[0], g = 0, m = e.count(); g < m; g++) {
                var v = e.get(u, g), y = e.get(c, g);
                if (!isNaN(v)) {
                    var x, _, w, b, S = 0 <= v ? "p" : "n", M = p;
                    if (d && (D[a][y] || (D[a][y] = {
                        p: p,
                        n: p
                    }), M = D[a][y][S]), f) x = M, _ = (I = i.dataToPoint([ v, y ]))[1] + r, w = I[0] - p, 
                    b = s, Math.abs(w) < h && (w = (w < 0 ? -1 : 1) * h), d && (D[a][y][S] += w); else {
                        var I = i.dataToPoint([ y, v ]);
                        x = I[0] + r, _ = M, w = s, b = I[1] - p, Math.abs(b) < h && (b = (b <= 0 ? -1 : 1) * h), 
                        d && (D[a][y][S] += b);
                    }
                    e.setItemLayout(g, {
                        x: x,
                        y: _,
                        width: w,
                        height: b
                    });
                }
            }
        }, this);
    }
    function Ar(t, e) {
        return B_(t, z_(e));
    }
    function Cr(t, e) {
        var i, n, a, o = t.type, r = e.getMin(), s = e.getMax(), l = null != r, h = null != s, u = t.getExtent();
        "ordinal" === o ? i = e.getCategories().length : (N(n = e.get("boundaryGap")) || (n = [ n || 0, n || 0 ]), 
        "boolean" == typeof n[0] && (n = [ 0, 0 ]), n[0] = zn(n[0], 1), n[1] = zn(n[1], 1), 
        a = u[1] - u[0] || Math.abs(u[0])), null == r && (r = "ordinal" === o ? i ? 0 : NaN : u[0] - n[0] * a), 
        null == s && (s = "ordinal" === o ? i ? i - 1 : NaN : u[1] + n[1] * a), "dataMin" === r ? r = u[0] : "function" == typeof r && (r = r({
            min: u[0],
            max: u[1]
        })), "dataMax" === s ? s = u[1] : "function" == typeof s && (s = s({
            min: u[0],
            max: u[1]
        })), (null == r || !isFinite(r)) && (r = NaN), (null == s || !isFinite(s)) && (s = NaN), 
        t.setBlank(y(r) || y(s)), e.getNeedCrossZero() && (0 < r && 0 < s && !l && (r = 0), 
        r < 0 && s < 0 && !h && (s = 0));
        var c = e.ecModel;
        if (c && "time" === o) {
            var d, f = [];
            if (c.eachSeriesByType("bar", function(t) {
                t.coordinateSystem && "cartesian2d" === t.coordinateSystem.type && (f.push(t), d |= t.getBaseAxis() === e.axis);
            }), d) {
                var p = function(t, e, i, n) {
                    var a = i.axis.getExtent(), o = a[1] - a[0], r = Ir(n)[i.axis.dim + i.axis.index];
                    if (void 0 === r) return {
                        min: t,
                        max: e
                    };
                    var s = 1 / 0;
                    R(r, function(t) {
                        s = Math.min(t.offset, s);
                    });
                    var l = -1 / 0;
                    R(r, function(t) {
                        l = Math.max(t.offset + t.width, l);
                    }), s = Math.abs(s), l = Math.abs(l);
                    var h = s + l, u = e - t, c = u / (1 - (s + l) / o) - u;
                    return {
                        min: t -= c * (s / h),
                        max: e += c * (l / h)
                    };
                }(r, s, e, f);
                r = p.min, s = p.max;
            }
        }
        return [ r, s ];
    }
    function Lr(t, e) {
        var i = Cr(t, e), n = null != e.getMin(), a = null != e.getMax(), o = e.get("splitNumber");
        "log" === t.type && (t.base = e.get("logBase"));
        var r = t.type;
        t.setExtent(i[0], i[1]), t.niceExtent({
            splitNumber: o,
            fixMin: n,
            fixMax: a,
            minInterval: "interval" === r || "time" === r ? e.get("minInterval") : null,
            maxInterval: "interval" === r || "time" === r ? e.get("maxInterval") : null
        });
        var s = e.get("interval");
        null != s && t.setInterval && t.setInterval(s);
    }
    function kr(t, e) {
        if (e = e || t.get("type")) switch (e) {
          case "category":
            return new I_(t.getOrdinalMeta ? t.getOrdinalMeta() : t.getCategories(), [ 1 / 0, -1 / 0 ]);

          case "value":
            return new A_();

          default:
            return (mr.getClass(e) || A_).create(t);
        }
    }
    function Pr(t, e, i, n, a) {
        var o, r = 0, s = 0, l = (n - a) / 180 * Math.PI, h = 1;
        40 < e.length && (h = Math.floor(e.length / 40));
        for (var u = 0; u < t.length; u += h) {
            var c = t[u], d = le(e[u], i, "center", "top");
            d.x += c * Math.cos(l), d.y += c * Math.sin(l), d.width *= 1.3, d.height *= 1.3, 
            o ? o.intersect(d) ? (s++, r = Math.max(r, s)) : (o.union(d), s = 0) : o = d.clone();
        }
        return 0 === r && 1 < h ? h : (r + 1) * h - 1;
    }
    function Nr(i, n) {
        var e, t = i.scale, a = t.getTicksLabels(), o = t.getTicks();
        return "string" == typeof n ? (e = n, L(a, n = function(t) {
            return e.replace("{value}", null != t ? t : "");
        })) : "function" == typeof n ? L(o, function(t, e) {
            return n(Or(i, t), e);
        }, this) : a;
    }
    function Or(t, e) {
        return "category" === t.type ? t.scale.getLabel(e) : e;
    }
    function Er(t, e) {
        if ("image" !== this.type) {
            var i = this.style, n = this.shape;
            n && "line" === n.symbolType ? i.stroke = t : this.__isEmptyBrush ? (i.stroke = t, 
            i.fill = e || "#fff") : (i.fill && (i.fill = t), i.stroke && (i.stroke = t)), this.dirty(!1);
        }
    }
    function Rr(t, e, i, n, a, o, r) {
        var s, l = 0 === t.indexOf("empty");
        return l && (t = t.substr(5, 1).toLowerCase() + t.substr(6)), (s = 0 === t.indexOf("image://") ? Ki(t.slice(8), new Xt(e, i, n, a), r ? "center" : "cover") : 0 === t.indexOf("path://") ? qi(t.slice(7), {}, new Xt(e, i, n, a), r ? "center" : "cover") : new $_({
            shape: {
                symbolType: t,
                x: e,
                y: i,
                width: n,
                height: a
            }
        })).__isEmptyBrush = l, s.setColor = Er, s.setColor(o), s;
    }
    function zr(t, e) {
        return Math.abs(t - e) < tw;
    }
    function Br(t, e, i) {
        var n = 0, a = t[0];
        if (!a) return !1;
        for (var o = 1; o < t.length; o++) {
            var r = t[o];
            n += Ri(a[0], a[1], r[0], r[1], e, i), a = r;
        }
        var s = t[0];
        return zr(a[0], s[0]) && zr(a[1], s[1]) || (n += Ri(a[0], a[1], s[0], s[1], e, i)), 
        0 !== n;
    }
    function Vr(t, e, i) {
        if (this.name = t, this.geometries = e, i) i = [ i[0], i[1] ]; else {
            var n = this.getBoundingRect();
            i = [ n.x + n.width / 2, n.y + n.height / 2 ];
        }
        this.center = i;
    }
    function Gr(t, e, i) {
        for (var n = [], a = e[0], o = e[1], r = 0; r < t.length; r += 2) {
            var s = t.charCodeAt(r) - 64, l = t.charCodeAt(r + 1) - 64;
            s = s >> 1 ^ -(1 & s), l = l >> 1 ^ -(1 & l), a = s += a, o = l += o, n.push([ s / i, l / i ]);
        }
        return n;
    }
    function Wr(t, e) {
        var i = (t[1] - t[0]) / e / 2;
        t[0] += i, t[1] -= i;
    }
    function Fr(t, e) {
        var i = t.mapDimension("defaultedLabel", !0), n = i.length;
        if (1 === n) return Ha(t, e, i[0]);
        if (n) {
            for (var a = [], o = 0; o < i.length; o++) {
                var r = Ha(t, e, i[o]);
                a.push(r);
            }
            return a.join(" ");
        }
    }
    function Hr(t) {
        return [ t[0] / 2, t[1] / 2 ];
    }
    function Zr(t, e, i) {
        Dg.call(this), this.updateData(t, e, i);
    }
    function Ur(t, e) {
        this.parent.drift(t, e);
    }
    function jr(t) {
        this.group = new Dg(), this._symbolCtor = t || Zr;
    }
    function Xr(t, e, i, n) {
        return e && !isNaN(e[0]) && !isNaN(e[1]) && !(n.isIgnore && n.isIgnore(i)) && !(n.clipShape && !n.clipShape.contain(e[0], e[1])) && "none" !== t.getItemVisual(i, "symbol");
    }
    function Yr(t) {
        return null == t || B(t) || (t = {
            isIgnore: t
        }), t || {};
    }
    function qr(t) {
        var e = t.hostModel;
        return {
            itemStyle: e.getModel("itemStyle").getItemStyle([ "color" ]),
            hoverItemStyle: e.getModel("emphasis.itemStyle").getItemStyle(),
            symbolRotate: e.get("symbolRotate"),
            symbolOffset: e.get("symbolOffset"),
            hoverAnimation: e.get("hoverAnimation"),
            labelModel: e.getModel("label"),
            hoverLabelModel: e.getModel("emphasis.label"),
            cursorStyle: e.get("cursor")
        };
    }
    function Kr(t, e, i) {
        var n, a, o, r = t.getBaseAxis(), s = t.getOtherAxis(r), l = (n = i, a = 0, o = s.scale.getExtent(), 
        "start" === n ? a = o[0] : "end" === n ? a = o[1] : 0 < o[0] ? a = o[0] : o[1] < 0 && (a = o[1]), 
        a), h = r.dim, u = s.dim, c = e.mapDimension(u), d = e.mapDimension(h), f = "x" === u || "radius" === u ? 1 : 0, p = pr(e, c, d);
        return {
            dataDimsForPoint: L(t.dimensions, function(t) {
                return e.mapDimension(t);
            }),
            valueStart: l,
            valueAxisDim: u,
            baseAxisDim: h,
            stacked: p,
            valueDim: c,
            baseDim: d,
            baseDataOffset: f,
            stackedOverDimension: e.getCalculationInfo("stackedOverDimension")
        };
    }
    function $r(t, e, i, n) {
        var a = NaN;
        t.stacked && (a = i.get(i.getCalculationInfo("stackedOverDimension"), n)), isNaN(a) && (a = t.valueStart);
        var o = t.baseDataOffset, r = [];
        return r[o] = i.get(t.baseDim, n), r[1 - o] = a, e.dataToPoint(r);
    }
    function Jr(t) {
        return isNaN(t[0]) || isNaN(t[1]);
    }
    function Qr(t, e, i, n, a, o, r, s, l, h, u) {
        return null == h ? ts(e, "x") ? es(t, e, i, n, a, o, r, s, l, "x", u) : ts(e, "y") ? es(t, e, i, n, a, o, r, s, l, "y", u) : is.apply(this, arguments) : "none" !== h && ts(e, h) ? es.apply(this, arguments) : is.apply(this, arguments);
    }
    function ts(t, e) {
        if (t.length <= 1) return !0;
        for (var i = "x" === e ? 0 : 1, n = t[0][i], a = 0, o = 1; o < t.length; ++o) {
            var r = t[o][i] - n;
            if (!isNaN(r) && !isNaN(a) && 0 !== r && 0 !== a && 0 <= r != 0 <= a) return !1;
            isNaN(r) || 0 === r || (a = r, n = t[o][i]);
        }
        return !0;
    }
    function es(t, e, i, n, a, o, r, s, l, h, u) {
        for (var c = 0, d = i, f = 0; f < n; f++) {
            var p = e[d];
            if (a <= d || d < 0) break;
            if (Jr(p)) {
                if (u) {
                    d += o;
                    continue;
                }
                break;
            }
            if (d === i) t[0 < o ? "moveTo" : "lineTo"](p[0], p[1]); else if (0 < l) {
                var g = e[c], m = "y" === h ? 1 : 0, v = (p[m] - g[m]) * l;
                mw(yw, g), yw[m] = g[m] + v, mw(xw, p), xw[m] = p[m] - v, t.bezierCurveTo(yw[0], yw[1], xw[0], xw[1], p[0], p[1]);
            } else t.lineTo(p[0], p[1]);
            c = d, d += o;
        }
        return f;
    }
    function is(t, e, i, n, a, o, r, s, l, h, u) {
        for (var c = 0, d = i, f = 0; f < n; f++) {
            var p = e[d];
            if (a <= d || d < 0) break;
            if (Jr(p)) {
                if (u) {
                    d += o;
                    continue;
                }
                break;
            }
            if (d === i) t[0 < o ? "moveTo" : "lineTo"](p[0], p[1]), mw(yw, p); else if (0 < l) {
                var g = d + o, m = e[g];
                if (u) for (;m && Jr(e[g]); ) m = e[g += o];
                var v = .5, y = e[c];
                if (!(m = e[g]) || Jr(m)) mw(xw, p); else {
                    var x, _;
                    if (Jr(m) && !u && (m = p), U(vw, m, y), "x" === h || "y" === h) {
                        var w = "x" === h ? 0 : 1;
                        x = Math.abs(p[w] - y[w]), _ = Math.abs(p[w] - m[w]);
                    } else x = Wp(p, y), _ = Wp(p, m);
                    gw(xw, p, vw, -l * (1 - (v = _ / (_ + x))));
                }
                fw(yw, yw, s), pw(yw, yw, r), fw(xw, xw, s), pw(xw, xw, r), t.bezierCurveTo(yw[0], yw[1], xw[0], xw[1], p[0], p[1]), 
                gw(yw, p, vw, l * v);
            } else t.lineTo(p[0], p[1]);
            c = d, d += o;
        }
        return f;
    }
    function ns(t, e) {
        var i = [ 1 / 0, 1 / 0 ], n = [ -1 / 0, -1 / 0 ];
        if (e) for (var a = 0; a < t.length; a++) {
            var o = t[a];
            o[0] < i[0] && (i[0] = o[0]), o[1] < i[1] && (i[1] = o[1]), o[0] > n[0] && (n[0] = o[0]), 
            o[1] > n[1] && (n[1] = o[1]);
        }
        return {
            min: e ? i : n,
            max: e ? n : i
        };
    }
    function as(t, e) {
        if (t.length === e.length) {
            for (var i = 0; i < t.length; i++) {
                var n = t[i], a = e[i];
                if (n[0] !== a[0] || n[1] !== a[1]) return;
            }
            return !0;
        }
    }
    function os(t) {
        return "number" == typeof t ? t : t ? .5 : 0;
    }
    function rs(t) {
        var e = t.getGlobalExtent();
        if (t.onBand) {
            var i = t.getBandWidth() / 2 - 1, n = e[1] > e[0] ? 1 : -1;
            e[0] += n * i, e[1] -= n * i;
        }
        return e;
    }
    function ss(t, e, i) {
        return "polar" === t.type ? (a = e, o = i, r = (n = t).getAngleAxis(), s = n.getRadiusAxis().getExtent(), 
        l = r.getExtent(), h = Math.PI / 180, u = new zv({
            shape: {
                cx: Bn(n.cx, 1),
                cy: Bn(n.cy, 1),
                r0: Bn(s[0], 1),
                r: Bn(s[1], 1),
                startAngle: -l[0] * h,
                endAngle: -l[1] * h,
                clockwise: r.inverse
            }
        }), a && (u.shape.endAngle = -l[0] * h, In(u, {
            shape: {
                endAngle: -l[1] * h
            }
        }, o)), u) : function(t, e, i) {
            var n = rs(t.getAxis("x")), a = rs(t.getAxis("y")), o = t.getBaseAxis().isHorizontal(), r = Math.min(n[0], n[1]), s = Math.min(a[0], a[1]), l = Math.max(n[0], n[1]) - r, h = Math.max(a[0], a[1]) - s, u = i.get("lineStyle.width") || 2, c = i.get("clipOverflow") ? u / 2 : Math.max(l, h);
            o ? (s -= c, h += 2 * c) : (r -= c, l += 2 * c), r = Bn(r, 1), s = Bn(s, 1), l = Bn(l, 1), 
            h = Bn(h, 1);
            var d = new Wv({
                shape: {
                    x: r,
                    y: s,
                    width: l,
                    height: h
                }
            });
            return e && (d.shape[o ? "width" : "height"] = 0, In(d, {
                shape: {
                    width: l,
                    height: h
                }
            }, i)), d;
        }(t, e, i);
        var n, a, o, r, s, l, h, u;
    }
    function ls(t, e, i) {
        for (var n = e.getBaseAxis(), a = "x" === n.dim || "radius" === n.dim ? 0 : 1, o = [], r = 0; r < t.length - 1; r++) {
            var s = t[r + 1], l = t[r];
            o.push(l);
            var h = [];
            switch (i) {
              case "end":
                h[a] = s[a], h[1 - a] = l[1 - a], o.push(h);
                break;

              case "middle":
                var u = (l[a] + s[a]) / 2, c = [];
                h[a] = c[a] = u, h[1 - a] = l[1 - a], c[1 - a] = s[1 - a], o.push(h), o.push(c);
                break;

              default:
                h[a] = l[a], h[1 - a] = s[1 - a], o.push(h);
            }
        }
        return t[r] && o.push(t[r]), o;
    }
    function hs(t) {
        return this._axes[t];
    }
    function us(t) {
        Tw.call(this, t);
    }
    function cs(t, e) {
        return e.type || (e.data ? "category" : "value");
    }
    function ds(t, e, i) {
        return t.getCoordSysModel() === e;
    }
    function fs(t, e, i) {
        this._coordsMap = {}, this._coordsList = [], this._axesMap = {}, this._axesList = [], 
        this._initCartesian(t, e, i), this.model = t;
    }
    function ps(t, e, i) {
        i.getAxesOnZeroOf = function() {
            return n ? [ n ] : [];
        };
        var n, a = t[e], o = i.model, r = o.get("axisLine.onZero"), s = o.get("axisLine.onZeroAxisIndex");
        if (r) if (null == s) {
            for (var l in a) if (a.hasOwnProperty(l) && gs(a[l])) {
                n = a[l];
                break;
            }
        } else gs(a[s]) && (n = a[s]);
    }
    function gs(t) {
        return t && "category" !== t.type && "time" !== t.type && Ew(t);
    }
    function ms(e, t) {
        return L(Bw, function(t) {
            return e.getReferringComponents(t)[0];
        });
    }
    function vs(t) {
        return "cartesian2d" === t.get("coordinateSystem");
    }
    function ys(t) {
        var e = {
            componentType: t.mainType
        };
        return e[t.mainType + "Index"] = t.componentIndex, e;
    }
    function xs(t) {
        var e = t.get("tooltip");
        return t.get("silent") || !(t.get("triggerEvent") || e && e.show);
    }
    function _s(t) {
        t && (t.ignore = !0);
    }
    function ws(t, e, i) {
        var n = t && t.getBoundingRect().clone(), a = e && e.getBoundingRect().clone();
        if (n && a) {
            var o = st([]);
            return ct(o, o, -t.rotation), n.applyTransform(ht([], o, t.getLocalTransform())), 
            a.applyTransform(ht([], o, e.getLocalTransform())), n.intersect(a);
        }
    }
    function bs(t) {
        return "middle" === t || "center" === t;
    }
    function Ss(t, e) {
        var p, g, i, o, m, v, y, n = {
            axesInfo: {},
            seriesInvolved: !1,
            coordSysAxesInfo: {},
            coordSysMap: {}
        };
        return p = n, i = e, o = (g = t).getComponent("tooltip"), m = g.getComponent("axisPointer"), 
        v = m.get("link", !0) || [], y = [], Uw(i.getCoordinateSystems(), function(c) {
            function t(t, e, i) {
                var n = i.model.getModel("axisPointer", m), a = n.get("show");
                if (a && ("auto" !== a || t || Ts(n))) {
                    null == e && (e = n.get("triggerTooltip"));
                    var o = (n = t ? function(t, e, i, n, a, o) {
                        var r = e.getModel("axisPointer"), s = {};
                        Uw([ "type", "snap", "lineStyle", "shadowStyle", "label", "animation", "animationDurationUpdate", "animationEasingUpdate", "z" ], function(t) {
                            s[t] = A(r.get(t));
                        }), s.snap = "category" !== t.type && !!o, "cross" === r.get("type") && (s.type = "line");
                        var l = s.label || (s.label = {});
                        if (null == l.show && (l.show = !1), "cross" === a) {
                            var h = r.get("label.show");
                            if (l.show = null == h || h, !o) {
                                var u = s.lineStyle = r.get("crossStyle");
                                u && E(l, u.textStyle);
                            }
                        }
                        return t.model.getModel("axisPointer", new Pn(s, i, n));
                    }(i, f, m, g, t, e) : n).get("snap"), r = Ds(i.model), s = e || o || "category" === i.type, l = p.axesInfo[r] = {
                        key: r,
                        axis: i,
                        coordSys: c,
                        axisPointerModel: n,
                        triggerTooltip: e,
                        involveSeries: s,
                        snap: o,
                        useHandle: Ts(n),
                        seriesModels: []
                    };
                    d[r] = l, p.seriesInvolved |= s;
                    var h = function(t, e) {
                        for (var i = e.model, n = e.dim, a = 0; a < t.length; a++) {
                            var o = t[a] || {};
                            if (Ms(o[n + "AxisId"], i.id) || Ms(o[n + "AxisIndex"], i.componentIndex) || Ms(o[n + "AxisName"], i.name)) return a;
                        }
                    }(v, i);
                    if (null != h) {
                        var u = y[h] || (y[h] = {
                            axesInfo: {}
                        });
                        u.axesInfo[r] = l, u.mapper = v[h].mapper, l.linkGroup = u;
                    }
                }
            }
            if (c.axisPointerEnabled) {
                var e = Ds(c.model), d = p.coordSysAxesInfo[e] = {}, f = (p.coordSysMap[e] = c).model.getModel("tooltip", o);
                if (Uw(c.getAxes(), jw(t, !1, null)), c.getTooltipAxes && o && f.get("show")) {
                    var i = "axis" === f.get("trigger"), n = "cross" === f.get("axisPointer.type"), a = c.getTooltipAxes(f.get("axisPointer.axis"));
                    (i || n) && Uw(a.baseAxes, jw(t, !n || "cross", i)), n && Uw(a.otherAxes, jw(t, "cross", !1));
                }
            }
        }), n.seriesInvolved && function(a, t) {
            t.eachSeries(function(i) {
                var n = i.coordinateSystem, t = i.get("tooltip.trigger", !0), e = i.get("tooltip.show", !0);
                n && "none" !== t && !1 !== t && "item" !== t && !1 !== e && !1 !== i.get("axisPointer.show", !0) && Uw(a.coordSysAxesInfo[Ds(n.model)], function(t) {
                    var e = t.axis;
                    n.getAxis(e.dim) === e && (t.seriesModels.push(i), null == t.seriesDataCount && (t.seriesDataCount = 0), 
                    t.seriesDataCount += i.getData().count());
                });
            }, this);
        }(n, t), n;
    }
    function Ms(t, e) {
        return "all" === t || N(t) && 0 <= C(t, e) || t === e;
    }
    function Is(t) {
        var e = (t.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
        return e && e.axesInfo[Ds(t)];
    }
    function Ts(t) {
        return !!t.get("handle.show");
    }
    function Ds(t) {
        return t.type + "||" + t.id;
    }
    function As(t, e, i, n, a, o) {
        var r, s = Xw.getAxisPointerClass(t.axisPointerClass);
        if (s) {
            var l = (r = Is(e)) && r.axisPointerModel;
            l ? (t._axisPointer || (t._axisPointer = new s())).render(e, l, n, o) : Cs(t, n);
        }
    }
    function Cs(t, e, i) {
        var n = t._axisPointer;
        n && n.dispose(e, i), t._axisPointer = null;
    }
    function Ls(t, e, i) {
        i = i || {};
        var n = t.coordinateSystem, a = e.axis, o = {}, r = a.getAxesOnZeroOf()[0], s = a.position, l = r ? "onZero" : s, h = a.dim, u = n.getRect(), c = [ u.x, u.x + u.width, u.y, u.y + u.height ], d = {
            left: 0,
            right: 1,
            top: 0,
            bottom: 1,
            onZero: 2
        }, f = e.get("offset") || 0, p = "x" === h ? [ c[2] - f, c[3] + f ] : [ c[0] - f, c[1] + f ];
        if (r) {
            var g = r.toGlobalCoord(r.dataToCoord(0));
            p[d.onZero] = Math.max(Math.min(g, p[1]), p[0]);
        }
        o.position = [ "y" === h ? p[d[l]] : c[0], "x" === h ? p[d[l]] : c[3] ], o.rotation = Math.PI / 2 * ("x" === h ? 0 : 1), 
        o.labelDirection = o.tickDirection = o.nameDirection = {
            top: -1,
            bottom: 1,
            left: -1,
            right: 1
        }[s], o.labelOffset = r ? p[d[s]] - p[d.onZero] : 0, e.get("axisTick.inside") && (o.tickDirection = -o.tickDirection), 
        V(i.labelInside, e.get("axisLabel.inside")) && (o.labelDirection = -o.labelDirection);
        var m = e.get("axisLabel.rotate");
        return o.labelRotate = "top" === l ? -m : m, o.labelInterval = a.getLabelInterval(), 
        o.z2 = 1, o;
    }
    function ks(t, e, i, n, a, o, r) {
        mn(t, e, i.getModel("label"), i.getModel("emphasis.label"), {
            labelFetcher: a,
            labelDataIndex: o,
            defaultText: Fr(a.getData(), o),
            isRectText: !0,
            autoColor: n
        }), Ps(t), Ps(e);
    }
    function Ps(t, e) {
        "outside" === t.textPosition && (t.textPosition = e);
    }
    function Ns(t, e, i) {
        i.style.text = null, Mn(i, {
            shape: {
                width: 0
            }
        }, e, t, function() {
            i.parent && i.parent.remove(i);
        });
    }
    function Os(t, e, i) {
        i.style.text = null, Mn(i, {
            shape: {
                r: i.shape.r0
            }
        }, e, t, function() {
            i.parent && i.parent.remove(i);
        });
    }
    function Es(t, e, i, n, a, o, r, s) {
        var l = e.getItemVisual(i, "color"), h = e.getItemVisual(i, "opacity"), u = n.getModel("itemStyle"), c = n.getModel("emphasis.itemStyle").getBarItemStyle();
        s || t.setShape("r", u.get("barBorderRadius") || 0), t.useStyle(E({
            fill: l,
            opacity: h
        }, u.getBarItemStyle()));
        var d = n.getShallow("cursor");
        d && t.attr("cursor", d);
        r ? a.height : a.width;
        s || ks(t.style, c, n, l, o, i), gn(t, c);
    }
    function Rs(t, e, i, n) {
        var a = e.getData(), o = this.dataIndex, r = a.getName(o), s = e.get("selectedOffset");
        n.dispatchAction({
            type: "pieToggleSelect",
            from: t,
            name: r,
            seriesId: e.id
        }), a.each(function(t) {
            zs(a.getItemGraphicEl(t), a.getItemLayout(t), e.isSelected(a.getName(t)), s, i);
        });
    }
    function zs(t, e, i, n, a) {
        var o = (e.startAngle + e.endAngle) / 2, r = i ? n : 0, s = [ Math.cos(o) * r, Math.sin(o) * r ];
        a ? t.animate().when(200, {
            position: s
        }).start("bounceOut") : t.attr("position", s);
    }
    function Bs(t, e) {
        function i() {
            o.ignore = o.hoverIgnore, r.ignore = r.hoverIgnore;
        }
        function n() {
            o.ignore = o.normalIgnore, r.ignore = r.normalIgnore;
        }
        Dg.call(this);
        var a = new zv({
            z2: 2
        }), o = new Gv(), r = new Nv();
        this.add(a), this.add(o), this.add(r), this.updateData(t, e, !0), this.on("emphasis", i).on("normal", n).on("mouseover", i).on("mouseout", n);
    }
    function Vs(o, t, e, i, n, a, r) {
        function s(t, e) {
            for (var i = t; 0 <= i && (o[i].y -= e, !(0 < i && o[i].y > o[i - 1].y + o[i - 1].height)); i--) ;
        }
        function l(t, e, i, n, a, o) {
            for (var r = e ? Number.MAX_VALUE : 0, s = 0, l = t.length; s < l; s++) if ("center" !== t[s].position) {
                var h = Math.abs(t[s].y - n), u = t[s].len, c = t[s].len2, d = h < a + u ? Math.sqrt((a + u + c) * (a + u + c) - h * h) : Math.abs(t[s].x - i);
                e && r <= d && (d = r - 10), !e && d <= r && (d = r + 10), t[s].x = i + d * o, r = d;
            }
        }
        o.sort(function(t, e) {
            return t.y - e.y;
        });
        for (var h, u = 0, c = o.length, d = [], f = [], p = 0; p < c; p++) (h = o[p].y - u) < 0 && function(t, e, i, n) {
            for (var a = t; a < e; a++) if (o[a].y += i, t < a && a + 1 < e && o[a + 1].y > o[a].y + o[a].height) return s(a, i / 2);
            s(e - 1, i / 2);
        }(p, c, -h), u = o[p].y + o[p].height;
        for (r - u < 0 && s(c - 1, u - r), p = 0; p < c; p++) o[p].y >= e ? f.push(o[p]) : d.push(o[p]);
        l(d, !1, t, e, i, n), l(f, !0, t, e, i, n);
    }
    function Gs() {
        this.group = new Dg();
    }
    function Ws(t, e, i) {
        aw.call(this, t, e, i), this.type = "value", this.angle = 0, this.name = "", this.model;
    }
    function Fs(t, e, i) {
        this._model = t, this.dimensions = [], this._indicatorAxes = L(t.getIndicatorModels(), function(t, e) {
            var i = "indicator_" + e, n = new Ws(i, new A_());
            return n.name = t.get("name"), (n.model = t).axis = n, this.dimensions.push(i), 
            n;
        }, this), this.resize(t, i), this.cx, this.cy, this.r, this.startAngle;
    }
    function Hs(t, e) {
        return E({
            show: e
        }, t);
    }
    function Zs() {
        Jp.call(this);
    }
    function Us(t) {
        this.name = t, this.zoomLimit, Jp.call(this), this._roamTransformable = new Zs(), 
        this._rawTransformable = new Zs(), this._center, this._zoom;
    }
    function js(t, e, i, n) {
        var a = i.seriesModel, o = a ? a.coordinateSystem : null;
        return o === this ? o[t](n) : null;
    }
    function Xs(t, e, i, n, a) {
        Us.call(this, t), this.map = e, this._nameCoordMap = W(), this.loadGeoJson(i, n, a);
    }
    function Ys(t, e, i, n) {
        var a = i.geoModel, o = i.seriesModel, r = a ? a.coordinateSystem : o ? o.coordinateSystem || (o.getReferringComponents("geo")[0] || {}).coordinateSystem : null;
        return r === this ? r[t](n) : null;
    }
    function qs(t, e) {
        var i = t.get("boundingCoords");
        if (null != i) {
            var n = i[0], a = i[1];
            isNaN(n[0]) || isNaN(n[1]) || isNaN(a[0]) || isNaN(a[1]) || this.setBoundingRect(n[0], n[1], a[0] - n[0], a[1] - n[1]);
        }
        var o, r = this.getBoundingRect(), s = t.get("layoutCenter"), l = t.get("layoutSize"), h = e.getWidth(), u = e.getHeight(), c = t.get("aspectScale") || .75, d = r.width / r.height * c, f = !1;
        if (s && l && (s = [ zn(s[0], h), zn(s[1], u) ], l = zn(l, Math.min(h, u)), isNaN(s[0]) || isNaN(s[1]) || isNaN(l) || (f = !0)), 
        f) {
            var p = {};
            1 < d ? (p.width = l, p.height = l / d) : (p.height = l, p.width = l * d), p.y = s[1] - p.height / 2, 
            p.x = s[0] - p.width / 2;
        } else (o = t.getBoxLayoutParams()).aspect = d, p = la(o, {
            width: h,
            height: u
        });
        this.setViewRect(p.x, p.y, p.width, p.height), this.setCenter(t.get("center")), 
        this.setZoom(t.get("zoom"));
    }
    function Ks(i, t) {
        R(t.get("geoCoord"), function(t, e) {
            i.addGeoCoord(e, t);
        });
    }
    function $s(t, e) {
        return !!Js(t)[e];
    }
    function Js(t) {
        return t[kb] || (t[kb] = {});
    }
    function Qs(i) {
        this.pointerChecker, this._zr = i, this._opt = {};
        var t = _, n = t(tl, this), a = t(el, this), o = t(il, this), r = t(nl, this), s = t(al, this);
        Up.call(this), this.setPointerChecker = function(t) {
            this.pointerChecker = t;
        }, this.enable = function(t, e) {
            this.disable(), this._opt = E(A(e) || {}, {
                zoomOnMouseWheel: !0,
                moveOnMouseMove: !0,
                preventDefaultMouseMove: !0
            }), null == t && (t = !0), !0 !== t && "move" !== t && "pan" !== t || (i.on("mousedown", n), 
            i.on("mousemove", a), i.on("mouseup", o)), !0 !== t && "scale" !== t && "zoom" !== t || (i.on("mousewheel", r), 
            i.on("pinch", s));
        }, this.disable = function() {
            i.off("mousedown", n), i.off("mousemove", a), i.off("mouseup", o), i.off("mousewheel", r), 
            i.off("pinch", s);
        }, this.dispose = this.disable, this.isDragging = function() {
            return this._dragging;
        }, this.isPinching = function() {
            return this._pinching;
        };
    }
    function tl(t) {
        if (!(Ze(t) || t.target && t.target.draggable)) {
            var e = t.offsetX, i = t.offsetY;
            this.pointerChecker && this.pointerChecker(t, e, i) && (this._x = e, this._y = i, 
            this._dragging = !0);
        }
    }
    function el(t) {
        if (!Ze(t) && rl(this, "moveOnMouseMove", t) && this._dragging && "pinch" !== t.gestureEvent && !$s(this._zr, "globalPan")) {
            var e = t.offsetX, i = t.offsetY, n = this._x, a = this._y, o = e - n, r = i - a;
            this._x = e, this._y = i, this._opt.preventDefaultMouseMove && nm(t.event), this.trigger("pan", o, r, n, a, e, i);
        }
    }
    function il(t) {
        Ze(t) || (this._dragging = !1);
    }
    function nl(t) {
        if (rl(this, "zoomOnMouseWheel", t) && 0 !== t.wheelDelta) {
            var e = 0 < t.wheelDelta ? 1.1 : 1 / 1.1;
            ol.call(this, t, e, t.offsetX, t.offsetY);
        }
    }
    function al(t) {
        if (!$s(this._zr, "globalPan")) {
            var e = 1 < t.pinchScale ? 1.1 : 1 / 1.1;
            ol.call(this, t, e, t.pinchX, t.pinchY);
        }
    }
    function ol(t, e, i, n) {
        this.pointerChecker && this.pointerChecker(t, i, n) && (nm(t.event), this.trigger("zoom", e, i, n));
    }
    function rl(t, e, i) {
        var n = t._opt[e];
        return n && (!b(n) || i.event[n + "Key"]);
    }
    function sl(t, e, i) {
        var n = t.target, a = n.position;
        a[0] += e, a[1] += i, n.dirty();
    }
    function ll(t, e, i, n) {
        var a = t.target, o = t.zoomLimit, r = a.position, s = a.scale, l = t.zoom = t.zoom || 1;
        if (l *= e, o) {
            var h = o.min || 0, u = o.max || 1 / 0;
            l = Math.max(Math.min(u, l), h);
        }
        var c = l / t.zoom;
        t.zoom = l, r[0] -= (i - r[0]) * (c - 1), r[1] -= (n - r[1]) * (c - 1), s[0] *= c, 
        s[1] *= c, a.dirty();
    }
    function hl(t, e, i) {
        var n = e.getComponentByElement(t.topTarget), a = n && n.coordinateSystem;
        return n && n !== i && !Pb[n.mainType] && a && a.model !== i;
    }
    function ul(t, e) {
        var i = t.getItemStyle(), n = t.get("areaColor");
        return null != n && (i.fill = n), i;
    }
    function cl(i, t) {
        t.eachChild(function(e) {
            R(e.__regions, function(t) {
                e.trigger(i.isSelected(t.name) ? "emphasis" : "normal");
            });
        });
    }
    function dl(t, e) {
        var i = new Dg();
        this._controller = new Qs(t.getZr()), this._controllerHost = {
            target: e ? i : null
        }, this.group = i, this._updateGroup = e, this._mouseDownFlag;
    }
    function fl(t, e, i) {
        var n = t.getZoom(), a = t.getCenter(), o = e.zoom, r = t.dataToPoint(a);
        if (null != e.dx && null != e.dy && (r[0] -= e.dx, r[1] -= e.dy, a = t.pointToData(r), 
        t.setCenter(a)), null != o) {
            if (i) {
                var s = i.min || 0, l = i.max || 1 / 0;
                o = Math.max(Math.min(n * o, l), s) / n;
            }
            t.scale[0] *= o, t.scale[1] *= o;
            var h = t.position, u = (e.originX - h[0]) * (o - 1), c = (e.originY - h[1]) * (o - 1);
            h[0] -= u, h[1] -= c, t.updateTransform(), a = t.pointToData(r), t.setCenter(a), 
            t.setZoom(o * n);
        }
        return {
            center: t.getCenter(),
            zoom: t.getZoom()
        };
    }
    function pl(i) {
        var n = i.mainData, t = i.datas;
        t || (t = {
            main: n
        }, i.datasAttr = {
            main: "data"
        }), i.datas = i.mainData = null, xl(n, t, i), Nb(t, function(e) {
            Nb(n.TRANSFERABLE_METHODS, function(t) {
                e.wrapMethod(t, z(gl, i));
            });
        }), n.wrapMethod("cloneShallow", z(vl, i)), Nb(n.CHANGABLE_METHODS, function(t) {
            n.wrapMethod(t, z(ml, i));
        }), c(t[n.dataType] === n);
    }
    function gl(t, e) {
        if ((n = this)[Eb] === n) {
            var i = P({}, this[Ob]);
            xl(i[this.dataType] = e, i, t);
        } else _l(e, this.dataType, this[Eb], t);
        var n;
        return e;
    }
    function ml(t, e) {
        return t.struct && t.struct.update(this), e;
    }
    function vl(i, n) {
        return Nb(n[Ob], function(t, e) {
            t !== n && _l(t.cloneShallow(), e, n, i);
        }), n;
    }
    function yl(t) {
        var e = this[Eb];
        return null == t || null == e ? e : e[Ob][t];
    }
    function xl(i, t, n) {
        i[Ob] = {}, Nb(t, function(t, e) {
            _l(t, e, i, n);
        });
    }
    function _l(t, e, i, n) {
        (i[Ob][e] = t)[Eb] = i, t.dataType = e, n.struct && (t[n.structAttr] = n.struct, 
        n.struct[n.datasAttr[e]] = t), t.getLinkedData = yl;
    }
    function wl(e, t, i) {
        this.root, this.data, this._nodes = [], this.hostModel = e, this.levelModels = L(t || [], function(t) {
            return new Pn(t, e, e.ecModel);
        }), this.leavesModel = new Pn(i || {}, e, e.ecModel);
    }
    function bl(t, e) {
        var i = t.isExpand ? t.children : [], n = t.parentNode.children, a = t.hierNode.i ? n[t.hierNode.i - 1] : null;
        if (i.length) {
            !function(t) {
                for (var e = t.children, i = e.length, n = 0, a = 0; 0 <= --i; ) {
                    var o = e[i];
                    o.hierNode.prelim += n, o.hierNode.modifier += n, a += o.hierNode.change, n += o.hierNode.shift + a;
                }
            }(t);
            var o = (i[0].hierNode.prelim + i[i.length - 1].hierNode.prelim) / 2;
            a ? (t.hierNode.prelim = a.hierNode.prelim + e(t, a), t.hierNode.modifier = t.hierNode.prelim - o) : t.hierNode.prelim = o;
        } else a && (t.hierNode.prelim = a.hierNode.prelim + e(t, a));
        t.parentNode.hierNode.defaultAncestor = function(t, e, i, n) {
            if (e) {
                for (var a = t, o = t, r = o.parentNode.children[0], s = e, l = a.hierNode.modifier, h = o.hierNode.modifier, u = r.hierNode.modifier, c = s.hierNode.modifier; s = Tl(s), 
                o = Dl(o), s && o; ) {
                    a = Tl(a), r = Dl(r), a.hierNode.ancestor = t;
                    var d = s.hierNode.prelim + c - o.hierNode.prelim - h + n(s, o);
                    0 < d && (y = t, x = i, f = (v = s).hierNode.ancestor.parentNode === y.parentNode ? v.hierNode.ancestor : x, 
                    void 0, m = (g = d) / ((p = t).hierNode.i - f.hierNode.i), p.hierNode.change -= m, 
                    p.hierNode.shift += g, p.hierNode.modifier += g, p.hierNode.prelim += g, f.hierNode.change += m, 
                    h += d, l += d), c += s.hierNode.modifier, h += o.hierNode.modifier, l += a.hierNode.modifier, 
                    u += r.hierNode.modifier;
                }
                s && !Tl(a) && (a.hierNode.thread = s, a.hierNode.modifier += c - l), o && !Dl(r) && (r.hierNode.thread = o, 
                r.hierNode.modifier += h - u, i = t);
            }
            var f, p, g, m;
            var v, y, x;
            return i;
        }(t, a, t.parentNode.hierNode.defaultAncestor || n[0], e);
    }
    function Sl(t) {
        var e = t.hierNode.prelim + t.parentNode.hierNode.modifier;
        t.setLayout({
            x: e
        }, !0), t.hierNode.modifier += t.parentNode.hierNode.modifier;
    }
    function Ml(t) {
        return arguments.length ? t : Al;
    }
    function Il(t, e) {
        var i = {};
        return t -= Math.PI / 2, i.x = e * Math.cos(t), i.y = e * Math.sin(t), i;
    }
    function Tl(t) {
        var e = t.children;
        return e.length && t.isExpand ? e[e.length - 1] : t.hierNode.thread;
    }
    function Dl(t) {
        var e = t.children;
        return e.length && t.isExpand ? e[0] : t.hierNode.thread;
    }
    function Al(t, e) {
        return t.parentNode === e.parentNode ? 1 : 2;
    }
    function Cl(t, e) {
        var i = t.getItemLayout(e);
        return i && !isNaN(i.x) && !isNaN(i.y) && "none" !== t.getItemVisual(e, "symbol");
    }
    function Ll(t, e, i) {
        return i.itemModel = e, i.itemStyle = e.getModel("itemStyle").getItemStyle(), i.hoverItemStyle = e.getModel("emphasis.itemStyle").getItemStyle(), 
        i.lineStyle = e.getModel("lineStyle").getLineStyle(), i.labelModel = e.getModel("label"), 
        i.hoverLabelModel = e.getModel("emphasis.label"), !1 === t.isExpand && 0 !== t.children.length ? i.symbolInnerColor = i.itemStyle.fill : i.symbolInnerColor = "#fff", 
        i;
    }
    function kl(t, e, i, n, a, o) {
        var r = !i, s = t.tree.getNodeByDataIndex(e), l = (o = Ll(s, s.getModel(), o), t.tree.root), h = s.parentNode === l ? s : s.parentNode || s, u = t.getItemGraphicEl(h.dataIndex), c = h.getLayout(), d = u ? {
            x: u.position[0],
            y: u.position[1],
            rawX: u.__radialOldRawX,
            rawY: u.__radialOldRawY
        } : c, f = s.getLayout();
        r ? (i = new Zr(t, e, o)).attr("position", [ d.x, d.y ]) : i.updateData(t, e, o), 
        i.__radialOldRawX = i.__radialRawX, i.__radialOldRawY = i.__radialRawY, i.__radialRawX = f.rawX, 
        i.__radialRawY = f.rawY, n.add(i), t.setItemGraphicEl(e, i), Mn(i, {
            position: [ f.x, f.y ]
        }, a);
        var p = i.getSymbolPath();
        if ("radial" === o.layout) {
            var g, m, v = l.children[0], y = v.getLayout(), x = v.children.length;
            if (f.x === y.x && !0 === s.isExpand) {
                var _ = {};
                _.x = (v.children[0].getLayout().x + v.children[x - 1].getLayout().x) / 2, _.y = (v.children[0].getLayout().y + v.children[x - 1].getLayout().y) / 2, 
                (g = Math.atan2(_.y - y.y, _.x - y.x)) < 0 && (g = 2 * Math.PI + g), (m = _.x < y.x) && (g -= Math.PI);
            } else (g = Math.atan2(f.y - y.y, f.x - y.x)) < 0 && (g = 2 * Math.PI + g), 0 === s.children.length || 0 !== s.children.length && !1 === s.isExpand ? (m = f.x < y.x) && (g -= Math.PI) : (m = f.x > y.x) || (g -= Math.PI);
            var w = m ? "left" : "right";
            p.setStyle({
                textPosition: w,
                textRotation: -g,
                textOrigin: "center",
                verticalAlign: "middle"
            });
        }
        if (s.parentNode && s.parentNode !== l) {
            var b = i.__edge;
            b || (b = i.__edge = new Zv({
                shape: Nl(o, d, d),
                style: E({
                    opacity: 0
                }, o.lineStyle)
            })), Mn(b, {
                shape: Nl(o, c, f),
                style: {
                    opacity: 1
                }
            }, a), n.add(b);
        }
    }
    function Pl(t, e, i, n, a, o) {
        for (var r, s = t.tree.getNodeByDataIndex(e), l = t.tree.root, h = (o = Ll(s, s.getModel(), o), 
        s.parentNode === l ? s : s.parentNode || s); null == (r = h.getLayout()); ) h = h.parentNode === l ? h : h.parentNode || h;
        Mn(i, {
            position: [ r.x + 1, r.y + 1 ]
        }, a, function() {
            n.remove(i), t.setItemGraphicEl(e, null);
        }), i.fadeOut(null, {
            keepLabel: !0
        });
        var u = i.__edge;
        u && Mn(u, {
            shape: Nl(o, r, r),
            style: {
                opacity: 0
            }
        }, a, function() {
            n.remove(u);
        });
    }
    function Nl(t, e, i) {
        var n, a, o, r, s = t.orient;
        if ("radial" === t.layout) {
            var l = e.rawX, h = e.rawY, u = i.rawX, c = i.rawY, d = Il(l, h), f = Il(l, h + (c - h) * t.curvature), p = Il(u, c + (h - c) * t.curvature), g = Il(u, c);
            return {
                x1: d.x,
                y1: d.y,
                x2: g.x,
                y2: g.y,
                cpx1: f.x,
                cpy1: f.y,
                cpx2: p.x,
                cpy2: p.y
            };
        }
        l = e.x, h = e.y, u = i.x, c = i.y;
        return "LR" !== s && "RL" !== s || (n = l + (u - l) * t.curvature, a = h, o = u + (l - u) * t.curvature, 
        r = c), "TB" !== s && "BT" !== s || (n = l, a = h + (c - h) * t.curvature, o = u, 
        r = c + (h - c) * t.curvature), {
            x1: l,
            y1: h,
            x2: u,
            y2: c,
            cpx1: n,
            cpy1: a,
            cpx2: o,
            cpy2: r
        };
    }
    function Ol(t, e) {
        for (var i, n = [ t ]; i = n.pop(); ) if (e(i), i.isExpand) {
            var a = i.children;
            if (a.length) for (var o = a.length - 1; 0 <= o; o--) n.push(a[o]);
        }
    }
    function El(t, e, i) {
        if (t && 0 <= C(e, t.type)) {
            var n = i.getData().tree.root, a = t.targetNode;
            if (a && n.contains(a)) return {
                node: a
            };
            var o = t.targetNodeId;
            if (null != o && (a = n.getNodeById(o))) return {
                node: a
            };
        }
    }
    function Rl(t) {
        for (var e = []; t; ) (t = t.parentNode) && e.push(t);
        return e.reverse();
    }
    function zl(t, e) {
        return 0 <= C(Rl(t), e);
    }
    function Bl(t, e) {
        for (var i = []; t; ) {
            var n = t.dataIndex;
            i.push({
                name: t.name,
                dataIndex: n,
                value: e.getRawValue(n)
            }), t = t.parentNode;
        }
        return i.reverse(), i;
    }
    function Vl(t) {
        this.group = new Dg(), t.add(this.group);
    }
    function Gl(d, c, f, p, g, i, m, t, e, n) {
        function s(t, e) {
            x ? !t.invisible && i.push(t) : (e(), t.__tmWillVisible || (t.invisible = !1));
        }
        function l(t, e, i, n, a, o) {
            var r = m.getModel(), s = V(d.getFormattedLabel(m.dataIndex, "normal", null, null, o ? "upperLabel" : "label"), r.get("name"));
            if (!o && v.isLeafRoot) {
                var l = d.get("drillDownIcon", !0);
                s = l ? l + " " + s : s;
            }
            var h = r.getModel(o ? Ub : Hb), u = r.getModel(o ? jb : Zb), c = h.getShallow("show");
            mn(t, e, h, u, {
                defaultText: c ? s : null,
                autoColor: i,
                isRectText: !0
            }), o && (t.textRect = A(o)), t.truncate = c && h.get("ellipsis") ? {
                outerWidth: n,
                outerHeight: a,
                minChar: 2
            } : null;
        }
        function a(t, e, i, n) {
            var a, o, r, s, l, h = null != w && f[t][w], u = g[t];
            return h ? (f[t][w] = null, s = h, l = t, (u[_] = {}).old = "nodeGroup" === l ? s.position.slice() : P({}, s.shape)) : x || ((h = new e({
                z: (a = i, o = n, r = a * Xb + o, (r - 1) / r)
            })).__tmDepth = i, function(t, e, i) {
                var n = t[_] = {}, a = m.parentNode;
                if (a && (!p || "drillDown" === p.direction)) {
                    var o = 0, r = 0, s = g.background[a.getRawIndex()];
                    !p && s && s.old && (o = s.old.width, r = s.old.height), n.old = "nodeGroup" === i ? [ 0, r ] : {
                        x: o,
                        y: r,
                        width: 0,
                        height: 0
                    };
                }
                n.fadein = "nodeGroup" !== i;
            }(u, 0, h.__tmStorageName = t)), c[t][_] = h;
        }
        if (m) {
            var v = m.getLayout();
            if (v && v.isInView) {
                var h = v.width, u = v.height, y = v.borderWidth, x = v.invisible, _ = m.getRawIndex(), w = t && t.getRawIndex(), o = m.viewChildren, b = v.upperHeight, r = o && o.length, S = m.getModel("itemStyle"), M = m.getModel("emphasis.itemStyle"), I = a("nodeGroup", Gb);
                if (I) {
                    if (e.add(I), I.attr("position", [ v.x || 0, v.y || 0 ]), I.__tmNodeWidth = h, I.__tmNodeHeight = u, 
                    v.isAboveViewRoot) return I;
                    var T = a("background", Wb, n, 1);
                    if (T && function(t, n, a) {
                        n.dataIndex = m.dataIndex, n.seriesIndex = d.seriesIndex, n.setShape({
                            x: 0,
                            y: 0,
                            width: h,
                            height: u
                        });
                        var o = m.getVisual("borderColor", !0), r = M.get("borderColor");
                        s(n, function() {
                            var t = qb(S);
                            t.fill = o;
                            var e = Yb(M);
                            if (e.fill = r, a) {
                                var i = h - 2 * y;
                                l(t, e, o, i, b, {
                                    x: y,
                                    y: 0,
                                    width: i,
                                    height: b
                                });
                            } else t.text = e.text = null;
                            n.setStyle(t), gn(n, e);
                        }), t.add(n);
                    }(I, T, r && v.upperHeight), !r) {
                        var D = a("content", Wb, n, 2);
                        D && function(t, i) {
                            i.dataIndex = m.dataIndex, i.seriesIndex = d.seriesIndex;
                            var n = Math.max(h - 2 * y, 0), a = Math.max(u - 2 * y, 0);
                            i.culling = !0, i.setShape({
                                x: y,
                                y: y,
                                width: n,
                                height: a
                            });
                            var o = m.getVisual("color", !0);
                            s(i, function() {
                                var t = qb(S);
                                t.fill = o;
                                var e = Yb(M);
                                l(t, e, o, n, a), i.setStyle(t), gn(i, e);
                            }), t.add(i);
                        }(I, D);
                    }
                    return I;
                }
            }
        }
    }
    function Wl(t, e) {
        var i = t.visual, n = [];
        B(i) ? Jb(i, function(t) {
            n.push(t);
        }) : null != i && n.push(i), e || 1 !== n.length || {
            color: 1,
            symbol: 1
        }.hasOwnProperty(t.type) || (n[1] = n[0]), ql(t, n);
    }
    function Fl(n) {
        return {
            applyVisual: function(t, e, i) {
                t = this.mapValueToVisual(t), i("color", n(e("color"), t));
            },
            _doMap: Xl([ 0, 1 ])
        };
    }
    function Hl(t) {
        var e = this.option.visual;
        return e[Math.round(Rn(t, [ 0, 1 ], [ 0, e.length - 1 ], !0))] || {};
    }
    function Zl(n) {
        return function(t, e, i) {
            i(n, this.mapValueToVisual(t));
        };
    }
    function Ul(t) {
        var e = this.option.visual;
        return e[this.option.loop && t !== tS ? t % e.length : t];
    }
    function jl() {
        return this.option.visual[0];
    }
    function Xl(n) {
        return {
            linear: function(t) {
                return Rn(t, n, this.option.visual, !0);
            },
            category: Ul,
            piecewise: function(t, e) {
                var i = Yl.call(this, e);
                return null == i && (i = Rn(t, n, this.option.visual, !0)), i;
            },
            fixed: jl
        };
    }
    function Yl(t) {
        var e = this.option, i = e.pieceList;
        if (e.hasSpecialVisual) {
            var n = i[eS.findPieceIndex(t, i)];
            if (n && n.visual) return n.visual[this.type];
        }
    }
    function ql(t, e) {
        return t.visual = e, "color" === t.type && (t.parsedVisual = L(e, function(t) {
            return Tt(t);
        })), e;
    }
    function Kl(t, e, i) {
        return t ? e <= i : e < i;
    }
    function $l(t, e, i, n, a, o) {
        var r, s, l, h, u, c, d, f = t.getModel(), p = t.getLayout();
        if (p && !p.invisible && p.isInView) {
            var g, m = t.getModel(oS), v = (l = m, h = e, u = i[t.depth], c = n, d = P({}, h), 
            R([ "color", "colorAlpha", "colorSaturation" ], function(t) {
                var e = l.get(t, !0);
                null == e && u && (e = u[t]), null == e && (e = h[t]), null == e && (e = c.get(t)), 
                null != e && (d[t] = e);
            }), d), y = m.get("borderColor"), x = m.get("borderColorSaturation");
            null != x && (r = x, y = null != (s = g = Jl(v)) ? Pt(s, null, null, r) : null), 
            t.setVisual("borderColor", y);
            var _ = t.viewChildren;
            if (_ && _.length) {
                var w = function(t, e, i, n, a, o) {
                    if (o && o.length) {
                        var r = th(e, "color") || null != a.color && "none" !== a.color && (th(e, "colorAlpha") || th(e, "colorSaturation"));
                        if (r) {
                            var s = e.get("visualMin"), l = e.get("visualMax"), h = i.dataExtent.slice();
                            null != s && s < h[0] && (h[0] = s), null != l && l > h[1] && (h[1] = l);
                            var u = e.get("colorMappingBy"), c = {
                                type: r.name,
                                dataExtent: h,
                                visual: r.range
                            };
                            "color" !== c.type || "index" !== u && "id" !== u ? c.mappingMethod = "linear" : (c.mappingMethod = "category", 
                            c.loop = !0);
                            var d = new eS(c);
                            return d.__drColorMappingBy = u, d;
                        }
                    }
                }(0, f, p, 0, v, _);
                R(_, function(t, e) {
                    (t.depth >= a.length || t === a[t.depth]) && $l(t, function(t, e, i, n, a, o) {
                        var r = P({}, e);
                        if (a) {
                            var s = a.type, l = "color" === s && a.__drColorMappingBy, h = "index" === l ? n : "id" === l ? o.mapIdToIndex(i.getId()) : i.getValue(t.get("visualDimension"));
                            r[s] = a.mapValueToVisual(h);
                        }
                        return r;
                    }(f, v, t, e, w, o), i, n, a, o);
                });
            } else g = Jl(v), t.setVisual("color", g);
        }
    }
    function Jl(t) {
        var e = Ql(t, "color");
        if (e) {
            var i = Ql(t, "colorAlpha"), n = Ql(t, "colorSaturation");
            return n && (e = Pt(e, null, null, n)), i && (e = Nt(e, i)), e;
        }
    }
    function Ql(t, e) {
        var i = t[e];
        if (null != i && "none" !== i) return i;
    }
    function th(t, e) {
        var i = t.get(e);
        return aS(i) && i.length ? {
            name: e,
            range: i
        } : null;
    }
    function eh(t, e, i, n) {
        var a, o;
        if (!t.isRemoved()) {
            var r = t.getLayout();
            a = r.width, o = r.height;
            var s = (f = t.getModel()).get(cS), l = f.get(dS) / 2, h = ah(f), u = Math.max(s, h), c = s - l, d = u - l, f = t.getModel();
            t.setLayout({
                borderWidth: s,
                upperHeight: u,
                upperLabelHeight: h
            }, !0);
            var p = (a = sS(a - 2 * c, 0)) * (o = sS(o - c - d, 0)), g = function(t, e, i, n, a, o) {
                var r = t.children || [], s = n.sort;
                "asc" !== s && "desc" !== s && (s = null);
                var l = null != n.leafDepth && n.leafDepth <= o;
                if (a && !l) return t.viewChildren = [];
                h = r = I(r, function(t) {
                    return !t.isRemoved();
                }), u = s, u && h.sort(function(t, e) {
                    var i = "asc" === u ? t.getValue() - e.getValue() : e.getValue() - t.getValue();
                    return 0 === i ? "asc" === u ? t.dataIndex - e.dataIndex : e.dataIndex - t.dataIndex : i;
                });
                var h, u;
                var c = function(t, e, i) {
                    for (var n = 0, a = 0, o = e.length; a < o; a++) n += e[a].getValue();
                    var r = t.get("visualDimension");
                    if (e && e.length) if ("value" === r && i) s = [ e[e.length - 1].getValue(), e[0].getValue() ], 
                    "asc" === i && s.reverse(); else {
                        var s = [ 1 / 0, -1 / 0 ];
                        uS(e, function(t) {
                            var e = t.getValue(r);
                            e < s[0] && (s[0] = e), e > s[1] && (s[1] = e);
                        });
                    } else s = [ NaN, NaN ];
                    return {
                        sum: n,
                        dataExtent: s
                    };
                }(e, r, s);
                if (0 === c.sum) return t.viewChildren = [];
                if (c.sum = function(t, e, i, n, a) {
                    if (!n) return i;
                    for (var o = t.get("visibleMin"), r = a.length, s = r, l = r - 1; 0 <= l; l--) {
                        var h = a["asc" === n ? r - l - 1 : l].getValue();
                        h / i * e < o && (s = l, i -= h);
                    }
                    return "asc" === n ? a.splice(0, r - s) : a.splice(s, r - s), i;
                }(e, i, c.sum, s, r), 0 === c.sum) return t.viewChildren = [];
                for (var d = 0, f = r.length; d < f; d++) {
                    var p = r[d].getValue() / c.sum * i;
                    r[d].setLayout({
                        area: p
                    });
                }
                return l && (r.length && t.setLayout({
                    isLeafRoot: !0
                }, !0), r.length = 0), t.viewChildren = r, t.setLayout({
                    dataExtent: c.dataExtent
                }, !0), r;
            }(t, f, p, e, i, n);
            if (g.length) {
                for (var m = {
                    x: c,
                    y: d,
                    width: a,
                    height: o
                }, v = lS(a, o), y = 1 / 0, x = [], _ = x.area = 0, w = g.length; _ < w; ) {
                    var b = g[_];
                    x.push(b), x.area += b.getLayout().area;
                    var S = ih(x, v, e.squareRatio);
                    S <= y ? (_++, y = S) : (x.area -= x.pop().getLayout().area, nh(x, v, m, l, !1), 
                    v = lS(m.width, m.height), x.length = x.area = 0, y = 1 / 0);
                }
                if (x.length && nh(x, v, m, l, !0), !i) {
                    var M = f.get("childrenVisibleMin");
                    null != M && p < M && (i = !0);
                }
                for (_ = 0, w = g.length; _ < w; _++) eh(g[_], e, i, n + 1);
            }
        }
    }
    function ih(t, e, i) {
        for (var n, a = 0, o = 1 / 0, r = 0, s = t.length; r < s; r++) (n = t[r].getLayout().area) && (n < o && (o = n), 
        a < n && (a = n));
        var l = t.area * t.area, h = e * e * i;
        return l ? sS(h * a / l, l / (h * o)) : 1 / 0;
    }
    function nh(t, e, i, n, a) {
        var o = e === i.width ? 0 : 1, r = 1 - o, s = [ "x", "y" ], l = [ "width", "height" ], h = i[s[o]], u = e ? t.area / e : 0;
        (a || u > i[l[r]]) && (u = i[l[r]]);
        for (var c = 0, d = t.length; c < d; c++) {
            var f = t[c], p = {}, g = u ? f.getLayout().area / u : 0, m = p[l[r]] = sS(u - 2 * n, 0), v = i[s[o]] + i[l[o]] - h, y = c === d - 1 || v < g ? v : g, x = p[l[o]] = sS(y - 2 * n, 0);
            p[s[r]] = i[s[r]] + lS(n, m / 2), p[s[o]] = h + lS(n, x / 2), h += y, f.setLayout(p, !0);
        }
        i[s[r]] += u, i[l[r]] -= u;
    }
    function ah(t) {
        return t.get(fS) ? t.get(pS) : 0;
    }
    function oh(t) {
        return "_EC_" + t;
    }
    function rh(t, e) {
        this.id = null == t ? "" : t, this.inEdges = [], this.outEdges = [], this.edges = [], 
        this.hostGraph, this.dataIndex = null == e ? -1 : e;
    }
    function sh(t, e, i) {
        this.node1 = t, this.node2 = e, this.dataIndex = null == i ? -1 : i;
    }
    function lh(t) {
        return isNaN(+t.cpx1) || isNaN(+t.cpy1);
    }
    function hh(t) {
        return "_" + t + "Type";
    }
    function uh(t, e, i) {
        var n = e.getItemVisual(i, "color"), a = e.getItemVisual(i, t), o = e.getItemVisual(i, t + "Size");
        if (a && "none" !== a) {
            N(o) || (o = [ o, o ]);
            var r = Rr(a, -o[0] / 2, -o[1] / 2, o[0], o[1], n);
            return r.name = t, r;
        }
    }
    function ch(t, e) {
        var i = e[0], n = e[1], a = e[2];
        t.x1 = i[0], t.y1 = i[1], t.x2 = n[0], t.y2 = n[1], t.percent = 1, a ? (t.cpx1 = a[0], 
        t.cpy1 = a[1]) : (t.cpx1 = NaN, t.cpy1 = NaN);
    }
    function dh(t, e, i) {
        Dg.call(this), this._createLine(t, e, i);
    }
    function fh(t) {
        this._ctor = t || dh, this.group = new Dg();
    }
    function ph(t) {
        var e = t.hostModel;
        return {
            lineStyle: e.getModel("lineStyle").getLineStyle(),
            hoverLineStyle: e.getModel("emphasis.lineStyle").getLineStyle(),
            labelModel: e.getModel("label"),
            hoverLabelModel: e.getModel("emphasis.label")
        };
    }
    function gh(t) {
        return isNaN(t[0]) || isNaN(t[1]);
    }
    function mh(t) {
        return !gh(t[0]) && !gh(t[1]);
    }
    function vh(t, e, i) {
        for (var n, a = t[0], o = t[1], r = t[2], s = 1 / 0, l = i * i, h = .1, u = .1; u <= .9; u += .1) DS[0] = LS(a[0], o[0], r[0], u), 
        DS[1] = LS(a[1], o[1], r[1], u), (f = PS(kS(DS, e) - l)) < s && (s = f, n = u);
        for (var c = 0; c < 32; c++) {
            var d = n + h;
            AS[0] = LS(a[0], o[0], r[0], n), AS[1] = LS(a[1], o[1], r[1], n), CS[0] = LS(a[0], o[0], r[0], d), 
            CS[1] = LS(a[1], o[1], r[1], d);
            var f = kS(AS, e) - l;
            if (PS(f) < .01) break;
            var p = kS(CS, e) - l;
            h /= 2, f < 0 ? 0 <= p ? n += h : n -= h : 0 <= p ? n -= h : n += h;
        }
        return n;
    }
    function yh(t, e) {
        return t.getVisual("opacity") || t.getModel().get(e);
    }
    function xh(t, e, i) {
        var n = t.getGraphicEl(), a = yh(t, e);
        null != i && (null == a && (a = 1), a *= i), n.downplay && n.downplay(), n.traverse(function(t) {
            "group" !== t.type && t.setStyle("opacity", a);
        });
    }
    function _h(t, e) {
        var i = yh(t, e), n = t.getGraphicEl();
        n.highlight && n.highlight(), n.traverse(function(t) {
            "group" !== t.type && t.setStyle("opacity", i);
        });
    }
    function wh(t) {
        return t instanceof Array || (t = [ t, t ]), t;
    }
    function bh(t) {
        var e = t.coordinateSystem;
        if (!e || "view" === e.type) {
            var i = t.getGraph();
            i.eachNode(function(t) {
                var e = t.getModel();
                t.setLayout([ +e.get("x"), +e.get("y") ]);
            }), Sh(i);
        }
    }
    function Sh(t) {
        t.eachEdge(function(t) {
            var e = t.getModel().get("lineStyle.curveness") || 0, i = D(t.node1.getLayout()), n = D(t.node2.getLayout()), a = [ i, n ];
            +e && a.push([ (i[0] + n[0]) / 2 - (i[1] - n[1]) * e, (i[1] + n[1]) / 2 - (n[0] - i[0]) * e ]), 
            t.setLayout(a);
        });
    }
    function Mh(t) {
        var e = t.coordinateSystem;
        if (!e || "view" === e.type) {
            var i = e.getBoundingRect(), n = t.getData(), a = n.graph, o = 0, r = n.getSum("value"), s = 2 * Math.PI / (r || n.count()), l = i.width / 2 + i.x, h = i.height / 2 + i.y, u = Math.min(i.width, i.height) / 2;
            a.eachNode(function(t) {
                var e = t.getValue("value");
                o += s * (r ? e : 1) / 2, t.setLayout([ u * Math.cos(o) + l, u * Math.sin(o) + h ]), 
                o += s * (r ? e : 1) / 2;
            }), n.setLayout({
                cx: l,
                cy: h
            }), a.eachEdge(function(t) {
                var e, i = t.getModel().get("lineStyle.curveness") || 0, n = D(t.node1.getLayout()), a = D(t.node2.getLayout()), o = (n[0] + a[0]) / 2, r = (n[1] + a[1]) / 2;
                +i && (e = [ l * (i *= 3) + o * (1 - i), h * i + r * (1 - i) ]), t.setLayout([ n, a, e ]);
            });
        }
    }
    function Ih(t, e) {
        return e && ("string" == typeof e ? t = e.replace("{value}", null != t ? t : "") : "function" == typeof e && (t = e(t))), 
        t;
    }
    function Th(t, e) {
        function i() {
            o.ignore = o.hoverIgnore, r.ignore = r.hoverIgnore;
        }
        function n() {
            o.ignore = o.normalIgnore, r.ignore = r.normalIgnore;
        }
        Dg.call(this);
        var a = new Vv(), o = new Gv(), r = new Nv();
        this.add(a), this.add(o), this.add(r), this.updateData(t, e, !0), this.on("emphasis", i).on("normal", n).on("mouseover", i).on("mouseout", n);
    }
    function Dh(t, e) {
        var i = t[e] - t[1 - e];
        return {
            span: Math.abs(i),
            sign: 0 < i ? -1 : i < 0 ? 1 : e ? -1 : 1
        };
    }
    function Ah(t, e) {
        return Math.min(e[1], Math.max(e[0], t));
    }
    function Ch(t, e, i) {
        this._axesMap = W(), this._axesLayout = {}, this.dimensions = t.dimensions, this._rect, 
        this._model = t, this._init(t, e, i);
    }
    function Lh(t, e) {
        return US(jS(t, e[0]), e[1]);
    }
    function kh(t) {
        Up.call(this), this._zr = t, this.group = new Dg(), this._brushType, this._brushOption, 
        this._panels, this._track = [], this._dragging, this._covers = [], this._creatingCover, 
        this._creatingPanel, this._enableGlobalPan, this._uid = "brushController_" + cM++, 
        this._handlers = {}, QS(dM, function(t, e) {
            this._handlers[e] = _(t, this);
        }, this);
    }
    function Ph(t, e) {
        var i, n, a, o = t._zr;
        t._enableGlobalPan || (i = o, n = sM, a = t._uid, Js(i)[n] = a), QS(t._handlers, function(t, e) {
            o.on(e, t);
        }), t._brushType = e.brushType, t._brushOption = g(A(uM), e, !0);
    }
    function Nh(t) {
        var e, i, n, a, o = t._zr;
        e = o, i = sM, n = t._uid, (a = Js(e))[i] === n && (a[i] = null), QS(t._handlers, function(t, e) {
            o.off(e, t);
        }), t._brushType = t._brushOption = null;
    }
    function Oh(t, e) {
        var i = fM[e.brushType].createCover(t, e);
        return i.__brushOption = e, zh(i, e), t.group.add(i), i;
    }
    function Eh(t, e) {
        var i = Vh(e);
        return i.endCreating && (i.endCreating(t, e), zh(e, e.__brushOption)), e;
    }
    function Rh(t, e) {
        var i = e.__brushOption;
        Vh(e).updateCoverShape(t, e, i.range, i);
    }
    function zh(t, e) {
        var i = e.z;
        null == i && (i = aM), t.traverse(function(t) {
            t.z = i, t.z2 = i;
        });
    }
    function Bh(t, e) {
        Vh(e).updateCommon(t, e), Rh(t, e);
    }
    function Vh(t) {
        return fM[t.__brushOption.brushType];
    }
    function Gh(t, e, i) {
        var n = t._panels;
        if (!n) return !0;
        var a, o = t._transform;
        return QS(n, function(t) {
            t.isTargetByCursor(e, i, o) && (a = t);
        }), a;
    }
    function Wh(t, e) {
        var i = t._panels;
        if (!i) return !0;
        var n = e.__brushOption.panelId;
        return null == n || i[n];
    }
    function Fh(e) {
        var t = e._covers, i = t.length;
        return QS(t, function(t) {
            e.group.remove(t);
        }, e), t.length = 0, !!i;
    }
    function Hh(t, e) {
        var i = tM(t._covers, function(t) {
            var e = t.__brushOption, i = A(e.range);
            return {
                brushType: e.brushType,
                panelId: e.panelId,
                range: i
            };
        });
        t.trigger("brush", i, {
            isEnd: !!e.isEnd,
            removeOnClick: !!e.removeOnClick
        });
    }
    function Zh(t) {
        var e = t.length - 1;
        return e < 0 && (e = 0), [ t[0], t[e] ];
    }
    function Uh(e, i, t, n) {
        var a = new Dg();
        return a.add(new Wv({
            name: "main",
            style: qh(t),
            silent: !0,
            draggable: !0,
            cursor: "move",
            drift: JS(e, i, a, "nswe"),
            ondragend: JS(Hh, i, {
                isEnd: !0
            })
        })), QS(n, function(t) {
            a.add(new Wv({
                name: t,
                style: {
                    opacity: 0
                },
                draggable: !0,
                silent: !0,
                invisible: !0,
                drift: JS(e, i, a, t),
                ondragend: JS(Hh, i, {
                    isEnd: !0
                })
            }));
        }), a;
    }
    function jh(t, e, i, n) {
        var a = n.brushStyle.lineWidth || 0, o = iM(a, rM), r = i[0][0], s = i[1][0], l = r - a / 2, h = s - a / 2, u = i[0][1], c = i[1][1], d = u - o + a / 2, f = c - o + a / 2, p = u - r, g = c - s, m = p + a, v = g + a;
        Yh(t, e, "main", r, s, p, g), n.transformable && (Yh(t, e, "w", l, h, o, v), Yh(t, e, "e", d, h, o, v), 
        Yh(t, e, "n", l, h, m, o), Yh(t, e, "s", l, f, m, o), Yh(t, e, "nw", l, h, o, o), 
        Yh(t, e, "ne", d, h, o, o), Yh(t, e, "sw", l, f, o, o), Yh(t, e, "se", d, f, o, o));
    }
    function Xh(n, a) {
        var t = a.__brushOption, o = t.transformable, e = a.childAt(0);
        e.useStyle(qh(t)), e.attr({
            silent: !o,
            cursor: o ? "move" : "default"
        }), QS([ "w", "e", "n", "s", "se", "sw", "ne", "nw" ], function(t) {
            var e = a.childOfName(t), i = function t(e, i) {
                if (1 < i.length) return ("e" === (n = [ t(e, (i = i.split(""))[0]), t(e, i[1]) ])[0] || "w" === n[0]) && n.reverse(), 
                n.join("");
                var n = An({
                    w: "left",
                    e: "right",
                    n: "top",
                    s: "bottom"
                }[i], (a = e, Tn(a.group)));
                var a;
                return {
                    left: "w",
                    right: "e",
                    top: "n",
                    bottom: "s"
                }[n];
            }(n, t);
            e && e.attr({
                silent: !o,
                invisible: !o,
                cursor: o ? hM[i] + "-resize" : null
            });
        });
    }
    function Yh(t, e, i, n, a, o, r) {
        var s, l, h, u = e.childOfName(i);
        u && u.setShape((s = tu(t, e, [ [ n, a ], [ n + o, a + r ] ]), l = eM(s[0][0], s[1][0]), 
        h = eM(s[0][1], s[1][1]), {
            x: l,
            y: h,
            width: iM(s[0][0], s[1][0]) - l,
            height: iM(s[0][1], s[1][1]) - h
        }));
    }
    function qh(t) {
        return E({
            strokeNoScale: !0
        }, t.brushStyle);
    }
    function Kh(t, e, i, n) {
        var a = [ eM(t, i), eM(e, n) ], o = [ iM(t, i), iM(e, n) ];
        return [ [ a[0], o[0] ], [ a[1], o[1] ] ];
    }
    function $h(t, e, i, n, a, o, r, s) {
        var l = n.__brushOption, h = t(l.range), u = Qh(i, o, r);
        QS(a.split(""), function(t) {
            var e = lM[t];
            h[e[0]][e[1]] += u[e[0]];
        }), l.range = e(Kh(h[0][0], h[1][0], h[0][1], h[1][1])), Bh(i, n), Hh(i, {
            isEnd: !1
        });
    }
    function Jh(t, e, i, n, a) {
        var o = e.__brushOption.range, r = Qh(t, i, n);
        QS(o, function(t) {
            t[0] += r[0], t[1] += r[1];
        }), Bh(t, e), Hh(t, {
            isEnd: !1
        });
    }
    function Qh(t, e, i) {
        var n = t.group, a = n.transformCoordToLocal(e, i), o = n.transformCoordToLocal(0, 0);
        return [ a[0] - o[0], a[1] - o[1] ];
    }
    function tu(t, e, i) {
        var n = Wh(t, e);
        return n && !0 !== n ? n.clipPath(i, t._transform) : A(i);
    }
    function eu(t) {
        var e = t.event;
        e.preventDefault && e.preventDefault();
    }
    function iu(t, e, i) {
        return t.childOfName("main").contain(e, i);
    }
    function nu(t, e, i, n) {
        var a, o = t._creatingCover, r = t._creatingPanel, s = t._brushOption;
        if (t._track.push(i.slice()), function(t) {
            var e = t._track;
            if (!e.length) return !1;
            var i = e[e.length - 1], n = e[0], a = i[0] - n[0], o = i[1] - n[1];
            return nM(a * a + o * o, .5) > oM;
        }(t) || o) {
            if (r && !o) {
                "single" === s.brushMode && Fh(t);
                var l = A(s);
                l.brushType = au(l.brushType, r), l.panelId = !0 === r ? null : r.panelId, o = t._creatingCover = Oh(t, l), 
                t._covers.push(o);
            }
            if (o) {
                var h = fM[au(t._brushType, r)];
                o.__brushOption.range = h.getCreatingRange(tu(t, o, t._track)), n && (Eh(t, o), 
                h.updateCommon(t, o)), Rh(t, o), a = {
                    isEnd: n
                };
            }
        } else n && "single" === s.brushMode && s.removeOnClick && Gh(t, e, i) && Fh(t) && (a = {
            isEnd: n,
            removeOnClick: !0
        });
        return a;
    }
    function au(t, e) {
        return "auto" === t ? e.defaultBrushType : t;
    }
    function ou(t) {
        if (this._dragging) {
            eu(t);
            var e = nu(this, t, this.group.transformCoordToLocal(t.offsetX, t.offsetY), !0);
            this._dragging = !1, this._track = [], this._creatingCover = null, e && Hh(this, e);
        }
    }
    function ru(l) {
        return {
            createCover: function(t, e) {
                return Uh(JS($h, function(t) {
                    var e = [ t, [ 0, 100 ] ];
                    return l && e.reverse(), e;
                }, function(t) {
                    return t[l];
                }), t, e, [ [ "w", "e" ], [ "n", "s" ] ][l]);
            },
            getCreatingRange: function(t) {
                var e = Zh(t);
                return [ eM(e[0][l], e[1][l]), iM(e[0][l], e[1][l]) ];
            },
            updateCoverShape: function(t, e, i, n) {
                var a, o = Wh(t, e);
                if (!0 !== o && o.getLinearBrushOtherExtent) a = o.getLinearBrushOtherExtent(l, t._transform); else {
                    var r = t._zr;
                    a = [ 0, [ r.getWidth(), r.getHeight() ][1 - l] ];
                }
                var s = [ i, a ];
                l && s.reverse(), jh(t, e, s, n);
            },
            updateCommon: Xh,
            contain: iu
        };
    }
    function su(i) {
        return i = uu(i), function(t, e) {
            return Ln(t, i);
        };
    }
    function lu(a, o) {
        return a = uu(a), function(t) {
            var e = null != o ? o : t, i = e ? a.width : a.height, n = e ? a.x : a.y;
            return [ n, n + (i || 0) ];
        };
    }
    function hu(n, a, o) {
        return n = uu(n), function(t, e, i) {
            return n.contain(e[0], e[1]) && !hl(t, a, o);
        };
    }
    function uu(t) {
        return Xt.create(t);
    }
    function cu(t, e) {
        var i = t._model;
        return i.get("axisExpandable") && i.get("axisExpandTriggerOn") === e;
    }
    function du(t, e, i, n) {
        for (var a = [], o = 0; o < i.length; o++) {
            var r = i[o], s = t.get(t.mapDimension(r), e);
            l = s, ("category" === n.getAxis(r).type ? null == l : null == l || isNaN(l)) || a.push(n.dataToPoint(s, r));
        }
        var l;
        return a;
    }
    function fu() {
        var u = [], e = [];
        return {
            key: function(t) {
                return u.push(t), this;
            },
            sortKeys: function(t) {
                return e[u.length - 1] = t, this;
            },
            entries: function(t) {
                return function i(t, n) {
                    if (n >= u.length) return t;
                    var a = [], o = e[n++];
                    return R(t, function(t, e) {
                        a.push({
                            key: e,
                            values: i(t, n)
                        });
                    }), o ? a.sort(function(t, e) {
                        return o(t.key, e.key);
                    }) : a;
                }(function i(t, n) {
                    if (n >= u.length) return t;
                    for (var e = -1, a = t.length, o = u[n++], r = {}, s = {}; ++e < a; ) {
                        var l = o(t[e]), h = s[l];
                        h ? h.push(t[e]) : s[l] = [ t[e] ];
                    }
                    return R(s, function(t, e) {
                        r[e] = i(t, n);
                    }), r;
                }(t, 0), 0);
            }
        };
    }
    function pu(t, e, i, n, a, o, r) {
        var s;
        (function(t, e, i) {
            for (var n = t, a = null, o = 0; n.length; ) {
                a = [];
                for (var r = 0, s = n.length; r < s; r++) {
                    var l = n[r];
                    l.setLayout({
                        x: o
                    }, !0), l.setLayout({
                        dx: e
                    }, !0);
                    for (var h = 0, u = l.outEdges.length; h < u; h++) a.push(l.outEdges[h].node2);
                }
                n = a, ++o;
            }
            f = t, p = o, R(f, function(t) {
                t.outEdges.length || t.setLayout({
                    x: p - 1
                }, !0);
            }), c = t, d = (i - e) / (o - 1), R(c, function(t) {
                var e = t.getLayout().x * d;
                t.setLayout({
                    x: e
                }, !0);
            });
            var c, d;
            var f, p;
        })(t, i, a), function(t, e, i, n, a) {
            var o = fu().key(function(t) {
                return t.getLayout().x;
            }).sortKeys(Iu).entries(t).map(function(t) {
                return t.values;
            });
            (function(t, e, i, a, o) {
                var r = [];
                R(e, function(t) {
                    var e = t.length, i = 0;
                    R(t, function(t) {
                        i += t.getLayout().value;
                    });
                    var n = (a - (e - 1) * o) / i;
                    r.push(n);
                }), r.sort(function(t, e) {
                    return t - e;
                });
                var n = r[0];
                R(e, function(t) {
                    R(t, function(t, e) {
                        t.setLayout({
                            y: e
                        }, !0);
                        var i = t.getLayout().value * n;
                        t.setLayout({
                            dy: i
                        }, !0);
                    });
                }), R(i, function(t) {
                    var e = +t.getValue() * n;
                    t.setLayout({
                        dy: e
                    }, !0);
                });
            })(0, o, e, i, n), gu(o, n, i);
            for (var r = 1; 0 < a; a--) mu(o, r *= .99), gu(o, n, i), yu(o, r), gu(o, n, i);
        }(t, e, o, n, r), R(s = t, function(t) {
            t.outEdges.sort(_u), t.inEdges.sort(wu);
        }), R(s, function(t) {
            var e = 0, i = 0;
            R(t.outEdges, function(t) {
                t.setLayout({
                    sy: e
                }, !0), e += t.getLayout().dy;
            }), R(t.inEdges, function(t) {
                t.setLayout({
                    ty: i
                }, !0), i += t.getLayout().dy;
            });
        });
    }
    function gu(t, s, l) {
        R(t, function(t) {
            var e, i, n, a = 0, o = t.length;
            for (t.sort(Mu), n = 0; n < o; n++) 0 < (i = a - (e = t[n]).getLayout().y) && (r = e.getLayout().y + i, 
            e.setLayout({
                y: r
            }, !0)), a = e.getLayout().y + e.getLayout().dy + s;
            if (0 < (i = a - s - l)) {
                var r = e.getLayout().y - i;
                for (e.setLayout({
                    y: r
                }, !0), a = e.getLayout().y, n = o - 2; 0 <= n; --n) 0 < (i = (e = t[n]).getLayout().y + e.getLayout().dy + s - a) && (r = e.getLayout().y - i, 
                e.setLayout({
                    y: r
                }, !0)), a = e.getLayout().y;
            }
        });
    }
    function mu(t, n) {
        R(t.slice().reverse(), function(t) {
            R(t, function(t) {
                if (t.outEdges.length) {
                    var e = bu(t.outEdges, vu) / bu(t.outEdges, Tu), i = t.getLayout().y + (e - Su(t)) * n;
                    t.setLayout({
                        y: i
                    }, !0);
                }
            });
        });
    }
    function vu(t) {
        return Su(t.node2) * t.getValue();
    }
    function yu(t, n) {
        R(t, function(t) {
            R(t, function(t) {
                if (t.inEdges.length) {
                    var e = bu(t.inEdges, xu) / bu(t.inEdges, Tu), i = t.getLayout().y + (e - Su(t)) * n;
                    t.setLayout({
                        y: i
                    }, !0);
                }
            });
        });
    }
    function xu(t) {
        return Su(t.node1) * t.getValue();
    }
    function _u(t, e) {
        return t.node2.getLayout().y - e.node2.getLayout().y;
    }
    function wu(t, e) {
        return t.node1.getLayout().y - e.node1.getLayout().y;
    }
    function bu(t, e) {
        for (var i = 0, n = t.length, a = -1; ++a < n; ) {
            var o = +e.call(t, t[a], a);
            isNaN(o) || (i += o);
        }
        return i;
    }
    function Su(t) {
        return t.getLayout().y + t.getLayout().dy / 2;
    }
    function Mu(t, e) {
        return t.getLayout().y - e.getLayout().y;
    }
    function Iu(t, e) {
        return t < e ? -1 : e < t ? 1 : t === e ? 0 : NaN;
    }
    function Tu(t) {
        return t.getValue();
    }
    function Du(t, e, i, n) {
        Dg.call(this), this.bodyIndex, this.whiskerIndex, this.styleUpdater = i, this._createContent(t, e, n), 
        this.updateData(t, e, n), this._seriesModel;
    }
    function Au(t, e, i) {
        return L(t, function(t) {
            return (t = t.slice())[e] = i.initBaseline, t;
        });
    }
    function Cu(t) {
        var i = {};
        return R(t, function(t, e) {
            i["ends" + e] = t;
        }), i;
    }
    function Lu(t) {
        this.group = new Dg(), this.styleUpdater = t;
    }
    function ku(t, e, i) {
        var n = e.getItemModel(i), a = n.getModel(IM), o = e.getItemVisual(i, "color"), r = a.getItemStyle([ "borderColor" ]), s = t.childAt(t.whiskerIndex);
        s.style.set(r), s.style.stroke = o, s.dirty();
        var l = t.childAt(t.bodyIndex);
        l.style.set(r), l.style.stroke = o, l.dirty(), gn(t, n.getModel(TM).getItemStyle());
    }
    function Pu(t, e, i) {
        var n = e.getItemModel(i), a = n.getModel(CM), o = e.getItemVisual(i, "color"), r = e.getItemVisual(i, "borderColor") || o, s = a.getItemStyle([ "color", "color0", "borderColor", "borderColor0" ]), l = t.childAt(t.whiskerIndex);
        l.useStyle(s), l.style.stroke = r;
        var h = t.childAt(t.bodyIndex);
        h.useStyle(s), h.style.fill = o, h.style.stroke = r, gn(t, n.getModel(LM).getItemStyle());
    }
    function Nu(t, e) {
        t.eachChild(function(t) {
            t.attr({
                z: e.z,
                zlevel: e.zlevel,
                style: {
                    stroke: "stroke" === e.brushType ? e.color : null,
                    fill: "fill" === e.brushType ? e.color : null
                }
            });
        });
    }
    function Ou(t, e) {
        Dg.call(this);
        var i = new Zr(t, e), n = new Dg();
        this.add(i), this.add(n), n.beforeUpdate = function() {
            this.attr(i.getScale());
        }, this.updateData(t, e);
    }
    function Eu(t) {
        var e = t.data;
        e && e[0] && e[0][0] && e[0][0].coord && (t.data = L(e, function(t) {
            var e = {
                coords: [ t[0].coord, t[1].coord ]
            };
            return t[0].name && (e.fromName = t[0].name), t[1].name && (e.toName = t[1].name), 
            u([ e, t[0], t[1] ]);
        }));
    }
    function Ru(t, e, i) {
        Dg.call(this), this.add(this.createLine(t, e, i)), this._updateEffectSymbol(t, e);
    }
    function zu(t, e, i) {
        Dg.call(this), this._createPolyline(t, e, i);
    }
    function Bu(t, e, i) {
        Ru.call(this, t, e, i), this._lastFrame = 0, this._lastFramePercent = 0;
    }
    function Vu() {
        this.group = new Dg();
    }
    function Gu(t) {
        return t instanceof Array || (t = [ t, t ]), t;
    }
    function Wu() {
        var t = Op();
        this.canvas = t, this.blurSize = 30, this.pointSize = 20, this.maxOpacity = 1, this.minOpacity = 0, 
        this._gradientPixels = {};
    }
    function Fu(t, e, i, n) {
        var a, o, r, s, l, h, u, c, d, f, p, g, m, v, y, x, _, w, b = t.getItemLayout(e), S = i.get("symbolRepeat"), M = i.get("symbolClip"), I = i.get("symbolPosition") || "start", T = (i.get("symbolRotate") || 0) * Math.PI / 180 || 0, D = i.get("symbolPatternSize") || 2, A = i.isAnimationEnabled(), C = {
            dataIndex: e,
            layout: b,
            itemModel: i,
            symbolType: t.getItemVisual(e, "symbol") || "circle",
            color: t.getItemVisual(e, "color"),
            symbolClip: M,
            symbolRepeat: S,
            symbolRepeatDirection: i.get("symbolRepeatDirection"),
            symbolPatternSize: D,
            rotation: T,
            animationModel: A ? i : null,
            hoverAnimation: A && i.get("hoverAnimation"),
            z2: i.getShallow("z", !0) || 0
        };
        (function(t, e, i, n, a) {
            var o, r = n.valueDim, s = t.get("symbolBoundingData"), l = n.coordSys.getOtherAxis(n.coordSys.getBaseAxis()), h = l.toGlobalCoord(l.dataToCoord(0)), u = 1 - +(i[r.wh] <= 0);
            if (N(s)) {
                var c = [ Hu(l, s[0]) - h, Hu(l, s[1]) - h ];
                c[1] < c[0] && c.reverse(), o = c[u];
            } else o = null != s ? Hu(l, s) - h : e ? n.coordSysExtent[r.index][u] - h : i[r.wh];
            a.boundingLength = o, e && (a.repeatCutLength = i[r.wh]), a.pxSign = 0 < o ? 1 : o < 0 ? -1 : 0;
        })(i, S, b, n, C), h = t, u = e, c = b, d = S, f = C.boundingLength, p = C.pxSign, 
        g = D, v = C, y = (m = n).valueDim, x = m.categoryDim, _ = Math.abs(c[x.wh]), N(w = h.getItemVisual(u, "symbolSize")) ? w = w.slice() : (null == w && (w = "100%"), 
        w = [ w, w ]), w[x.index] = zn(w[x.index], _), w[y.index] = zn(w[y.index], d ? _ : Math.abs(f)), 
        v.symbolSize = w, (v.symbolScale = [ w[0] / g, w[1] / g ])[y.index] *= (m.isHorizontal ? -1 : 1) * p, 
        a = C.symbolScale, o = T, r = n, s = C, (l = i.get(KM) || 0) && (JM.attr({
            scale: a.slice(),
            rotation: o
        }), JM.updateTransform(), l /= JM.getLineScale(), l *= a[r.valueDim.index]), s.valueLineWidth = l;
        var L = C.symbolSize, k = i.get("symbolOffset");
        return N(k) && (k = [ zn(k[0], L[0]), zn(k[1], L[1]) ]), function(t, e, i, n, a, o, r, s, l, h, u, c) {
            var d = u.categoryDim, f = u.valueDim, p = c.pxSign, g = Math.max(e[f.index] + s, 0), m = g;
            if (n) {
                var v = Math.abs(l), y = V(t.get("symbolMargin"), "15%") + "", x = !1;
                y.lastIndexOf("!") === y.length - 1 && (x = !0, y = y.slice(0, y.length - 1)), y = zn(y, e[f.index]);
                var _ = Math.max(g + 2 * y, 0), w = x ? 0 : 2 * y, b = $n(n), S = b ? n : oc((v + w) / _);
                _ = g + 2 * (y = (v - S * g) / 2 / (x ? S : S - 1)), w = x ? 0 : 2 * y, b || "fixed" === n || (S = h ? oc((Math.abs(h) + w) / _) : 0), 
                m = S * _ - w, c.repeatTimes = S, c.symbolMargin = y;
            }
            var M = p * (m / 2), I = c.pathPosition = [];
            I[d.index] = i[d.wh] / 2, I[f.index] = "start" === r ? M : "end" === r ? l - M : l / 2, 
            o && (I[0] += o[0], I[1] += o[1]);
            var T = c.bundlePosition = [];
            T[d.index] = i[d.xy], T[f.index] = i[f.xy];
            var D = c.barRectShape = P({}, i);
            D[f.wh] = p * Math.max(Math.abs(i[f.wh]), Math.abs(I[f.index] + M)), D[d.wh] = i[d.wh];
            var A = c.clipShape = {};
            A[d.xy] = -i[d.xy], A[d.wh] = u.ecSize[d.wh], A[f.xy] = 0, A[f.wh] = i[f.wh];
        }(i, L, b, S, 0, k, I, C.valueLineWidth, C.boundingLength, C.repeatCutLength, n, C), 
        C;
    }
    function Hu(t, e) {
        return t.toGlobalCoord(t.dataToCoord(t.scale.parse(e)));
    }
    function Zu(t) {
        var e = t.symbolPatternSize, i = Rr(t.symbolType, -e / 2, -e / 2, e, e, t.color);
        return i.attr({
            culling: !0
        }), "image" !== i.type && i.setStyle({
            strokeNoScale: !0
        }), i;
    }
    function Uu(t, e, a, i) {
        function n(t) {
            var e = l.slice(), i = a.pxSign, n = t;
            return ("start" === a.symbolRepeatDirection ? 0 < i : i < 0) && (n = u - 1 - t), 
            e[h.index] = d * (n - u / 2 + .5) + l[h.index], {
                position: e,
                scale: a.symbolScale.slice(),
                rotation: a.rotation
            };
        }
        var o = t.__pictorialBundle, r = a.symbolSize, s = a.valueLineWidth, l = a.pathPosition, h = e.valueDim, u = a.repeatTimes || 0, c = 0, d = r[e.valueDim.index] + s + 2 * a.symbolMargin;
        for (ic(t, function(t) {
            t.__pictorialAnimationIndex = c, t.__pictorialRepeatTimes = u, c < u ? nc(t, null, n(c), a, i) : nc(t, null, {
                scale: [ 0, 0 ]
            }, a, i, function() {
                o.remove(t);
            }), Ju(t, a), c++;
        }); c < u; c++) {
            var f = Zu(a);
            f.__pictorialAnimationIndex = c, f.__pictorialRepeatTimes = u, o.add(f);
            var p = n(c);
            nc(f, {
                position: p.position,
                scale: [ 0, 0 ]
            }, {
                scale: p.scale,
                rotation: p.rotation
            }, a, i), f.on("mouseover", function() {
                ic(t, function(t) {
                    t.trigger("emphasis");
                });
            }).on("mouseout", function() {
                ic(t, function(t) {
                    t.trigger("normal");
                });
            }), Ju(f, a);
        }
    }
    function ju(t, e, i, n) {
        var a = t.__pictorialBundle, o = t.__pictorialMainPath;
        o ? nc(o, null, {
            position: i.pathPosition.slice(),
            scale: i.symbolScale.slice(),
            rotation: i.rotation
        }, i, n) : (o = t.__pictorialMainPath = Zu(i), a.add(o), nc(o, {
            position: i.pathPosition.slice(),
            scale: [ 0, 0 ],
            rotation: i.rotation
        }, {
            scale: i.symbolScale.slice()
        }, i, n), o.on("mouseover", function() {
            this.trigger("emphasis");
        }).on("mouseout", function() {
            this.trigger("normal");
        })), Ju(o, i);
    }
    function Xu(t, e, i) {
        var n = P({}, e.barRectShape), a = t.__pictorialBarRect;
        a ? nc(a, null, {
            shape: n
        }, e, i) : (a = t.__pictorialBarRect = new Wv({
            z2: 2,
            shape: n,
            silent: !0,
            style: {
                stroke: "transparent",
                fill: "transparent",
                lineWidth: 0
            }
        }), t.add(a));
    }
    function Yu(t, e, i, n) {
        if (i.symbolClip) {
            var a = t.__pictorialClipPath, o = P({}, i.clipShape), r = e.valueDim, s = i.animationModel, l = i.dataIndex;
            if (a) Mn(a, {
                shape: o
            }, s, l); else {
                o[r.wh] = 0, a = new Wv({
                    shape: o
                }), t.__pictorialBundle.setClipPath(a), t.__pictorialClipPath = a;
                var h = {};
                h[r.wh] = i.clipShape[r.wh], iy[n ? "updateProps" : "initProps"](a, {
                    shape: h
                }, s, l);
            }
        }
    }
    function qu(t, e) {
        var i = t.getItemModel(e);
        return i.getAnimationDelayParams = Ku, i.isAnimationEnabled = $u, i;
    }
    function Ku(t) {
        return {
            index: t.__pictorialAnimationIndex,
            count: t.__pictorialRepeatTimes
        };
    }
    function $u() {
        return this.parentModel.isAnimationEnabled() && !!this.getShallow("animation");
    }
    function Ju(t, e) {
        t.off("emphasis").off("normal");
        var i = e.symbolScale.slice();
        e.hoverAnimation && t.on("emphasis", function() {
            this.animateTo({
                scale: [ 1.1 * i[0], 1.1 * i[1] ]
            }, 400, "elasticOut");
        }).on("normal", function() {
            this.animateTo({
                scale: i.slice()
            }, 400, "elasticOut");
        });
    }
    function Qu(t, e, i, n) {
        var a = new Dg(), o = new Dg();
        return a.add(o), (a.__pictorialBundle = o).attr("position", i.bundlePosition.slice()), 
        i.symbolRepeat ? Uu(a, e, i) : ju(a, 0, i), Xu(a, i, n), Yu(a, e, i, n), a.__pictorialShapeStr = ec(t, i), 
        a.__pictorialSymbolMeta = i, a;
    }
    function tc(t, e, i, n) {
        var a = n.__pictorialBarRect;
        a && (a.style.text = null);
        var o = [];
        ic(n, function(t) {
            o.push(t);
        }), n.__pictorialMainPath && o.push(n.__pictorialMainPath), n.__pictorialClipPath && (i = null), 
        R(o, function(t) {
            Mn(t, {
                scale: [ 0, 0 ]
            }, i, e, function() {
                n.parent && n.parent.remove(n);
            });
        }), t.setItemGraphicEl(e, null);
    }
    function ec(t, e) {
        return [ t.getItemVisual(e.dataIndex, "symbol") || "none", !!e.symbolRepeat, !!e.symbolClip ].join(":");
    }
    function ic(e, i, n) {
        R(e.__pictorialBundle.children(), function(t) {
            t !== e.__pictorialBarRect && i.call(n, t);
        });
    }
    function nc(t, e, i, n, a, o) {
        e && t.attr(e), n.symbolClip && !a ? i && t.attr(i) : i && iy[a ? "updateProps" : "initProps"](t, i, n.animationModel, n.dataIndex, o);
    }
    function ac(t, e, i) {
        var n = i.color, a = i.dataIndex, o = i.itemModel, r = o.getModel("itemStyle").getItemStyle([ "color" ]), s = o.getModel("emphasis.itemStyle").getItemStyle(), l = o.getShallow("cursor");
        ic(t, function(t) {
            t.setColor(n), t.setStyle(E({
                fill: n,
                opacity: i.opacity
            }, r)), gn(t, s), l && (t.cursor = l), t.z2 = i.z2;
        });
        var h = {}, u = (e.valueDim.posDesc[+(0 < i.boundingLength)], t.__pictorialBarRect);
        ks(u.style, h, o, n, e.seriesModel, a), gn(u, h);
    }
    function oc(t) {
        var e = Math.round(t);
        return Math.abs(t - e) < 1e-4 ? e : Math.ceil(t);
    }
    function rc(t, e, i) {
        this.dimension = "single", this.dimensions = [ "single" ], this._axis = null, this._rect, 
        this._init(t, e, i), this.model = t;
    }
    function sc(t, e) {
        e = e || {};
        var i = t.coordinateSystem, n = t.axis, a = {}, o = n.position, r = n.orient, s = i.getRect(), l = [ s.x, s.x + s.width, s.y, s.y + s.height ], h = {
            horizontal: {
                top: l[2],
                bottom: l[3]
            },
            vertical: {
                left: l[0],
                right: l[1]
            }
        };
        a.position = [ "vertical" === r ? h.vertical[o] : l[0], "horizontal" === r ? h.horizontal[o] : l[3] ], 
        a.rotation = Math.PI / 2 * {
            horizontal: 0,
            vertical: 1
        }[r], a.labelDirection = a.tickDirection = a.nameDirection = {
            top: -1,
            bottom: 1,
            right: 1,
            left: -1
        }[o], t.get("axisTick.inside") && (a.tickDirection = -a.tickDirection), V(e.labelInside, t.get("axisLabel.inside")) && (a.labelDirection = -a.labelDirection);
        var u = e.rotate;
        return null == u && (u = t.get("axisLabel.rotate")), a.labelRotation = "top" === o ? -u : u, 
        a.labelInterval = n.getLabelInterval(), a.z2 = 1, a;
    }
    function lc(t, e, i, n, a) {
        var l, o, h, u, c, d, f, p, r = t.axis;
        if (!r.scale.isBlank() && r.containData(e)) if (t.involveSeries) {
            var s = (l = e, h = (o = t).axis, u = h.dim, c = l, d = [], f = Number.MAX_VALUE, 
            p = -1, rI(o.seriesModels, function(e, t) {
                var i, n, a = e.getData().mapDimension(u, !0);
                if (e.getAxisTooltipData) {
                    var o = e.getAxisTooltipData(a, l, h);
                    n = o.dataIndices, i = o.nestestValue;
                } else {
                    if (!(n = e.getData().indicesOfNearest(a[0], l, "category" === h.type ? .5 : null)).length) return;
                    i = e.getData().get(a[0], n[0]);
                }
                if (null != i && isFinite(i)) {
                    var r = l - i, s = Math.abs(r);
                    s <= f && ((s < f || 0 <= r && p < 0) && (f = s, p = r, c = i, d.length = 0), rI(n, function(t) {
                        d.push({
                            seriesIndex: e.seriesIndex,
                            dataIndexInside: t,
                            dataIndex: e.getData().getRawIndex(t)
                        });
                    }));
                }
            }), {
                payloadBatch: d,
                snapToValue: c
            }), g = s.payloadBatch, m = s.snapToValue;
            g[0] && null == a.seriesIndex && P(a, g[0]), !n && t.snap && r.containData(m) && null != m && (e = m), 
            i.showPointer(t, e, g, a), i.showTooltip(t, s, m);
        } else i.showPointer(t, e);
    }
    function hc(t, e, i, n) {
        t[e.key] = {
            value: i,
            payloadBatch: n
        };
    }
    function uc(t, e, i, n) {
        var a = i.payloadBatch, o = e.axis, r = o.model, s = e.axisPointerModel;
        if (e.triggerTooltip && a.length) {
            var l = e.coordSys.model, h = Ds(l), u = t.map[h];
            u || (u = t.map[h] = {
                coordSysId: l.id,
                coordSysIndex: l.componentIndex,
                coordSysType: l.type,
                coordSysMainType: l.mainType,
                dataByAxis: []
            }, t.list.push(u)), u.dataByAxis.push({
                axisDim: o.dim,
                axisIndex: r.componentIndex,
                axisType: r.type,
                axisId: r.id,
                value: n,
                valueLabelOpt: {
                    precision: s.get("label.precision"),
                    formatter: s.get("label.formatter")
                },
                seriesDataIndices: a.slice()
            });
        }
    }
    function cc(t) {
        var e = t.axis.model, i = {}, n = i.axisDim = t.axis.dim;
        return i.axisIndex = i[n + "AxisIndex"] = e.componentIndex, i.axisName = i[n + "AxisName"] = e.name, 
        i.axisId = i[n + "AxisId"] = e.id, i;
    }
    function dc(t) {
        return !t || null == t[0] || isNaN(t[0]) || null == t[1] || isNaN(t[1]);
    }
    function fc(t, e, i) {
        if (!Sp.node) {
            var n = e.getZr();
            hI(n).records || (hI(n).records = {}), function(u, c) {
                function t(t, h) {
                    u.on(t, function(e) {
                        var n, a, t, i, o, r, s, l = (n = c, {
                            dispatchAction: function t(e) {
                                var i = a[e.type];
                                i ? i.push(e) : (e.dispatchAction = t, n.dispatchAction(e));
                            },
                            pendings: a = {
                                showTip: [],
                                hideTip: []
                            }
                        });
                        uI(hI(u).records, function(t) {
                            t && h(t, e, l.dispatchAction);
                        }), t = l.pendings, i = c, r = t.showTip.length, s = t.hideTip.length, r ? o = t.showTip[r - 1] : s && (o = t.hideTip[s - 1]), 
                        o && (o.dispatchAction = null, i.dispatchAction(o));
                    });
                }
                hI(u).initialized || (hI(u).initialized = !0, t("click", z(gc, "click")), t("mousemove", z(gc, "mousemove")), 
                t("globalout", pc));
            }(n, e), (hI(n).records[t] || (hI(n).records[t] = {})).handler = i;
        }
    }
    function pc(t, e, i) {
        t.handler("leave", null, i);
    }
    function gc(t, e, i, n) {
        e.handler(t, i, n);
    }
    function mc(t, e) {
        if (!Sp.node) {
            var i = e.getZr();
            (hI(i).records || {})[t] && (hI(i).records[t] = null);
        }
    }
    function vc() {}
    function yc(t, e, i, n) {
        (function i(n, t) {
            if (B(n) && B(t)) {
                var a = !0;
                return R(t, function(t, e) {
                    a = a && i(n[e], t);
                }), !!a;
            }
            return n === t;
        })(dI(i).lastProp, n) || (dI(i).lastProp = n, e ? Mn(i, n, t) : (i.stopAnimation(), 
        i.attr(n)));
    }
    function xc(t, e) {
        t[e.get("label.show") ? "show" : "hide"]();
    }
    function _c(t) {
        return {
            position: t.position.slice(),
            rotation: t.rotation || 0
        };
    }
    function wc(t, e, i) {
        var n = e.get("z"), a = e.get("zlevel");
        t && t.traverse(function(t) {
            "group" !== t.type && (null != n && (t.z = n), null != a && (t.zlevel = a), t.silent = i);
        });
    }
    function bc(t) {
        var e, i = t.get("type"), n = t.getModel(i + "Style");
        return "line" === i ? (e = n.getLineStyle()).fill = null : "shadow" === i && ((e = n.getAreaStyle()).stroke = null), 
        e;
    }
    function Sc(t, e, i, n, a) {
        var o = Mc(i.get("value"), e.axis, e.ecModel, i.get("seriesDataIndices"), {
            precision: i.get("label.precision"),
            formatter: i.get("label.formatter")
        }), r = i.getModel("label"), s = my(r.get("padding") || 0), l = r.getFont(), h = le(o, l), u = a.position, c = h.width + s[1] + s[3], d = h.height + s[0] + s[2], f = a.align;
        "right" === f && (u[0] -= c), "center" === f && (u[0] -= c / 2);
        var p, g, m, v, y, x, _ = a.verticalAlign;
        "bottom" === _ && (u[1] -= d), "middle" === _ && (u[1] -= d / 2), p = u, g = c, 
        m = d, y = (v = n).getWidth(), x = v.getHeight(), p[0] = Math.min(p[0] + g, y) - g, 
        p[1] = Math.min(p[1] + m, x) - m, p[0] = Math.max(p[0], 0), p[1] = Math.max(p[1], 0);
        var w = r.get("backgroundColor");
        w && "auto" !== w || (w = e.get("axisLine.lineStyle.color")), t.label = {
            shape: {
                x: 0,
                y: 0,
                width: c,
                height: d,
                r: r.get("borderRadius")
            },
            position: u.slice(),
            style: {
                text: o,
                textFont: l,
                textFill: r.getTextColor(),
                textPosition: "inside",
                fill: w,
                stroke: r.get("borderColor") || "transparent",
                lineWidth: r.get("borderWidth") || 0,
                shadowBlur: r.get("shadowBlur"),
                shadowColor: r.get("shadowColor"),
                shadowOffsetX: r.get("shadowOffsetX"),
                shadowOffsetY: r.get("shadowOffsetY")
            },
            z2: 10
        };
    }
    function Mc(t, e, a, i, n) {
        var o = e.scale.getLabel(t, {
            precision: n.precision
        }), r = n.formatter;
        if (r) {
            var s = {
                value: Or(e, t),
                seriesData: []
            };
            R(i, function(t) {
                var e = a.getSeriesByIndex(t.seriesIndex), i = t.dataIndexInside, n = e && e.getDataParams(i);
                n && s.seriesData.push(n);
            }), b(r) ? o = r.replace("{value}", o) : m(r) && (o = r(s));
        }
        return o;
    }
    function Ic(t, e, i) {
        var n = rt();
        return ct(n, n, i.rotation), ut(n, n, i.position), Dn([ t.dataToCoord(e), (i.labelOffset || 0) + (i.labelDirection || 1) * (i.labelMargin || 0) ], n);
    }
    function Tc(t, e, i, n, a, o) {
        var r = Gw.innerTextLayout(i.rotation, 0, i.labelDirection);
        i.labelMargin = a.get("label.margin"), Sc(e, n, a, o, {
            position: Ic(n.axis, t, i),
            align: r.textAlign,
            verticalAlign: r.textVerticalAlign
        });
    }
    function Dc(t, e, i) {
        return {
            x1: t[i = i || 0],
            y1: t[1 - i],
            x2: e[i],
            y2: e[1 - i]
        };
    }
    function Ac(t, e, i) {
        return {
            x: t[i = i || 0],
            y: t[1 - i],
            width: e[i],
            height: e[1 - i]
        };
    }
    function Cc(t, e, i, n, a, o) {
        return {
            cx: t,
            cy: e,
            r0: i,
            r: n,
            startAngle: a,
            endAngle: o,
            clockwise: !0
        };
    }
    function Lc(t, e) {
        var i = {};
        return i[e.dim + "AxisIndex"] = e.index, t.getCartesian(i);
    }
    function kc(t) {
        return "x" === t.dim ? 0 : 1;
    }
    function Pc(t) {
        return t.isHorizontal() ? 0 : 1;
    }
    function Nc(t, e) {
        var i = t.getRect();
        return [ i[vI[e]], i[vI[e]] + i[yI[e]] ];
    }
    function Oc(i, t, e) {
        if (i.count()) for (var n, a = t.coordinateSystem, o = t.getLayerSeries(), r = i.mapDimension("single"), s = i.mapDimension("value"), l = L(o, function(t) {
            return L(t.indices, function(t) {
                var e = a.dataToPoint(i.get(r, t));
                return e[1] = i.get(s, t), e;
            });
        }), h = function(t) {
            for (var e = t.length, i = t[0].length, n = [], a = [], o = 0, r = {}, s = 0; s < i; ++s) {
                for (var l = 0, h = 0; l < e; ++l) h += t[l][s][1];
                o < h && (o = h), n.push(h);
            }
            for (var u = 0; u < i; ++u) a[u] = (o - n[u]) / 2;
            for (var c = o = 0; c < i; ++c) {
                var d = n[c] + a[c];
                o < d && (o = d);
            }
            return r.y0 = a, r.max = o, r;
        }(l), u = h.y0, c = e / h.max, d = o.length, f = o[0].indices.length, p = 0; p < f; ++p) {
            n = u[p] * c, i.setItemLayout(o[0].indices[p], {
                layerIndex: 0,
                x: l[0][p][0],
                y0: n,
                y: l[0][p][1] * c
            });
            for (var g = 1; g < d; ++g) n += l[g - 1][p][1] * c, i.setItemLayout(o[g].indices[p], {
                layerIndex: g,
                x: l[g][p][0],
                y0: n,
                y: l[g][p][1] * c
            });
        }
    }
    function Ec(t, e, i) {
        function n() {
            r.ignore = r.hoverIgnore;
        }
        function a() {
            r.ignore = r.normalIgnore;
        }
        Dg.call(this);
        var o = new zv({
            z2: SI
        }), r = new Nv({
            z2: MI,
            silent: t.getModel("label").get("silent")
        });
        this.add(o), this.add(r), this.updateData(!0, t, "normal", e, i), this.on("emphasis", n).on("normal", a).on("mouseover", n).on("mouseout", a);
    }
    function Rc(t, e, i) {
        var n = t.getVisual("color"), a = t.getVisual("visualMeta");
        a && 0 !== a.length || (n = null);
        var o = t.getModel("itemStyle").get("color");
        if (o) return o;
        if (n) return n;
        if (0 === t.depth) return i.option.color[0];
        var r = i.option.color.length;
        return i.option.color[function(t) {
            for (var e = t; 1 < e.depth; ) e = e.parentNode;
            return C(t.getAncestors()[0].children, e);
        }(t) % r];
    }
    function zc(o, r) {
        return r = r || [ 0, 0 ], L([ "x", "y" ], function(t, e) {
            var i = this.getAxis(t), n = r[e], a = o[e] / 2;
            return "category" === i.type ? i.getBandWidth() : Math.abs(i.dataToCoord(n - a) - i.dataToCoord(n + a));
        }, this);
    }
    function Bc(o, r) {
        return r = r || [ 0, 0 ], L([ 0, 1 ], function(t) {
            var e = r[t], i = o[t] / 2, n = [], a = [];
            return n[t] = e - i, a[t] = e + i, n[1 - t] = a[1 - t] = r[1 - t], Math.abs(this.dataToPoint(n)[t] - this.dataToPoint(a)[t]);
        }, this);
    }
    function Vc(t, e) {
        var i = this.getAxis(), n = e instanceof Array ? e[0] : e, a = (t instanceof Array ? t[0] : t) / 2;
        return "category" === i.type ? i.getBandWidth() : Math.abs(i.dataToCoord(n - a) - i.dataToCoord(n + a));
    }
    function Gc(s, l) {
        return L([ "Radius", "Angle" ], function(t, e) {
            var i = this["get" + t + "Axis"](), n = l[e], a = s[e] / 2, o = "dataTo" + t, r = "category" === i.type ? i.getBandWidth() : Math.abs(i[o](n - a) - i[o](n + a));
            return "Angle" === t && (r = r * Math.PI / 180), r;
        }, this);
    }
    function Wc(t, e, i, n, a) {
        null == i[t] || a || (e[t] = i[t], i[t] = n[t]);
    }
    function Fc(a, o, e, t) {
        function r(t) {
            null == t && (t = l), v && (h = o.getItemModel(t), u = h.getModel(kI), c = h.getModel(PI), 
            d = o.getItemVisual(t, "color"), v = !1);
        }
        var i = a.get("renderItem"), n = a.coordinateSystem, s = {};
        n && (s = n.prepareCustoms ? n.prepareCustoms() : OI[n.type](n));
        var l, h, u, c, d, f, p, g = E({
            getWidth: t.getWidth,
            getHeight: t.getHeight,
            getZr: t.getZr,
            getDevicePixelRatio: t.getDevicePixelRatio,
            value: function(t, e) {
                return null == e && (e = l), o.get(o.getDimension(t || 0), e);
            },
            style: function(t, e) {
                null == e && (e = l), r(e);
                var i = h.getModel(CI).getItemStyle();
                null != d && (i.fill = d);
                var n = o.getItemVisual(e, "opacity");
                return null != n && (i.opacity = n), vn(i, u, null, {
                    autoColor: d,
                    isRectText: !0
                }), i.text = u.getShallow("show") ? k(a.getFormattedLabel(e, "normal"), Fr(o, e)) : null, 
                t && P(i, t), i;
            },
            styleEmphasis: function(t, e) {
                null == e && (e = l), r(e);
                var i = h.getModel(LI).getItemStyle();
                return vn(i, c, null, {
                    isRectText: !0
                }, !0), i.text = c.getShallow("show") ? G(a.getFormattedLabel(e, "emphasis"), a.getFormattedLabel(e, "normal"), Fr(o, e)) : null, 
                t && P(i, t), i;
            },
            visual: function(t, e) {
                return null == e && (e = l), o.getItemVisual(e, t);
            },
            barLayout: function(t) {
                if (n.getBaseAxis) return function(t, e) {
                    var i = [], n = t.axis;
                    if ("category" === n.type) {
                        for (var a = n.getBandWidth(), o = 0; o < t.count; o++) i.push(E({
                            bandWidth: a,
                            axisKey: "axis0",
                            stackId: C_ + o
                        }, t));
                        var r = Tr(i), s = [];
                        for (o = 0; o < t.count; o++) {
                            var l = r.axis0[C_ + o];
                            l.offsetCenter = l.offset + l.width / 2, s.push(l);
                        }
                        return s;
                    }
                }(E({
                    axis: n.getBaseAxis()
                }, t));
            },
            currentSeriesIndices: function() {
                return e.getCurrentSeriesIndices();
            },
            font: function(t) {
                return bn(t, e);
            }
        }, s.api || {}), m = {
            context: {},
            seriesId: a.id,
            seriesName: a.name,
            seriesIndex: a.seriesIndex,
            coordSys: s.coordSys,
            dataInsideLength: o.count(),
            encode: (f = a.getData(), p = {}, R(f.dimensions, function(t, e) {
                var i = f.getDimensionInfo(t);
                if (!i.isExtraCoord) {
                    var n = i.coordDim;
                    (p[n] = p[n] || [])[i.coordDimIndex] = e;
                }
            }), p)
        }, v = !0;
        return function(t) {
            return l = t, v = !0, i && i(E({
                dataIndexInside: t,
                dataIndex: o.getRawIndex(t)
            }, m), g) || {};
        };
    }
    function Hc(t, e, i, n, a, o) {
        return (t = Zc(t, e, i, n, a, o)) && o.setItemGraphicEl(e, t), t;
    }
    function Zc(t, e, i, n, a, o) {
        var r, s = i.type;
        if (!t || s === t.__customGraphicType || "path" === s && i.pathData === t.__customPathData || "image" === s && i.style.image === t.__customImagePath || "text" === s && i.style.text === t.__customText || (a.remove(t), 
        t = null), null != s) {
            var l = !t;
            if (!t && (t = function(t) {
                var e, i = t.type;
                if ("path" === i) {
                    var n = t.shape;
                    (e = qi(n.pathData, null, {
                        x: n.x || 0,
                        y: n.y || 0,
                        width: n.width || 0,
                        height: n.height || 0
                    }, "center")).__customPathData = t.pathData;
                } else "image" === i ? (e = new Be({})).__customImagePath = t.style.image : "text" === i ? (e = new Nv({})).__customText = t.style.text : e = new (iy[i.charAt(0).toUpperCase() + i.slice(1)])();
                return e.__customGraphicType = i, e.name = t.name, e;
            }(i)), function(e, t, i, n, a, o) {
                var r = {}, s = i.style || {};
                if (i.shape && (r.shape = A(i.shape)), i.position && (r.position = i.position.slice()), 
                i.scale && (r.scale = i.scale.slice()), i.origin && (r.origin = i.origin.slice()), 
                i.rotation && (r.rotation = i.rotation), "image" === e.type && i.style && (l = r.style = {}, 
                R([ "x", "y", "width", "height" ], function(t) {
                    Wc(t, l, s, e.style, o);
                })), "text" === e.type && i.style) {
                    var l = r.style = {};
                    R([ "x", "y" ], function(t) {
                        Wc(t, l, s, e.style, o);
                    }), !s.hasOwnProperty("textFill") && s.fill && (s.textFill = s.fill), !s.hasOwnProperty("textStroke") && s.stroke && (s.textStroke = s.stroke);
                }
                if ("group" !== e.type && (e.useStyle(s), o)) {
                    e.style.opacity = 0;
                    var h = s.opacity;
                    null == h && (h = 1), In(e, {
                        style: {
                            opacity: h
                        }
                    }, n, t);
                }
                o ? e.attr(r) : Mn(e, r, n, t), e.attr({
                    z2: i.z2 || 0,
                    silent: i.silent
                }), !1 !== i.styleEmphasis && gn(e, i.styleEmphasis);
            }(t, e, i, n, 0, l), "group" === s) {
                var h = t.children() || [], u = i.children || [];
                if (i.diffChildrenByName) new tr((r = {
                    oldChildren: h,
                    newChildren: u,
                    dataIndex: e,
                    animatableModel: n,
                    group: t,
                    data: o
                }).oldChildren, r.newChildren, Uc, Uc, r).add(jc).update(jc).remove(Xc).execute(); else {
                    for (var c = 0; c < u.length; c++) Zc(t.childAt(c), e, u[c], n, t, o);
                    for (;c < h.length; c++) h[c] && t.remove(h[c]);
                }
            }
            return a.add(t), t;
        }
    }
    function Uc(t, e) {
        var i = t && t.name;
        return null != i ? i : NI + e;
    }
    function jc(t, e) {
        var i = this.context, n = null != t ? i.newChildren[t] : null;
        Zc(null != e ? i.oldChildren[e] : null, i.dataIndex, n, i.animatableModel, i.group, i.data);
    }
    function Xc(t) {
        var e = this.context, i = e.oldChildren[t];
        i && e.group.remove(i);
    }
    function Yc(t, e, i, n) {
        var a = i.type, o = new (iy[a.charAt(0).toUpperCase() + a.slice(1)])(i);
        e.add(o), n.set(t, o), o.__ecGraphicId = t;
    }
    function qc(t, e) {
        var i = t && t.parent;
        i && ("group" === t.type && t.traverse(function(t) {
            qc(t, e);
        }), e.removeKey(t.__ecGraphicId), i.remove(t));
    }
    function Kc(e, t) {
        var i;
        return R(t, function(t) {
            null != e[t] && "auto" !== e[t] && (i = !0);
        }), i;
    }
    function $c(t, e, i) {
        var a, o = {}, r = "toggleSelected" === t;
        return i.eachComponent("legend", function(n) {
            r && null != a ? n[a ? "select" : "unSelect"](e.name) : (n[t](e.name), a = n.isSelected(e.name)), 
            R(n.getData(), function(t) {
                var e = t.get("name");
                if ("\n" !== e && "" !== e) {
                    var i = n.isSelected(e);
                    o.hasOwnProperty(e) ? o[e] = o[e] && i : o[e] = i;
                }
            });
        }), {
            name: e.name,
            selected: o
        };
    }
    function Jc(t, e) {
        var i = my(e.get("padding")), n = e.getItemStyle([ "color", "opacity" ]);
        return n.fill = e.get("backgroundColor"), new Wv({
            shape: {
                x: t.x - i[3],
                y: t.y - i[0],
                width: t.width + i[1] + i[3],
                height: t.height + i[0] + i[2],
                r: e.get("borderRadius")
            },
            style: n,
            silent: !0,
            z2: -1
        });
    }
    function Qc(t, e) {
        e.dispatchAction({
            type: "legendToggleSelect",
            name: t
        });
    }
    function td(t, e, i) {
        var n = i.getZr().storage.getDisplayList()[0];
        n && n.useHoverLayer || t.get("legendHoverLink") && i.dispatchAction({
            type: "highlight",
            seriesName: t.name,
            name: e
        });
    }
    function ed(t, e, i) {
        var n = i.getZr().storage.getDisplayList()[0];
        n && n.useHoverLayer || t.get("legendHoverLink") && i.dispatchAction({
            type: "downplay",
            seriesName: t.name,
            name: e
        });
    }
    function id(t, e, i) {
        var n = [ 1, 1 ];
        n[t.getOrient().index] = 0, ua(e, i, {
            type: "box",
            ignoreSize: n
        });
    }
    function nd(a) {
        var i, n, t, e, o, r, s = [], l = a.get("transitionDuration"), h = a.get("backgroundColor"), u = a.getModel("textStyle"), c = a.get("padding");
        return l && s.push((r = "left " + (o = l) + "s cubic-bezier(0.23, 1, 0.32, 1),top " + o + "s cubic-bezier(0.23, 1, 0.32, 1)", 
        L(YI, function(t) {
            return t + "transition:" + r;
        }).join(";"))), h && (Sp.canvasSupported ? s.push("background-Color:" + h) : (s.push("background-Color:#" + Ct(h)), 
        s.push("filter:alpha(opacity=70)"))), jI([ "width", "color", "radius" ], function(t) {
            var e = "border-" + t, i = XI(e), n = a.get(i);
            null != n && s.push(e + ":" + n + ("color" === t ? "" : "px"));
        }), s.push((n = [], t = (i = u).get("fontSize"), (e = i.getTextColor()) && n.push("color:" + e), 
        n.push("font:" + i.getFont()), t && n.push("line-height:" + Math.round(3 * t / 2) + "px"), 
        jI([ "decoration", "align" ], function(t) {
            var e = i.get(t);
            e && n.push("text-" + t + ":" + e);
        }), n.join(";"))), null != c && s.push("padding:" + my(c).join("px ") + "px"), s.join(";") + ";";
    }
    function ad(i, t) {
        if (Sp.wxa) return null;
        var e = document.createElement("div"), n = this._zr = t.getZr();
        this.el = e, this._x = t.getWidth() / 2, this._y = t.getHeight() / 2, i.appendChild(e), 
        this._container = i, this._show = !1, this._hideTimeout;
        var a = this;
        e.onmouseenter = function() {
            a._enterable && (clearTimeout(a._hideTimeout), a._show = !0), a._inContent = !0;
        }, e.onmousemove = function(t) {
            if (t = t || window.event, !a._enterable) {
                var e = n.handler;
                Fe(i, t, !0), e.dispatch("mousemove", t);
            }
        }, e.onmouseleave = function() {
            a._enterable && a._show && a.hideLater(a._hideDelay), a._inContent = !1;
        };
    }
    function od(t) {
        for (var e = t.pop(); t.length; ) {
            var i = t.pop();
            i && (Pn.isInstance(i) && (i = i.get("tooltip", !0)), "string" == typeof i && (i = {
                formatter: i
            }), e = new Pn(i, e, e.ecModel));
        }
        return e;
    }
    function rd(t, e) {
        return t.dispatchAction || _(e.dispatchAction, e);
    }
    function sd(t) {
        var e = t.clientWidth, i = t.clientHeight;
        if (document.defaultView && document.defaultView.getComputedStyle) {
            var n = document.defaultView.getComputedStyle(t);
            n && (e += parseInt(n.paddingLeft, 10) + parseInt(n.paddingRight, 10) + parseInt(n.borderLeftWidth, 10) + parseInt(n.borderRightWidth, 10), 
            i += parseInt(n.paddingTop, 10) + parseInt(n.paddingBottom, 10) + parseInt(n.borderTopWidth, 10) + parseInt(n.borderBottomWidth, 10));
        }
        return {
            width: e,
            height: i
        };
    }
    function ld(t) {
        return "center" === t || "middle" === t;
    }
    function hd(t) {
        return t.get("stack") || "__ec_stack_" + t.seriesIndex;
    }
    function ud(t) {
        return t.dim;
    }
    function cd(t, e) {
        aw.call(this, "radius", t, e), this.type = "category";
    }
    function dd(t, e) {
        e = e || [ 0, 360 ], aw.call(this, "angle", t, e), this.type = "category";
    }
    function fd(t, e) {
        return e.type || (e.data ? "category" : "value");
    }
    function pd(t, e) {
        var i = this, n = i.getAngleAxis(), a = i.getRadiusAxis();
        if (n.scale.setExtent(1 / 0, -1 / 0), a.scale.setExtent(1 / 0, -1 / 0), t.eachSeries(function(t) {
            if (t.coordinateSystem === i) {
                var e = t.getData();
                R(e.mapDimension("radius", !0), function(t) {
                    a.scale.unionExtentFromData(e, t);
                }), R(e.mapDimension("angle", !0), function(t) {
                    n.scale.unionExtentFromData(e, t);
                });
            }
        }), Lr(n.scale, n.model), Lr(a.scale, a.model), "category" === n.type && !n.onBand) {
            var o = n.getExtent(), r = 360 / n.scale.count();
            n.inverse ? o[1] += r : o[1] -= r, n.setExtent(o[0], o[1]);
        }
    }
    function gd(t, e) {
        if (t.type = e.get("type"), t.scale = kr(e), t.onBand = e.get("boundaryGap") && "category" === t.type, 
        t.inverse = e.get("inverse"), "angleAxis" === e.mainType) {
            t.inverse ^= e.get("clockwise");
            var i = e.get("startAngle");
            t.setExtent(i, i + (t.inverse ? -360 : 360));
        }
        (e.axis = t).model = e;
    }
    function md(t, e, i) {
        e[1] > e[0] && (e = e.slice().reverse());
        var n = t.coordToPoint([ e[0], i ]), a = t.coordToPoint([ e[1], i ]);
        return {
            x1: n[0],
            y1: n[1],
            x2: a[0],
            y2: a[1]
        };
    }
    function vd(t) {
        return t.getRadiusAxis().inverse ? 0 : 1;
    }
    function yd(n, t) {
        t.update = "updateView", Fo(t, function(t, e) {
            var i = {};
            return e.eachComponent({
                mainType: "geo",
                query: t
            }, function(e) {
                e[n](t.name), R(e.coordinateSystem.regions, function(t) {
                    i[t.name] = e.isSelected(t.name) || !1;
                });
            }), {
                selected: i,
                name: t.name
            };
        });
    }
    function xd(t) {
        if (t) for (var e in t) if (t.hasOwnProperty(e)) return !0;
    }
    function _d(e, t, o) {
        var i = {};
        return lT(t, function(n) {
            var t, a = i[n] = ((t = function() {}).prototype.__hidden = t.prototype, new t());
            lT(e[n], function(t, e) {
                if (eS.isValidType(e)) {
                    var i = {
                        type: e,
                        visual: t
                    };
                    o && o(i, n), a[e] = new eS(i), "opacity" === e && ((i = A(i)).type = "colorAlpha", 
                    a.__hidden.__alphaForOpacity = new eS(i));
                }
            });
        }), i;
    }
    function wd(e, i, t) {
        var n;
        R(t, function(t) {
            i.hasOwnProperty(t) && xd(i[t]) && (n = !0);
        }), n && R(t, function(t) {
            i.hasOwnProperty(t) && xd(i[t]) ? e[t] = A(i[t]) : delete e[t];
        });
    }
    function bd(o) {
        var r = [ "x", "y" ], s = [ "width", "height" ];
        return {
            point: function(t, e, i) {
                if (t) {
                    var n = i.range;
                    return Sd(t[o], n);
                }
            },
            rect: function(t, e, i) {
                if (t) {
                    var n = i.range, a = [ t[r[o]], t[r[o]] + t[s[o]] ];
                    return a[1] < a[0] && a.reverse(), Sd(a[0], n) || Sd(a[1], n) || Sd(n[0], a) || Sd(n[1], a);
                }
            }
        };
    }
    function Sd(t, e) {
        return e[0] <= t && t <= e[1];
    }
    function Md(t, e, i, n, a) {
        for (var o = 0, r = a[a.length - 1]; o < a.length; o++) {
            var s = a[o];
            if (Id(t, e, i, n, s[0], s[1], r[0], r[1])) return !0;
            r = s;
        }
    }
    function Id(t, e, i, n, a, o, r, s) {
        var l, h = Td(i - t, a - r, n - e, o - s);
        if ((l = h) <= 1e-6 && -1e-6 <= l) return !1;
        var u = Td(a - t, a - r, o - e, o - s) / h;
        if (u < 0 || 1 < u) return !1;
        var c = Td(i - t, a - t, n - e, o - e) / h;
        return !(c < 0 || 1 < c);
    }
    function Td(t, e, i, n) {
        return t * n - e * i;
    }
    function Dd(t, e, i) {
        var n = this._targetInfoList = [], a = {}, o = Cd(e, t);
        uT(mT, function(t, e) {
            (!i || !i.include || 0 <= cT(i.include, e)) && t(o, n, a);
        });
    }
    function Ad(t) {
        return t[0] > t[1] && t.reverse(), t;
    }
    function Cd(t, e) {
        return li(t, e, {
            includeMainTypes: pT
        });
    }
    function Ld(t, e, i, n) {
        var a = i.getAxis([ "x", "y" ][t]), o = Ad(L([ 0, 1 ], function(t) {
            return e ? a.coordToData(a.toLocalCoord(n[t])) : a.toGlobalCoord(a.dataToCoord(n[t]));
        })), r = [];
        return r[t] = o, r[1 - t] = [ NaN, NaN ], {
            values: o,
            xyMinMax: r
        };
    }
    function kd(t, e, i, n) {
        return [ e[0] - n[t] * i[0], e[1] - n[t] * i[1] ];
    }
    function Pd(t) {
        return t ? [ t[0][1] - t[0][0], t[1][1] - t[1][0] ] : [ NaN, NaN ];
    }
    function Nd(t, e) {
        if (!t.isDisposed()) {
            var i = t.getZr();
            i[ST] = !0, t.dispatchAction({
                type: "brushSelect",
                batch: e
            }), i[ST] = !1;
        }
    }
    function Od(t, e, i, n) {
        for (var a = 0, o = e.length; a < o; a++) {
            var r = e[a];
            if (t[r.brushType](n, i, r.selectors, r)) return !0;
        }
    }
    function Ed(t) {
        var r = t.brushSelector;
        if (b(r)) {
            var e = [];
            return R(hT, function(o, t) {
                e[t] = function(t, e, i, n) {
                    var a = e.getItemLayout(t);
                    return o[r](a, i, n);
                };
            }), e;
        }
        if (m(r)) {
            var i = {};
            return R(hT, function(t, e) {
                i[e] = r;
            }), i;
        }
        return r;
    }
    function Rd(t) {
        return new Xt(t[0][0], t[1][0], t[0][1] - t[0][0], t[1][1] - t[1][0]);
    }
    function zd(t, e) {
        return g({
            brushType: t.brushType,
            brushMode: t.brushMode,
            transformable: t.transformable,
            brushStyle: new Pn(t.brushStyle).getItemStyle(),
            removeOnClick: t.removeOnClick,
            z: t.z
        }, e, !0);
    }
    function Bd(t, e, i, n) {
        (!n || n.$from !== t.id) && this._brushController.setPanels(t.brushTargetManager.makePanelOpts(i)).enableBrush(t.brushOption).updateCovers(t.areas.slice());
    }
    function Vd(t, e) {
        DT[t] = e;
    }
    function Gd(t) {
        return DT[t];
    }
    function Wd(t, e, i) {
        this.model = t, this.ecModel = e, this.api = i, this._brushType, this._brushMode;
    }
    function Fd(t, e, i) {
        this._model = t;
    }
    function Hd(t, e, i, n) {
        var a = i.calendarModel, o = i.seriesModel, r = a ? a.coordinateSystem : o ? o.coordinateSystem : null;
        return r === this ? r[t](n) : null;
    }
    function Zd(t, n) {
        var a = t.cellSize;
        N(a) ? 1 === a.length && (a[1] = a[0]) : a = t.cellSize = [ a, a ];
        var e = L([ 0, 1 ], function(t) {
            return (null != (e = n)[Ty[i = t][0]] || null != e[Ty[i][1]] && null != e[Ty[i][2]]) && (a[t] = "auto"), 
            null != a[t] && "auto" !== a[t];
            var e, i;
        });
        ua(t, n, {
            type: "box",
            ignoreSize: e
        });
    }
    function Ud(t, e, i) {
        var n = [ 1 / 0, -1 / 0 ];
        return VT(i, function(t) {
            var i = t.getData();
            i && VT(i.mapDimension(e, !0), function(t) {
                var e = i.getApproximateExtent(t);
                e[0] < n[0] && (n[0] = e[0]), e[1] > n[1] && (n[1] = e[1]);
            });
        }), n[1] < n[0] && (n = [ NaN, NaN ]), function(t, e) {
            var i = t.getAxisModel(), n = i.getMin(!0), a = "category" === i.get("type"), o = a && i.getCategories().length;
            null != n && "dataMin" !== n && "function" != typeof n ? e[0] = n : a && (e[0] = 0 < o ? 0 : NaN);
            var r = i.getMax(!0);
            null != r && "dataMax" !== r && "function" != typeof r ? e[1] = r : a && (e[1] = 0 < o ? o - 1 : NaN), 
            i.get("scale", !0) || (0 < e[0] && (e[0] = 0), e[1] < 0 && (e[1] = 0));
        }(t, n), n;
    }
    function jd(t, e) {
        var i = t.getAxisModel(), n = t._percentWindow, a = t._valueWindow;
        if (n) {
            var o = Fn(a, [ 0, 500 ]);
            o = Math.min(o, 20);
            var r = e || 0 === n[0] && 100 === n[1];
            i.setRange(r ? null : +a[0].toFixed(o), r ? null : +a[1].toFixed(o));
        }
    }
    function Xd(e) {
        var i = {};
        return FT([ "start", "end", "startValue", "endValue", "throttle" ], function(t) {
            e.hasOwnProperty(t) && (i[t] = e[t]);
        }), i;
    }
    function Yd(t, a) {
        var o = t._rangePropMode, r = t.get("rangeMode");
        FT([ [ "start", "startValue" ], [ "end", "endValue" ] ], function(t, e) {
            var i = null != a[t[0]], n = null != a[t[1]];
            i && !n ? o[e] = "percent" : !i && n ? o[e] = "value" : r ? o[e] = r[e] : i && (o[e] = "percent");
        });
    }
    function qd(t) {
        return "vertical" === t ? "ns-resize" : "ew-resize";
    }
    function Kd(t, n) {
        var e = Jd(t), a = n.dataZoomId, o = n.coordId;
        R(e, function(t, e) {
            var i = t.dataZoomInfos;
            i[a] && C(n.allCoordIds, o) < 0 && (delete i[a], t.count--);
        }), Qd(e);
        var i, r, s = e[o];
        s || ((s = e[o] = {
            coordId: o,
            dataZoomInfos: {},
            count: 0
        }).controller = (i = s, (r = new Qs(t.getZr())).on("pan", tD(tf, i)), r.on("zoom", tD(ef, i)), 
        r), s.dispatchAction = z(af, t)), !s.dataZoomInfos[a] && s.count++, s.dataZoomInfos[a] = n;
        var l, h, u, c, d = (l = s.dataZoomInfos, u = {}, c = {
            type_true: 2,
            type_move: 1,
            type_false: 0,
            type_undefined: -1
        }, R(l, function(t) {
            var e = !t.disabled && (!t.zoomLock || "move");
            c["type_" + h] < c["type_" + e] && (h = e), P(u, t.roamControllerOpt);
        }), {
            controlType: h,
            opt: u
        });
        s.controller.enable(d.controlType, d.opt), s.controller.setPointerChecker(n.containsPoint), 
        ro(s, "dispatchAction", n.throttleRate, "fixRate");
    }
    function $d(t) {
        return t.type + "\0_" + t.id;
    }
    function Jd(t) {
        var e = t.getZr();
        return e[eD] || (e[eD] = {});
    }
    function Qd(i) {
        R(i, function(t, e) {
            t.count || (t.controller.dispose(), delete i[e]);
        });
    }
    function tf(e, i, n, a, o, r, s) {
        nf(e, function(t) {
            return t.panGetRange(e.controller, i, n, a, o, r, s);
        });
    }
    function ef(e, i, n, a) {
        nf(e, function(t) {
            return t.zoomGetRange(e.controller, i, n, a);
        });
    }
    function nf(t, i) {
        var n = [];
        R(t.dataZoomInfos, function(t) {
            var e = i(t);
            !t.disabled && e && n.push({
                dataZoomId: t.dataZoomId,
                start: e[0],
                end: e[1]
            });
        }), t.dispatchAction(n);
    }
    function af(t, e) {
        t.dispatchAction({
            type: "dataZoom",
            batch: e
        });
    }
    function of(t, e) {
        return t && t.hasOwnProperty && t.hasOwnProperty(e);
    }
    function rf(t, e, i, n) {
        for (var a = e.targetVisuals[n], o = eS.prepareVisualTypes(a), r = {
            color: t.getData().getVisual("color")
        }, s = 0, l = o.length; s < l; s++) {
            var h = o[s], u = a["opacity" === h ? "__alphaForOpacity" : h];
            u && u.applyVisual(i, function(t) {
                return r[t];
            }, function(t, e) {
                r[t] = e;
            });
        }
        return r.color;
    }
    function sf(t, e, i) {
        if (i[0] === i[1]) return i.slice();
        for (var n = (i[1] - i[0]) / 200, a = i[0], o = [], r = 0; r <= 200 && a < i[1]; r++) o.push(a), 
        a += n;
        return o.push(i[1]), o;
    }
    function lf(t, e, i) {
        var n = t.option, a = n.align;
        if (null != a && "auto" !== a) return a;
        for (var o = {
            width: e.getWidth(),
            height: e.getHeight()
        }, r = "horizontal" === n.orient ? 1 : 0, s = [ [ "left", "right", "width" ], [ "top", "bottom", "height" ] ], l = s[r], h = [ 0, null, 10 ], u = {}, c = 0; c < 3; c++) u[s[1 - r][c]] = h[c], 
        u[l[c]] = 2 === c ? i[0] : n[l[c]];
        var d = [ [ "x", "width", 3 ], [ "y", "height", 0 ] ][r], f = la(u, o, n.padding);
        return l[(f.margin[d[2]] || 0) + f[d[0]] + .5 * f[d[1]] < .5 * o[d[1]] ? 0 : 1];
    }
    function hf(e) {
        return R(e || [], function(t) {
            null != e.dataIndex && (e.dataIndexInside = e.dataIndex, e.dataIndex = null);
        }), e;
    }
    function uf(t, e, i, n) {
        return new Vv({
            shape: {
                points: t
            },
            draggable: !!i,
            cursor: e,
            drift: i,
            onmousemove: function(t) {
                nm(t.event);
            },
            ondragend: n
        });
    }
    function cf(t) {
        var e = t.get("hoverLinkOnHandle");
        return !!(null == e ? t.get("realtime") : e);
    }
    function df(t) {
        return "vertical" === t ? "ns-resize" : "ew-resize";
    }
    function ff(t, e) {
        var i = t.inverse;
        ("vertical" === t.orient ? !i : i) && e.reverse();
    }
    function pf(t) {
        ti(t, "label", [ "show" ]);
    }
    function gf(t, e, i, n, a, o) {
        var r = [], s = pr(e, n, i) ? e.getCalculationInfo("stackResultDimension") : n, l = _f(e, s, t), h = e.indicesOfNearest(s, l)[0];
        r[a] = e.get(i, h), r[o] = e.get(n, h);
        var u = Gn(e.get(n, h));
        return 0 <= (u = Math.min(u, 20)) && (r[o] = +r[o].toFixed(u)), r;
    }
    function mf(t, e) {
        var i, n = t.getData(), a = t.coordinateSystem;
        if (e && (i = e, isNaN(parseFloat(i.x)) || isNaN(parseFloat(i.y))) && !N(e.coord) && a) {
            var o = a.dimensions, r = vf(e, n, a, t);
            if ((e = A(e)).type && PD[e.type] && r.baseAxis && r.valueAxis) {
                var s = LD(o, r.baseAxis.dim), l = LD(o, r.valueAxis.dim);
                e.coord = PD[e.type](n, r.baseDataDim, r.valueDataDim, s, l), e.value = e.coord[l];
            } else {
                for (var h = [ null != e.xAxis ? e.xAxis : e.radiusAxis, null != e.yAxis ? e.yAxis : e.angleAxis ], u = 0; u < 2; u++) PD[h[u]] && (h[u] = _f(n, n.mapDimension(o[u]), h[u]));
                e.coord = h;
            }
        }
        return e;
    }
    function vf(t, e, i, n) {
        var a = {};
        return null != t.valueIndex || null != t.valueDim ? (a.valueDataDim = null != t.valueIndex ? e.getDimension(t.valueIndex) : t.valueDim, 
        a.valueAxis = i.getAxis(function(t, e) {
            var i = t.getData(), n = i.dimensions;
            e = i.getDimension(e);
            for (var a = 0; a < n.length; a++) {
                var o = i.getDimensionInfo(n[a]);
                if (o.name === e) return o.coordDim;
            }
        }(n, a.valueDataDim)), a.baseAxis = i.getOtherAxis(a.valueAxis), a.baseDataDim = e.mapDimension(a.baseAxis.dim)) : (a.baseAxis = n.getBaseAxis(), 
        a.valueAxis = i.getOtherAxis(a.baseAxis), a.baseDataDim = e.mapDimension(a.baseAxis.dim), 
        a.valueDataDim = e.mapDimension(a.valueAxis.dim)), a;
    }
    function yf(t, e) {
        return !(t && t.containData && e.coord && (i = e, isNaN(parseFloat(i.x)) && isNaN(parseFloat(i.y)))) || t.containData(e.coord);
        var i;
    }
    function xf(t, e, i, n) {
        return n < 2 ? t.coord && t.coord[n] : t.value;
    }
    function _f(t, e, i) {
        if ("average" === i) {
            var n = 0, a = 0;
            return t.each(e, function(t, e) {
                isNaN(t) || (n += t, a++);
            }), n / a;
        }
        return "median" === i ? t.getMedian(e) : t.getDataExtent(e, !0)["max" === i ? 1 : 0];
    }
    function wf(s, l, h) {
        var u = l.coordinateSystem;
        s.each(function(t) {
            var e, i = s.getItemModel(t), n = zn(i.get("x"), h.getWidth()), a = zn(i.get("y"), h.getHeight());
            if (isNaN(n) || isNaN(a)) {
                if (l.getMarkerPosition) e = l.getMarkerPosition(s.getValues(s.dimensions, t)); else if (u) {
                    var o = s.get(u.dimensions[0], t), r = s.get(u.dimensions[1], t);
                    e = u.dataToPoint([ o, r ]);
                }
            } else e = [ n, a ];
            isNaN(n) || (e[0] = n), isNaN(a) || (e[1] = a), s.setItemLayout(t, e);
        });
    }
    function bf(t) {
        return !isNaN(t) && !isFinite(t);
    }
    function Sf(t, e, i, n) {
        var a = 1 - t, o = n.dimensions[t];
        return bf(e[a]) && bf(i[a]) && e[t] === i[t] && n.getAxis(o).containData(e[t]);
    }
    function Mf(t, e) {
        if ("cartesian2d" === t.type) {
            var i = e[0].coord, n = e[1].coord;
            if (i && n && (Sf(1, i, n, t) || Sf(0, i, n, t))) return !0;
        }
        return yf(t, e[0]) && yf(t, e[1]);
    }
    function If(t, e, i, n, a) {
        var o, r = n.coordinateSystem, s = t.getItemModel(e), l = zn(s.get("x"), a.getWidth()), h = zn(s.get("y"), a.getHeight());
        if (isNaN(l) || isNaN(h)) {
            if (n.getMarkerPosition) o = n.getMarkerPosition(t.getValues(t.dimensions, e)); else {
                var u = r.dimensions, c = t.get(u[0], e), d = t.get(u[1], e);
                o = r.dataToPoint([ c, d ]);
            }
            if ("cartesian2d" === r.type) {
                var f = r.getAxis("x"), p = r.getAxis("y");
                u = r.dimensions;
                bf(t.get(u[0], e)) ? o[0] = f.toGlobalCoord(f.getExtent()[i ? 0 : 1]) : bf(t.get(u[1], e)) && (o[1] = p.toGlobalCoord(p.getExtent()[i ? 0 : 1]));
            }
            isNaN(l) || (o[0] = l), isNaN(h) || (o[1] = h);
        } else o = [ l, h ];
        t.setItemLayout(e, o);
    }
    function Tf(t) {
        return !isNaN(t) && !isFinite(t);
    }
    function Df(t, e, i, n) {
        var a = 1 - t;
        return Tf(e[a]) && Tf(i[a]);
    }
    function Af(t, e) {
        var i = e.coord[0], n = e.coord[1];
        return !("cartesian2d" !== t.type || !i || !n || !Df(1, i, n) && !Df(0, i, n)) || yf(t, {
            coord: i,
            x: e.x0,
            y: e.y0
        }) || yf(t, {
            coord: n,
            x: e.x1,
            y: e.y1
        });
    }
    function Cf(t, e, i, n, a) {
        var o, r = n.coordinateSystem, s = t.getItemModel(e), l = zn(s.get(i[0]), a.getWidth()), h = zn(s.get(i[1]), a.getHeight());
        if (isNaN(l) || isNaN(h)) {
            if (n.getMarkerPosition) o = n.getMarkerPosition(t.getValues(i, e)); else {
                var u = [ f = t.get(i[0], e), p = t.get(i[1], e) ];
                r.clampData && r.clampData(u, u), o = r.dataToPoint(u, !0);
            }
            if ("cartesian2d" === r.type) {
                var c = r.getAxis("x"), d = r.getAxis("y"), f = t.get(i[0], e), p = t.get(i[1], e);
                Tf(f) ? o[0] = c.toGlobalCoord(c.getExtent()["x0" === i[0] ? 0 : 1]) : Tf(p) && (o[1] = d.toGlobalCoord(d.getExtent()["y0" === i[1] ? 0 : 1]));
            }
            isNaN(l) || (o[0] = l), isNaN(h) || (o[1] = h);
        } else o = [ l, h ];
        return o;
    }
    function Lf(t) {
        var e = t.itemStyle || (t.itemStyle = {}), i = e.emphasis || (e.emphasis = {}), n = t.label || t.label || {}, a = n.normal || (n.normal = {}), o = {
            normal: 1,
            emphasis: 1
        };
        R(n, function(t, e) {
            o[e] || kf(a, e) || (a[e] = t);
        }), i.label && !kf(n, "emphasis") && (n.emphasis = i.label, delete i.label);
    }
    function kf(t, e) {
        return t.hasOwnProperty(e);
    }
    function Pf(t, e, i, n, a, o) {
        var r = e.get("color");
        a ? (a.setColor(r), i.add(a), o && o.onUpdate(a)) : ((a = Rr(t.get("symbol"), -1, -1, 2, 2, r)).setStyle("strokeNoScale", !0), 
        i.add(a), o && o.onCreate(a));
        var s = e.getItemStyle([ "color", "symbol", "symbolSize" ]);
        a.setStyle(s), n = g({
            rectHover: !0,
            z2: 100
        }, n, !0);
        var l = t.get("symbolSize");
        (l = l instanceof Array ? l.slice() : [ +l, +l ])[0] /= 2, l[1] /= 2, n.scale = l;
        var h = t.get("symbolOffset");
        if (h) {
            var u = n.position = n.position || [ 0, 0 ];
            u[0] += zn(h[0], l[0]), u[1] += zn(h[1], l[1]);
        }
        var c = t.get("symbolRotate");
        return n.rotation = (c || 0) * Math.PI / 180 || 0, a.attr(n), a.updateTransform(), 
        a;
    }
    function Nf(t, e, i, n, a) {
        if (!t.dragging) {
            var o = n.getModel("checkpointStyle"), r = i.dataToCoord(n.getData().get([ "value" ], e));
            a || !o.get("animation", !0) ? t.attr({
                position: [ r, 0 ]
            }) : (t.stopAnimation(!0), t.animateTo({
                position: [ r, 0 ]
            }, o.get("animationDuration", !0), o.get("animationEasing", !0)));
        }
    }
    function Of(t) {
        this.model = t;
    }
    function Ef(t) {
        this.model = t;
    }
    function Rf(t) {
        var a, o, r, e, i, u, n = (a = {}, o = [], r = [], t.eachRawSeries(function(t) {
            var e = t.coordinateSystem;
            if (!e || "cartesian2d" !== e.type && "polar" !== e.type) o.push(t); else {
                var i = e.getBaseAxis();
                if ("category" === i.type) {
                    var n = i.dim + "_" + i.index;
                    a[n] || (a[n] = {
                        categoryAxis: i,
                        valueAxis: e.getOtherAxis(i),
                        series: []
                    }, r.push({
                        axisDim: i.dim,
                        axisIndex: i.index
                    })), a[n].series.push(t);
                } else o.push(t);
            }
        }), {
            seriesGroupByCategoryAxis: a,
            other: o,
            meta: r
        });
        return {
            value: I([ (i = n.seriesGroupByCategoryAxis, u = [], R(i, function(t, e) {
                var i = t.categoryAxis, n = t.valueAxis.dim, a = [ " " ].concat(L(t.series, function(t) {
                    return t.name;
                })), o = [ i.model.getCategories() ];
                R(t.series, function(t) {
                    o.push(t.getRawData().mapArray(n, function(t) {
                        return t;
                    }));
                });
                for (var r = [ a.join($D) ], s = 0; s < o[0].length; s++) {
                    for (var l = [], h = 0; h < o.length; h++) l.push(o[h][s]);
                    r.push(l.join($D));
                }
                u.push(r.join("\n"));
            }), u.join("\n\n" + KD + "\n\n")), (e = n.other, L(e, function(t) {
                var a = t.getRawData(), o = [ t.name ], r = [];
                return a.each(a.dimensions, function() {
                    for (var t = arguments.length, e = arguments[t - 1], i = a.getName(e), n = 0; n < t - 1; n++) r[n] = arguments[n];
                    o.push((i ? i + $D : "") + r.join($D));
                }), o.join("\n");
            }).join("\n\n" + KD + "\n\n")) ], function(t) {
                return t.replace(/[\n\t\s]/g, "");
            }).join("\n\n" + KD + "\n\n"),
            meta: n.meta
        };
    }
    function zf(t) {
        return t.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
    }
    function Bf(t, o) {
        var r = {
            series: []
        };
        return R(t.split(new RegExp("\n*" + KD + "\n*", "g")), function(t, e) {
            if (function(t) {
                if (0 <= t.slice(0, t.indexOf("\n")).indexOf($D)) return !0;
            }(t)) {
                var i = function(t) {
                    for (var e = t.split(/\n+/g), i = [], n = L(zf(e.shift()).split(JD), function(t) {
                        return {
                            name: t,
                            data: []
                        };
                    }), a = 0; a < e.length; a++) {
                        var o = zf(e[a]).split(JD);
                        i.push(o.shift());
                        for (var r = 0; r < o.length; r++) n[r] && (n[r].data[a] = o[r]);
                    }
                    return {
                        series: n,
                        categories: i
                    };
                }(t), n = o[e], a = n.axisDim + "Axis";
                n && (r[a] = r[a] || [], r[a][n.axisIndex] = {
                    data: i.categories
                }, r.series = r.series.concat(i.series));
            } else i = function(t) {
                for (var e = t.split(/\n+/g), i = zf(e.shift()), n = [], a = 0; a < e.length; a++) {
                    var o, r = zf(e[a]).split(JD), s = "", l = !1;
                    isNaN(r[0]) ? (l = !0, s = r[0], r = r.slice(1), n[a] = {
                        name: s,
                        value: []
                    }, o = n[a].value) : o = n[a] = [];
                    for (var h = 0; h < r.length; h++) o.push(+r[h]);
                    1 === o.length && (l ? n[a].value = o[0] : n[a] = o[0]);
                }
                return {
                    name: i,
                    data: n
                };
            }(t), r.series.push(i);
        }), r;
    }
    function Vf(t) {
        this._dom = null, this.model = t;
    }
    function Gf(t) {
        var e = t[tA];
        return e || (e = t[tA] = [ {} ]), e;
    }
    function Wf(t, e, i) {
        (this._brushController = new kh(i.getZr())).on("brush", _(this._onBrush, this)).mount(), 
        this._isZoomActive;
    }
    function Ff(e) {
        var i = {};
        return R([ "xAxisIndex", "yAxisIndex" ], function(t) {
            i[t] = e[t], null == i[t] && (i[t] = "all"), (!1 === i[t] || "none" === i[t]) && (i[t] = []);
        }), i;
    }
    function Hf(t, e) {
        t.setIconStatus("back", 1 < Gf(e).length ? "emphasis" : "normal");
    }
    function Zf(t) {
        this.model = t;
    }
    function Uf(t) {
        return rA(t);
    }
    function jf(t) {
        return parseInt(t, 10);
    }
    function Xf(t, e) {
        (function() {
            if (!hA && uA) {
                hA = !0;
                var t = uA.styleSheets;
                t.length < 31 ? uA.createStyleSheet().addRule(".zrvml", "behavior:url(#default#VML)") : t[0].addRule(".zrvml", "behavior:url(#default#VML)");
            }
        })(), this.root = t, this.storage = e;
        var i = document.createElement("div"), n = document.createElement("div");
        i.style.cssText = "display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;", 
        n.style.cssText = "position:absolute;left:0;top:0;", t.appendChild(i), this._vmlRoot = n, 
        this._vmlViewport = i, this.resize();
        var a = e.delFromStorage, o = e.addToStorage;
        e.delFromStorage = function(t) {
            a.call(e, t), t && t.onRemove && t.onRemove(n);
        }, e.addToStorage = function(t) {
            t.onAdd && t.onAdd(n), o.call(e, t);
        }, this._firstPaint = !0;
    }
    function Yf(t) {
        return document.createElementNS("http://www.w3.org/2000/svg", t);
    }
    function qf(t) {
        return WA(1e4 * t) / 1e4;
    }
    function Kf(t) {
        return t < XA && -XA < t;
    }
    function $f(t, e) {
        e && Jf(t, "transform", "matrix(" + VA.call(e, ",") + ")");
    }
    function Jf(t, e, i) {
        (!i || "linear" !== i.type && "radial" !== i.type) && t.setAttribute(e, i);
    }
    function Qf(t, e, i) {
        if (a = e, null != (o = i ? a.textFill : a.fill) && o !== GA) {
            var n = i ? e.textFill : e.fill;
            n = "transparent" === n ? GA : n, "none" !== t.getAttribute("clip-path") && n === GA && (n = "rgba(0, 0, 0, 0.002)"), 
            Jf(t, "fill", n), Jf(t, "fill-opacity", e.opacity);
        } else Jf(t, "fill", GA);
        var a, o, r, s;
        if (r = e, null != (s = i ? r.textStroke : r.stroke) && s !== GA) {
            var l = i ? e.textStroke : e.stroke;
            Jf(t, "stroke", l = "transparent" === l ? GA : l), Jf(t, "stroke-width", (i ? e.textStrokeWidth : e.lineWidth) / (!i && e.strokeNoScale ? e.host.getLineScale() : 1)), 
            Jf(t, "paint-order", i ? "stroke" : "fill"), Jf(t, "stroke-opacity", e.opacity), 
            e.lineDash ? (Jf(t, "stroke-dasharray", e.lineDash.join(",")), Jf(t, "stroke-dashoffset", WA(e.lineDashOffset || 0))) : Jf(t, "stroke-dasharray", ""), 
            e.lineCap && Jf(t, "stroke-linecap", e.lineCap), e.lineJoin && Jf(t, "stroke-linejoin", e.lineJoin), 
            e.miterLimit && Jf(t, "stroke-miterlimit", e.miterLimit);
        } else Jf(t, "stroke", GA);
    }
    function tp(t) {
        return "middle" === t ? "middle" : "bottom" === t ? "baseline" : "hanging";
    }
    function ep() {}
    function ip(t, e, i, n) {
        for (var a = 0, o = e.length, r = 0, s = 0; a < o; a++) {
            var l = e[a];
            if (l.removed) {
                for (var h = [], u = s; u < s + l.count; u++) h.push(u);
                l.indices = h, s += l.count;
            } else {
                for (h = [], u = r; u < r + l.count; u++) h.push(u);
                l.indices = h, r += l.count, l.added || (s += l.count);
            }
        }
        return e;
    }
    function np(t, e, i, n, a) {
        this._zrId = t, this._svgRoot = e, this._tagNames = "string" == typeof i ? [ i ] : i, 
        this._markLabel = n, this._domName = a || "_dom", this.nextId = 0;
    }
    function ap(t, e) {
        np.call(this, t, e, [ "linearGradient", "radialGradient" ], "__gradient_in_use__");
    }
    function op(t, e) {
        np.call(this, t, e, "clipPath", "__clippath_in_use__");
    }
    function rp(t, e) {
        np.call(this, t, e, [ "filter" ], "__filter_in_use__", "_shadowDom");
    }
    function sp(t) {
        return t && (t.shadowBlur || t.shadowOffsetX || t.shadowOffsetY || t.textShadowBlur || t.textShadowOffsetX || t.textShadowOffsetY);
    }
    function lp(t) {
        return parseInt(t, 10);
    }
    function hp(t, e) {
        return e && t && e.parentNode !== t;
    }
    function up(t, e, i) {
        if (hp(t, e) && i) {
            var n = i.nextSibling;
            n ? t.insertBefore(e, n) : t.appendChild(e);
        }
    }
    function cp(t, e) {
        if (hp(t, e)) {
            var i = t.firstChild;
            i ? t.insertBefore(e, i) : t.appendChild(e);
        }
    }
    function dp(t, e) {
        e && t && e.parentNode === t && t.removeChild(e);
    }
    function fp(t) {
        return t.__textSvgEl;
    }
    function pp(t) {
        return t.__svgEl;
    }
    var gp, mp, vp, yp, xp, _p, wp = 2311, bp = function() {
        return wp++;
    }, Sp = "object" == ("undefined" == typeof wx ? "undefined" : _typeof(wx)) && "function" == typeof wx.getSystemInfoSync ? {
        browser: {},
        os: {},
        node: !1,
        wxa: !0,
        canvasSupported: !0,
        svgSupported: !1,
        touchEventsSupported: !0
    } : "undefined" == typeof document && "undefined" != typeof self ? {
        browser: {},
        os: {},
        node: !1,
        worker: !0,
        canvasSupported: !0
    } : "undefined" == typeof navigator ? {
        browser: {},
        os: {},
        node: !0,
        worker: !1,
        canvasSupported: !0,
        svgSupported: !0
    } : (gp = navigator.userAgent, mp = {}, vp = gp.match(/Firefox\/([\d.]+)/), yp = gp.match(/MSIE\s([\d.]+)/) || gp.match(/Trident\/.+?rv:(([\d.]+))/), 
    xp = gp.match(/Edge\/([\d.]+)/), _p = /micromessenger/i.test(gp), vp && (mp.firefox = !0, 
    mp.version = vp[1]), yp && (mp.ie = !0, mp.version = yp[1]), xp && (mp.edge = !0, 
    mp.version = xp[1]), _p && (mp.weChat = !0), {
        browser: mp,
        os: {},
        node: !1,
        canvasSupported: !!document.createElement("canvas").getContext,
        svgSupported: "undefined" != typeof SVGRect,
        touchEventsSupported: "ontouchstart" in window && !mp.ie && !mp.edge,
        pointerEventsSupported: "onpointerdown" in window && (mp.edge || mp.ie && 11 <= mp.version)
    }), Mp = {
        "[object Function]": 1,
        "[object RegExp]": 1,
        "[object Date]": 1,
        "[object Error]": 1,
        "[object CanvasGradient]": 1,
        "[object CanvasPattern]": 1,
        "[object Image]": 1,
        "[object Canvas]": 1
    }, Ip = {
        "[object Int8Array]": 1,
        "[object Uint8Array]": 1,
        "[object Uint8ClampedArray]": 1,
        "[object Int16Array]": 1,
        "[object Uint16Array]": 1,
        "[object Int32Array]": 1,
        "[object Uint32Array]": 1,
        "[object Float32Array]": 1,
        "[object Float64Array]": 1
    }, Tp = Object.prototype.toString, Dp = Array.prototype, Ap = Dp.forEach, Cp = Dp.filter, Lp = Dp.slice, kp = Dp.map, Pp = Dp.reduce, Np = {}, Op = function() {
        return Np.createCanvas();
    };
    Np.createCanvas = function() {
        return document.createElement("canvas");
    };
    var Ep, Rp = "__ec_primitive__";
    x.prototype = {
        constructor: x,
        get: function(t) {
            return this.hasOwnProperty(t) ? this[t] : null;
        },
        set: function(t, e) {
            return this[t] = e;
        },
        each: function(t, e) {
            for (var i in void 0 !== e && (t = _(t, e)), this) this.hasOwnProperty(i) && t(this[i], i);
        },
        removeKey: function(t) {
            delete this[t];
        }
    };
    var zp = (Object.freeze || Object)({
        $override: e,
        clone: A,
        merge: g,
        mergeAll: u,
        extend: P,
        defaults: E,
        createCanvas: Op,
        getContext: n,
        indexOf: C,
        inherits: o,
        mixin: a,
        isArrayLike: O,
        each: R,
        map: L,
        reduce: p,
        filter: I,
        find: function(t, e, i) {
            if (t && e) for (var n = 0, a = t.length; n < a; n++) if (e.call(i, t[n], n, t)) return t[n];
        },
        bind: _,
        curry: z,
        isArray: N,
        isFunction: m,
        isString: b,
        isObject: B,
        isBuiltInObject: r,
        isTypedArray: v,
        isDom: w,
        eqNaN: y,
        retrieve: V,
        retrieve2: k,
        retrieve3: G,
        slice: s,
        normalizeCssArray: l,
        assert: c,
        trim: h,
        setAsPrimitive: d,
        isPrimitive: f,
        createHashMap: W,
        concatArray: i,
        noop: S
    }), Bp = "undefined" == typeof Float32Array ? Array : Float32Array, Vp = j, Gp = X, Wp = K, Fp = $, Hp = (Object.freeze || Object)({
        create: M,
        copy: T,
        clone: D,
        set: F,
        add: H,
        scaleAndAdd: Z,
        sub: U,
        len: j,
        length: Vp,
        lenSquare: X,
        lengthSquare: Gp,
        mul: function(t, e, i) {
            return t[0] = e[0] * i[0], t[1] = e[1] * i[1], t;
        },
        div: function(t, e, i) {
            return t[0] = e[0] / i[0], t[1] = e[1] / i[1], t;
        },
        dot: function(t, e) {
            return t[0] * e[0] + t[1] * e[1];
        },
        scale: Y,
        normalize: q,
        distance: K,
        dist: Wp,
        distanceSquare: $,
        distSquare: Fp,
        negate: function(t, e) {
            return t[0] = -e[0], t[1] = -e[1], t;
        },
        lerp: J,
        applyTransform: Q,
        min: tt,
        max: et
    });
    it.prototype = {
        constructor: it,
        _dragStart: function(t) {
            var e = t.target;
            e && e.draggable && ((this._draggingTarget = e).dragging = !0, this._x = t.offsetX, 
            this._y = t.offsetY, this.dispatchToElement(nt(e, t), "dragstart", t.event));
        },
        _drag: function(t) {
            var e = this._draggingTarget;
            if (e) {
                var i = t.offsetX, n = t.offsetY, a = i - this._x, o = n - this._y;
                this._x = i, this._y = n, e.drift(a, o, t), this.dispatchToElement(nt(e, t), "drag", t.event);
                var r = this.findHover(i, n, e).target, s = this._dropTarget;
                e !== (this._dropTarget = r) && (s && r !== s && this.dispatchToElement(nt(s, t), "dragleave", t.event), 
                r && r !== s && this.dispatchToElement(nt(r, t), "dragenter", t.event));
            }
        },
        _dragEnd: function(t) {
            var e = this._draggingTarget;
            e && (e.dragging = !1), this.dispatchToElement(nt(e, t), "dragend", t.event), this._dropTarget && this.dispatchToElement(nt(this._dropTarget, t), "drop", t.event), 
            this._draggingTarget = null, this._dropTarget = null;
        }
    };
    var Zp = Array.prototype.slice, Up = function() {
        this._$handlers = {};
    };
    Up.prototype = {
        constructor: Up,
        one: function(t, e, i) {
            var n = this._$handlers;
            if (!e || !t) return this;
            n[t] || (n[t] = []);
            for (var a = 0; a < n[t].length; a++) if (n[t][a].h === e) return this;
            return n[t].push({
                h: e,
                one: !0,
                ctx: i || this
            }), this;
        },
        on: function(t, e, i) {
            var n = this._$handlers;
            if (!e || !t) return this;
            n[t] || (n[t] = []);
            for (var a = 0; a < n[t].length; a++) if (n[t][a].h === e) return this;
            return n[t].push({
                h: e,
                one: !1,
                ctx: i || this
            }), this;
        },
        isSilent: function(t) {
            var e = this._$handlers;
            return e[t] && e[t].length;
        },
        off: function(t, e) {
            var i = this._$handlers;
            if (!t) return this._$handlers = {}, this;
            if (e) {
                if (i[t]) {
                    for (var n = [], a = 0, o = i[t].length; a < o; a++) i[t][a].h != e && n.push(i[t][a]);
                    i[t] = n;
                }
                i[t] && 0 === i[t].length && delete i[t];
            } else delete i[t];
            return this;
        },
        trigger: function(t) {
            if (this._$handlers[t]) {
                var e = arguments, i = e.length;
                3 < i && (e = Zp.call(e, 1));
                for (var n = this._$handlers[t], a = n.length, o = 0; o < a; ) {
                    switch (i) {
                      case 1:
                        n[o].h.call(n[o].ctx);
                        break;

                      case 2:
                        n[o].h.call(n[o].ctx, e[1]);
                        break;

                      case 3:
                        n[o].h.call(n[o].ctx, e[1], e[2]);
                        break;

                      default:
                        n[o].h.apply(n[o].ctx, e);
                    }
                    n[o].one ? (n.splice(o, 1), a--) : o++;
                }
            }
            return this;
        },
        triggerWithContext: function(t) {
            if (this._$handlers[t]) {
                var e = arguments, i = e.length;
                4 < i && (e = Zp.call(e, 1, e.length - 1));
                for (var n = e[e.length - 1], a = this._$handlers[t], o = a.length, r = 0; r < o; ) {
                    switch (i) {
                      case 1:
                        a[r].h.call(n);
                        break;

                      case 2:
                        a[r].h.call(n, e[1]);
                        break;

                      case 3:
                        a[r].h.call(n, e[1], e[2]);
                        break;

                      default:
                        a[r].h.apply(n, e);
                    }
                    a[r].one ? (a.splice(r, 1), o--) : r++;
                }
            }
            return this;
        }
    };
    var jp = "silent";
    at.prototype.dispose = function() {};
    var Xp = [ "click", "dblclick", "mousewheel", "mouseout", "mouseup", "mousedown", "mousemove", "contextmenu" ], Yp = function(t, e, i, n) {
        Up.call(this), this.storage = t, this.painter = e, this.painterRoot = n, i = i || new at(), 
        this.proxy = null, this._hovered = {}, this._lastTouchMoment, this._lastX, this._lastY, 
        it.call(this), this.setHandlerProxy(i);
    };
    Yp.prototype = {
        constructor: Yp,
        setHandlerProxy: function(e) {
            this.proxy && this.proxy.dispose(), e && (R(Xp, function(t) {
                e.on && e.on(t, this[t], this);
            }, this), e.handler = this), this.proxy = e;
        },
        mousemove: function(t) {
            var e = t.zrX, i = t.zrY, n = this._hovered, a = n.target;
            a && !a.__zr && (a = (n = this.findHover(n.x, n.y)).target);
            var o = this._hovered = this.findHover(e, i), r = o.target, s = this.proxy;
            s.setCursor && s.setCursor(r ? r.cursor : "default"), a && r !== a && this.dispatchToElement(n, "mouseout", t), 
            this.dispatchToElement(o, "mousemove", t), r && r !== a && this.dispatchToElement(o, "mouseover", t);
        },
        mouseout: function(t) {
            this.dispatchToElement(this._hovered, "mouseout", t);
            for (var e, i = t.toElement || t.relatedTarget; (i = i && i.parentNode) && 9 != i.nodeType && !(e = i === this.painterRoot); ) ;
            !e && this.trigger("globalout", {
                event: t
            });
        },
        resize: function(t) {
            this._hovered = {};
        },
        dispatch: function(t, e) {
            var i = this[t];
            i && i.call(this, e);
        },
        dispose: function() {
            this.proxy.dispose(), this.storage = this.proxy = this.painter = null;
        },
        setCursorStyle: function(t) {
            var e = this.proxy;
            e.setCursor && e.setCursor(t);
        },
        dispatchToElement: function(t, e, i) {
            var n, a, o = (t = t || {}).target;
            if (!o || !o.silent) {
                for (var r = "on" + e, s = {
                    type: e,
                    event: a = i,
                    target: (n = t).target,
                    topTarget: n.topTarget,
                    cancelBubble: !1,
                    offsetX: a.zrX,
                    offsetY: a.zrY,
                    gestureEvent: a.gestureEvent,
                    pinchX: a.pinchX,
                    pinchY: a.pinchY,
                    pinchScale: a.pinchScale,
                    wheelDelta: a.zrDelta,
                    zrByTouch: a.zrByTouch,
                    which: a.which
                }; o && (o[r] && (s.cancelBubble = o[r].call(o, s)), o.trigger(e, s), o = o.parent, 
                !s.cancelBubble); ) ;
                s.cancelBubble || (this.trigger(e, s), this.painter && this.painter.eachOtherLayer(function(t) {
                    "function" == typeof t[r] && t[r].call(t, s), t.trigger && t.trigger(e, s);
                }));
            }
        },
        findHover: function(t, e, i) {
            for (var n = this.storage.getDisplayList(), a = {
                x: t,
                y: e
            }, o = n.length - 1; 0 <= o; o--) {
                var r;
                if (n[o] !== i && !n[o].ignore && (r = ot(n[o], t, e)) && (!a.topTarget && (a.topTarget = n[o]), 
                r !== jp)) {
                    a.target = n[o];
                    break;
                }
            }
            return a;
        }
    }, R([ "click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu" ], function(n) {
        Yp.prototype[n] = function(t) {
            var e = this.findHover(t.zrX, t.zrY), i = e.target;
            if ("mousedown" === n) this._downEl = i, this._downPoint = [ t.zrX, t.zrY ], this._upEl = i; else if ("mouseup" === n) this._upEl = i; else if ("click" === n) {
                if (this._downEl !== this._upEl || !this._downPoint || 4 < Wp(this._downPoint, [ t.zrX, t.zrY ])) return;
                this._downPoint = null;
            }
            this.dispatchToElement(e, n, t);
        };
    }), a(Yp, Up), a(Yp, it);
    var qp = "undefined" == typeof Float32Array ? Array : Float32Array, Kp = (Object.freeze || Object)({
        create: rt,
        identity: st,
        copy: lt,
        mul: ht,
        translate: ut,
        rotate: ct,
        scale: dt,
        invert: ft,
        clone: pt
    }), $p = st, Jp = function(t) {
        (t = t || {}).position || (this.position = [ 0, 0 ]), null == t.rotation && (this.rotation = 0), 
        t.scale || (this.scale = [ 1, 1 ]), this.origin = this.origin || null;
    }, Qp = Jp.prototype;
    Qp.transform = null, Qp.needLocalTransform = function() {
        return gt(this.rotation) || gt(this.position[0]) || gt(this.position[1]) || gt(this.scale[0] - 1) || gt(this.scale[1] - 1);
    }, Qp.updateTransform = function() {
        var t = this.parent, e = t && t.transform, i = this.needLocalTransform(), n = this.transform;
        i || e ? (n = n || rt(), i ? this.getLocalTransform(n) : $p(n), e && (i ? ht(n, t.transform, n) : lt(n, t.transform)), 
        this.transform = n, this.invTransform = this.invTransform || rt(), ft(this.invTransform, n)) : n && $p(n);
    }, Qp.getLocalTransform = function(t) {
        return Jp.getLocalTransform(this, t);
    }, Qp.setTransform = function(t) {
        var e = this.transform, i = t.dpr || 1;
        e ? t.setTransform(i * e[0], i * e[1], i * e[2], i * e[3], i * e[4], i * e[5]) : t.setTransform(i, 0, 0, i, 0, 0);
    }, Qp.restoreTransform = function(t) {
        var e = t.dpr || 1;
        t.setTransform(e, 0, 0, e, 0, 0);
    };
    var tg = [];
    Qp.decomposeTransform = function() {
        if (this.transform) {
            var t = this.parent, e = this.transform;
            t && t.transform && (ht(tg, t.invTransform, e), e = tg);
            var i = e[0] * e[0] + e[1] * e[1], n = e[2] * e[2] + e[3] * e[3], a = this.position, o = this.scale;
            gt(i - 1) && (i = Math.sqrt(i)), gt(n - 1) && (n = Math.sqrt(n)), e[0] < 0 && (i = -i), 
            e[3] < 0 && (n = -n), a[0] = e[4], a[1] = e[5], o[0] = i, o[1] = n, this.rotation = Math.atan2(-e[1] / n, e[0] / i);
        }
    }, Qp.getGlobalScale = function() {
        var t = this.transform;
        if (!t) return [ 1, 1 ];
        var e = Math.sqrt(t[0] * t[0] + t[1] * t[1]), i = Math.sqrt(t[2] * t[2] + t[3] * t[3]);
        return t[0] < 0 && (e = -e), t[3] < 0 && (i = -i), [ e, i ];
    }, Qp.transformCoordToLocal = function(t, e) {
        var i = [ t, e ], n = this.invTransform;
        return n && Q(i, i, n), i;
    }, Qp.transformCoordToGlobal = function(t, e) {
        var i = [ t, e ], n = this.transform;
        return n && Q(i, i, n), i;
    }, Jp.getLocalTransform = function(t, e) {
        $p(e = e || []);
        var i = t.origin, n = t.scale || [ 1, 1 ], a = t.rotation || 0, o = t.position || [ 0, 0 ];
        return i && (e[4] -= i[0], e[5] -= i[1]), dt(e, e, n), a && ct(e, e, a), i && (e[4] += i[0], 
        e[5] += i[1]), e[4] += o[0], e[5] += o[1], e;
    };
    var eg = {
        linear: function(t) {
            return t;
        },
        quadraticIn: function(t) {
            return t * t;
        },
        quadraticOut: function(t) {
            return t * (2 - t);
        },
        quadraticInOut: function(t) {
            return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1);
        },
        cubicIn: function(t) {
            return t * t * t;
        },
        cubicOut: function(t) {
            return --t * t * t + 1;
        },
        cubicInOut: function(t) {
            return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2);
        },
        quarticIn: function(t) {
            return t * t * t * t;
        },
        quarticOut: function(t) {
            return 1 - --t * t * t * t;
        },
        quarticInOut: function(t) {
            return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2);
        },
        quinticIn: function(t) {
            return t * t * t * t * t;
        },
        quinticOut: function(t) {
            return --t * t * t * t * t + 1;
        },
        quinticInOut: function(t) {
            return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2);
        },
        sinusoidalIn: function(t) {
            return 1 - Math.cos(t * Math.PI / 2);
        },
        sinusoidalOut: function(t) {
            return Math.sin(t * Math.PI / 2);
        },
        sinusoidalInOut: function(t) {
            return .5 * (1 - Math.cos(Math.PI * t));
        },
        exponentialIn: function(t) {
            return 0 === t ? 0 : Math.pow(1024, t - 1);
        },
        exponentialOut: function(t) {
            return 1 === t ? 1 : 1 - Math.pow(2, -10 * t);
        },
        exponentialInOut: function(t) {
            return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (2 - Math.pow(2, -10 * (t - 1)));
        },
        circularIn: function(t) {
            return 1 - Math.sqrt(1 - t * t);
        },
        circularOut: function(t) {
            return Math.sqrt(1 - --t * t);
        },
        circularInOut: function(t) {
            return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
        },
        elasticIn: function(t) {
            var e, i = .1;
            return 0 === t ? 0 : 1 === t ? 1 : (!i || i < 1 ? (i = 1, e = .1) : e = .4 * Math.asin(1 / i) / (2 * Math.PI), 
            -i * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / .4));
        },
        elasticOut: function(t) {
            var e, i = .1;
            return 0 === t ? 0 : 1 === t ? 1 : (!i || i < 1 ? (i = 1, e = .1) : e = .4 * Math.asin(1 / i) / (2 * Math.PI), 
            i * Math.pow(2, -10 * t) * Math.sin((t - e) * (2 * Math.PI) / .4) + 1);
        },
        elasticInOut: function(t) {
            var e, i = .1;
            return 0 === t ? 0 : 1 === t ? 1 : (!i || i < 1 ? (i = 1, e = .1) : e = .4 * Math.asin(1 / i) / (2 * Math.PI), 
            (t *= 2) < 1 ? i * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / .4) * -.5 : i * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / .4) * .5 + 1);
        },
        backIn: function(t) {
            return t * t * (2.70158 * t - 1.70158);
        },
        backOut: function(t) {
            return --t * t * (2.70158 * t + 1.70158) + 1;
        },
        backInOut: function(t) {
            var e = 2.5949095;
            return (t *= 2) < 1 ? t * t * ((e + 1) * t - e) * .5 : .5 * ((t -= 2) * t * ((e + 1) * t + e) + 2);
        },
        bounceIn: function(t) {
            return 1 - eg.bounceOut(1 - t);
        },
        bounceOut: function(t) {
            return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
        },
        bounceInOut: function(t) {
            return t < .5 ? .5 * eg.bounceIn(2 * t) : .5 * eg.bounceOut(2 * t - 1) + .5;
        }
    };
    mt.prototype = {
        constructor: mt,
        step: function(t, e) {
            if (this._initialized || (this._startTime = t + this._delay, this._initialized = !0), 
            this._paused) this._pausedTime += e; else {
                var i = (t - this._startTime - this._pausedTime) / this._life;
                if (!(i < 0)) {
                    i = Math.min(i, 1);
                    var n = this.easing, a = "string" == typeof n ? eg[n] : n, o = "function" == typeof a ? a(i) : i;
                    return this.fire("frame", o), 1 == i ? this.loop ? (this.restart(t), "restart") : (this._needsRemove = !0, 
                    "destroy") : null;
                }
            }
        },
        restart: function(t) {
            var e = (t - this._startTime - this._pausedTime) % this._life;
            this._startTime = t - e + this.gap, this._pausedTime = 0, this._needsRemove = !1;
        },
        fire: function(t, e) {
            this[t = "on" + t] && this[t](this._target, e);
        },
        pause: function() {
            this._paused = !0;
        },
        resume: function() {
            this._paused = !1;
        }
    };
    var ig = function() {
        this.head = null, this.tail = null, this._len = 0;
    }, ng = ig.prototype;
    ng.insert = function(t) {
        var e = new ag(t);
        return this.insertEntry(e), e;
    }, ng.insertEntry = function(t) {
        this.head ? ((this.tail.next = t).prev = this.tail, t.next = null, this.tail = t) : this.head = this.tail = t, 
        this._len++;
    }, ng.remove = function(t) {
        var e = t.prev, i = t.next;
        e ? e.next = i : this.head = i, i ? i.prev = e : this.tail = e, t.next = t.prev = null, 
        this._len--;
    }, ng.len = function() {
        return this._len;
    }, ng.clear = function() {
        this.head = this.tail = null, this._len = 0;
    };
    var ag = function(t) {
        this.value = t, this.next, this.prev;
    }, og = function(t) {
        this._list = new ig(), this._map = {}, this._maxSize = t || 10, this._lastRemovedEntry = null;
    }, rg = og.prototype;
    rg.put = function(t, e) {
        var i = this._list, n = this._map, a = null;
        if (null == n[t]) {
            var o = i.len(), r = this._lastRemovedEntry;
            if (o >= this._maxSize && 0 < o) {
                var s = i.head;
                i.remove(s), delete n[s.key], a = s.value, this._lastRemovedEntry = s;
            }
            r ? r.value = e : r = new ag(e), r.key = t, i.insertEntry(r), n[t] = r;
        }
        return a;
    }, rg.get = function(t) {
        var e = this._map[t], i = this._list;
        if (null != e) return e !== i.tail && (i.remove(e), i.insertEntry(e)), e.value;
    }, rg.clear = function() {
        this._list.clear(), this._map = {};
    };
    var sg = {
        transparent: [ 0, 0, 0, 0 ],
        aliceblue: [ 240, 248, 255, 1 ],
        antiquewhite: [ 250, 235, 215, 1 ],
        aqua: [ 0, 255, 255, 1 ],
        aquamarine: [ 127, 255, 212, 1 ],
        azure: [ 240, 255, 255, 1 ],
        beige: [ 245, 245, 220, 1 ],
        bisque: [ 255, 228, 196, 1 ],
        black: [ 0, 0, 0, 1 ],
        blanchedalmond: [ 255, 235, 205, 1 ],
        blue: [ 0, 0, 255, 1 ],
        blueviolet: [ 138, 43, 226, 1 ],
        brown: [ 165, 42, 42, 1 ],
        burlywood: [ 222, 184, 135, 1 ],
        cadetblue: [ 95, 158, 160, 1 ],
        chartreuse: [ 127, 255, 0, 1 ],
        chocolate: [ 210, 105, 30, 1 ],
        coral: [ 255, 127, 80, 1 ],
        cornflowerblue: [ 100, 149, 237, 1 ],
        cornsilk: [ 255, 248, 220, 1 ],
        crimson: [ 220, 20, 60, 1 ],
        cyan: [ 0, 255, 255, 1 ],
        darkblue: [ 0, 0, 139, 1 ],
        darkcyan: [ 0, 139, 139, 1 ],
        darkgoldenrod: [ 184, 134, 11, 1 ],
        darkgray: [ 169, 169, 169, 1 ],
        darkgreen: [ 0, 100, 0, 1 ],
        darkgrey: [ 169, 169, 169, 1 ],
        darkkhaki: [ 189, 183, 107, 1 ],
        darkmagenta: [ 139, 0, 139, 1 ],
        darkolivegreen: [ 85, 107, 47, 1 ],
        darkorange: [ 255, 140, 0, 1 ],
        darkorchid: [ 153, 50, 204, 1 ],
        darkred: [ 139, 0, 0, 1 ],
        darksalmon: [ 233, 150, 122, 1 ],
        darkseagreen: [ 143, 188, 143, 1 ],
        darkslateblue: [ 72, 61, 139, 1 ],
        darkslategray: [ 47, 79, 79, 1 ],
        darkslategrey: [ 47, 79, 79, 1 ],
        darkturquoise: [ 0, 206, 209, 1 ],
        darkviolet: [ 148, 0, 211, 1 ],
        deeppink: [ 255, 20, 147, 1 ],
        deepskyblue: [ 0, 191, 255, 1 ],
        dimgray: [ 105, 105, 105, 1 ],
        dimgrey: [ 105, 105, 105, 1 ],
        dodgerblue: [ 30, 144, 255, 1 ],
        firebrick: [ 178, 34, 34, 1 ],
        floralwhite: [ 255, 250, 240, 1 ],
        forestgreen: [ 34, 139, 34, 1 ],
        fuchsia: [ 255, 0, 255, 1 ],
        gainsboro: [ 220, 220, 220, 1 ],
        ghostwhite: [ 248, 248, 255, 1 ],
        gold: [ 255, 215, 0, 1 ],
        goldenrod: [ 218, 165, 32, 1 ],
        gray: [ 128, 128, 128, 1 ],
        green: [ 0, 128, 0, 1 ],
        greenyellow: [ 173, 255, 47, 1 ],
        grey: [ 128, 128, 128, 1 ],
        honeydew: [ 240, 255, 240, 1 ],
        hotpink: [ 255, 105, 180, 1 ],
        indianred: [ 205, 92, 92, 1 ],
        indigo: [ 75, 0, 130, 1 ],
        ivory: [ 255, 255, 240, 1 ],
        khaki: [ 240, 230, 140, 1 ],
        lavender: [ 230, 230, 250, 1 ],
        lavenderblush: [ 255, 240, 245, 1 ],
        lawngreen: [ 124, 252, 0, 1 ],
        lemonchiffon: [ 255, 250, 205, 1 ],
        lightblue: [ 173, 216, 230, 1 ],
        lightcoral: [ 240, 128, 128, 1 ],
        lightcyan: [ 224, 255, 255, 1 ],
        lightgoldenrodyellow: [ 250, 250, 210, 1 ],
        lightgray: [ 211, 211, 211, 1 ],
        lightgreen: [ 144, 238, 144, 1 ],
        lightgrey: [ 211, 211, 211, 1 ],
        lightpink: [ 255, 182, 193, 1 ],
        lightsalmon: [ 255, 160, 122, 1 ],
        lightseagreen: [ 32, 178, 170, 1 ],
        lightskyblue: [ 135, 206, 250, 1 ],
        lightslategray: [ 119, 136, 153, 1 ],
        lightslategrey: [ 119, 136, 153, 1 ],
        lightsteelblue: [ 176, 196, 222, 1 ],
        lightyellow: [ 255, 255, 224, 1 ],
        lime: [ 0, 255, 0, 1 ],
        limegreen: [ 50, 205, 50, 1 ],
        linen: [ 250, 240, 230, 1 ],
        magenta: [ 255, 0, 255, 1 ],
        maroon: [ 128, 0, 0, 1 ],
        mediumaquamarine: [ 102, 205, 170, 1 ],
        mediumblue: [ 0, 0, 205, 1 ],
        mediumorchid: [ 186, 85, 211, 1 ],
        mediumpurple: [ 147, 112, 219, 1 ],
        mediumseagreen: [ 60, 179, 113, 1 ],
        mediumslateblue: [ 123, 104, 238, 1 ],
        mediumspringgreen: [ 0, 250, 154, 1 ],
        mediumturquoise: [ 72, 209, 204, 1 ],
        mediumvioletred: [ 199, 21, 133, 1 ],
        midnightblue: [ 25, 25, 112, 1 ],
        mintcream: [ 245, 255, 250, 1 ],
        mistyrose: [ 255, 228, 225, 1 ],
        moccasin: [ 255, 228, 181, 1 ],
        navajowhite: [ 255, 222, 173, 1 ],
        navy: [ 0, 0, 128, 1 ],
        oldlace: [ 253, 245, 230, 1 ],
        olive: [ 128, 128, 0, 1 ],
        olivedrab: [ 107, 142, 35, 1 ],
        orange: [ 255, 165, 0, 1 ],
        orangered: [ 255, 69, 0, 1 ],
        orchid: [ 218, 112, 214, 1 ],
        palegoldenrod: [ 238, 232, 170, 1 ],
        palegreen: [ 152, 251, 152, 1 ],
        paleturquoise: [ 175, 238, 238, 1 ],
        palevioletred: [ 219, 112, 147, 1 ],
        papayawhip: [ 255, 239, 213, 1 ],
        peachpuff: [ 255, 218, 185, 1 ],
        peru: [ 205, 133, 63, 1 ],
        pink: [ 255, 192, 203, 1 ],
        plum: [ 221, 160, 221, 1 ],
        powderblue: [ 176, 224, 230, 1 ],
        purple: [ 128, 0, 128, 1 ],
        red: [ 255, 0, 0, 1 ],
        rosybrown: [ 188, 143, 143, 1 ],
        royalblue: [ 65, 105, 225, 1 ],
        saddlebrown: [ 139, 69, 19, 1 ],
        salmon: [ 250, 128, 114, 1 ],
        sandybrown: [ 244, 164, 96, 1 ],
        seagreen: [ 46, 139, 87, 1 ],
        seashell: [ 255, 245, 238, 1 ],
        sienna: [ 160, 82, 45, 1 ],
        silver: [ 192, 192, 192, 1 ],
        skyblue: [ 135, 206, 235, 1 ],
        slateblue: [ 106, 90, 205, 1 ],
        slategray: [ 112, 128, 144, 1 ],
        slategrey: [ 112, 128, 144, 1 ],
        snow: [ 255, 250, 250, 1 ],
        springgreen: [ 0, 255, 127, 1 ],
        steelblue: [ 70, 130, 180, 1 ],
        tan: [ 210, 180, 140, 1 ],
        teal: [ 0, 128, 128, 1 ],
        thistle: [ 216, 191, 216, 1 ],
        tomato: [ 255, 99, 71, 1 ],
        turquoise: [ 64, 224, 208, 1 ],
        violet: [ 238, 130, 238, 1 ],
        wheat: [ 245, 222, 179, 1 ],
        white: [ 255, 255, 255, 1 ],
        whitesmoke: [ 245, 245, 245, 1 ],
        yellow: [ 255, 255, 0, 1 ],
        yellowgreen: [ 154, 205, 50, 1 ]
    }, lg = new og(20), hg = null, ug = Lt, cg = kt, dg = (Object.freeze || Object)({
        parse: Tt,
        lift: At,
        toHex: Ct,
        fastLerp: Lt,
        fastMapToColor: ug,
        lerp: kt,
        mapToColor: cg,
        modifyHSL: Pt,
        modifyAlpha: Nt,
        stringify: Ot
    }), fg = Array.prototype.slice, pg = function(t, e, i, n) {
        this._tracks = {}, this._target = t, this._loop = e || !1, this._getter = i || Et, 
        this._setter = n || Rt, this._clipCount = 0, this._delay = 0, this._doneList = [], 
        this._onframeList = [], this._clipList = [];
    };
    pg.prototype = {
        when: function(t, e) {
            var i = this._tracks;
            for (var n in e) if (e.hasOwnProperty(n)) {
                if (!i[n]) {
                    i[n] = [];
                    var a = this._getter(this._target, n);
                    if (null == a) continue;
                    0 !== t && i[n].push({
                        time: 0,
                        value: Zt(a)
                    });
                }
                i[n].push({
                    time: t,
                    value: e[n]
                });
            }
            return this;
        },
        during: function(t) {
            return this._onframeList.push(t), this;
        },
        pause: function() {
            for (var t = 0; t < this._clipList.length; t++) this._clipList[t].pause();
            this._paused = !0;
        },
        resume: function() {
            for (var t = 0; t < this._clipList.length; t++) this._clipList[t].resume();
            this._paused = !1;
        },
        isPaused: function() {
            return !!this._paused;
        },
        _doneCallback: function() {
            this._tracks = {}, this._clipList.length = 0;
            for (var t = this._doneList, e = t.length, i = 0; i < e; i++) t[i].call(this);
        },
        start: function(t, e) {
            var i, n = this, a = 0;
            for (var o in this._tracks) if (this._tracks.hasOwnProperty(o)) {
                var r = jt(this, t, function() {
                    --a || n._doneCallback();
                }, this._tracks[o], o, e);
                r && (this._clipList.push(r), a++, this.animation && this.animation.addClip(r), 
                i = r);
            }
            if (i) {
                var s = i.onframe;
                i.onframe = function(t, e) {
                    s(t, e);
                    for (var i = 0; i < n._onframeList.length; i++) n._onframeList[i](t, e);
                };
            }
            return a || this._doneCallback(), this;
        },
        stop: function(t) {
            for (var e = this._clipList, i = this.animation, n = 0; n < e.length; n++) {
                var a = e[n];
                t && a.onframe(this._target, 1), i && i.removeClip(a);
            }
            e.length = 0;
        },
        delay: function(t) {
            return this._delay = t, this;
        },
        done: function(t) {
            return t && this._doneList.push(t), this;
        },
        getClips: function() {
            return this._clipList;
        }
    };
    var gg = 1;
    "undefined" != typeof window && (gg = Math.max(window.devicePixelRatio || 1, 1));
    var mg = gg, vg = function() {}, yg = function() {
        this.animators = [];
    };
    yg.prototype = {
        constructor: yg,
        animate: function(t, e) {
            var i, n = !1, a = this, o = this.__zr;
            if (t) {
                var r = t.split("."), s = a;
                n = "shape" === r[0];
                for (var l = 0, h = r.length; l < h; l++) s && (s = s[r[l]]);
                s && (i = s);
            } else i = a;
            if (i) {
                var u = a.animators, c = new pg(i, e);
                return c.during(function(t) {
                    a.dirty(n);
                }).done(function() {
                    u.splice(C(u, c), 1);
                }), u.push(c), o && o.animation.addAnimator(c), c;
            }
            vg('Property "' + t + '" is not existed in element ' + a.id);
        },
        stopAnimation: function(t) {
            for (var e = this.animators, i = e.length, n = 0; n < i; n++) e[n].stop(t);
            return e.length = 0, this;
        },
        animateTo: function(t, e, i, n, a, o) {
            b(i) ? (a = n, n = i, i = 0) : m(n) ? (a = n, n = "linear", i = 0) : m(i) ? (a = i, 
            i = 0) : m(e) ? (a = e, e = 500) : e || (e = 500), this.stopAnimation(), this._animateToShallow("", this, t, e, i);
            var r = this.animators.slice(), s = r.length;
            s || a && a();
            for (var l = 0; l < r.length; l++) r[l].done(function() {
                --s || a && a();
            }).start(n, o);
        },
        _animateToShallow: function(t, e, i, n, a) {
            var o = {}, r = 0;
            for (var s in i) if (i.hasOwnProperty(s)) if (null != e[s]) B(i[s]) && !O(i[s]) ? this._animateToShallow(t ? t + "." + s : s, e[s], i[s], n, a) : (o[s] = i[s], 
            r++); else if (null != i[s]) if (t) {
                var l = {};
                l[t] = {}, l[t][s] = i[s], this.attr(l);
            } else this.attr(s, i[s]);
            return 0 < r && this.animate(t, !1).when(null == n ? 500 : n, o).delay(a || 0), 
            this;
        }
    };
    var xg = function(t) {
        Jp.call(this, t), Up.call(this, t), yg.call(this, t), this.id = t.id || bp();
    };
    xg.prototype = {
        type: "element",
        name: "",
        __zr: null,
        ignore: !1,
        clipPath: null,
        isGroup: !1,
        drift: function(t, e) {
            switch (this.draggable) {
              case "horizontal":
                e = 0;
                break;

              case "vertical":
                t = 0;
            }
            var i = this.transform;
            i || (i = this.transform = [ 1, 0, 0, 1, 0, 0 ]), i[4] += t, i[5] += e, this.decomposeTransform(), 
            this.dirty(!1);
        },
        beforeUpdate: function() {},
        afterUpdate: function() {},
        update: function() {
            this.updateTransform();
        },
        traverse: function(t, e) {},
        attrKV: function(t, e) {
            if ("position" === t || "scale" === t || "origin" === t) {
                if (e) {
                    var i = this[t];
                    i || (i = this[t] = []), i[0] = e[0], i[1] = e[1];
                }
            } else this[t] = e;
        },
        hide: function() {
            this.ignore = !0, this.__zr && this.__zr.refresh();
        },
        show: function() {
            this.ignore = !1, this.__zr && this.__zr.refresh();
        },
        attr: function(t, e) {
            if ("string" == typeof t) this.attrKV(t, e); else if (B(t)) for (var i in t) t.hasOwnProperty(i) && this.attrKV(i, t[i]);
            return this.dirty(!1), this;
        },
        setClipPath: function(t) {
            var e = this.__zr;
            e && t.addSelfToZr(e), this.clipPath && this.clipPath !== t && this.removeClipPath(), 
            (this.clipPath = t).__zr = e, (t.__clipTarget = this).dirty(!1);
        },
        removeClipPath: function() {
            var t = this.clipPath;
            t && (t.__zr && t.removeSelfFromZr(t.__zr), t.__zr = null, t.__clipTarget = null, 
            this.clipPath = null, this.dirty(!1));
        },
        addSelfToZr: function(t) {
            this.__zr = t;
            var e = this.animators;
            if (e) for (var i = 0; i < e.length; i++) t.animation.addAnimator(e[i]);
            this.clipPath && this.clipPath.addSelfToZr(t);
        },
        removeSelfFromZr: function(t) {
            this.__zr = null;
            var e = this.animators;
            if (e) for (var i = 0; i < e.length; i++) t.animation.removeAnimator(e[i]);
            this.clipPath && this.clipPath.removeSelfFromZr(t);
        }
    }, a(xg, yg), a(xg, Jp), a(xg, Up);
    var _g, wg, bg, Sg, Mg = Q, Ig = Math.min, Tg = Math.max;
    Xt.prototype = {
        constructor: Xt,
        union: function(t) {
            var e = Ig(t.x, this.x), i = Ig(t.y, this.y);
            this.width = Tg(t.x + t.width, this.x + this.width) - e, this.height = Tg(t.y + t.height, this.y + this.height) - i, 
            this.x = e, this.y = i;
        },
        applyTransform: (_g = [], wg = [], bg = [], Sg = [], function(t) {
            if (t) {
                _g[0] = bg[0] = this.x, _g[1] = Sg[1] = this.y, wg[0] = Sg[0] = this.x + this.width, 
                wg[1] = bg[1] = this.y + this.height, Mg(_g, _g, t), Mg(wg, wg, t), Mg(bg, bg, t), 
                Mg(Sg, Sg, t), this.x = Ig(_g[0], wg[0], bg[0], Sg[0]), this.y = Ig(_g[1], wg[1], bg[1], Sg[1]);
                var e = Tg(_g[0], wg[0], bg[0], Sg[0]), i = Tg(_g[1], wg[1], bg[1], Sg[1]);
                this.width = e - this.x, this.height = i - this.y;
            }
        }),
        calculateTransform: function(t) {
            var e = t.width / this.width, i = t.height / this.height, n = rt();
            return ut(n, n, [ -this.x, -this.y ]), dt(n, n, [ e, i ]), ut(n, n, [ t.x, t.y ]), 
            n;
        },
        intersect: function(t) {
            if (!t) return !1;
            t instanceof Xt || (t = Xt.create(t));
            var e = this.x, i = this.x + this.width, n = this.y, a = this.y + this.height, o = t.x, r = t.x + t.width, s = t.y, l = t.y + t.height;
            return !(i < o || r < e || a < s || l < n);
        },
        contain: function(t, e) {
            return t >= this.x && t <= this.x + this.width && e >= this.y && e <= this.y + this.height;
        },
        clone: function() {
            return new Xt(this.x, this.y, this.width, this.height);
        },
        copy: function(t) {
            this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height;
        },
        plain: function() {
            return {
                x: this.x,
                y: this.y,
                width: this.width,
                height: this.height
            };
        }
    }, Xt.create = function(t) {
        return new Xt(t.x, t.y, t.width, t.height);
    };
    var Dg = function(t) {
        for (var e in t = t || {}, xg.call(this, t), t) t.hasOwnProperty(e) && (this[e] = t[e]);
        this._children = [], this.__storage = null, this.__dirty = !0;
    };
    Dg.prototype = {
        constructor: Dg,
        isGroup: !0,
        type: "group",
        silent: !1,
        children: function() {
            return this._children.slice();
        },
        childAt: function(t) {
            return this._children[t];
        },
        childOfName: function(t) {
            for (var e = this._children, i = 0; i < e.length; i++) if (e[i].name === t) return e[i];
        },
        childCount: function() {
            return this._children.length;
        },
        add: function(t) {
            return t && t !== this && t.parent !== this && (this._children.push(t), this._doAdd(t)), 
            this;
        },
        addBefore: function(t, e) {
            if (t && t !== this && t.parent !== this && e && e.parent === this) {
                var i = this._children, n = i.indexOf(e);
                0 <= n && (i.splice(n, 0, t), this._doAdd(t));
            }
            return this;
        },
        _doAdd: function(t) {
            t.parent && t.parent.remove(t);
            var e = (t.parent = this).__storage, i = this.__zr;
            e && e !== t.__storage && (e.addToStorage(t), t instanceof Dg && t.addChildrenToStorage(e)), 
            i && i.refresh();
        },
        remove: function(t) {
            var e = this.__zr, i = this.__storage, n = this._children, a = C(n, t);
            return a < 0 || (n.splice(a, 1), t.parent = null, i && (i.delFromStorage(t), t instanceof Dg && t.delChildrenFromStorage(i)), 
            e && e.refresh()), this;
        },
        removeAll: function() {
            var t, e, i = this._children, n = this.__storage;
            for (e = 0; e < i.length; e++) t = i[e], n && (n.delFromStorage(t), t instanceof Dg && t.delChildrenFromStorage(n)), 
            t.parent = null;
            return i.length = 0, this;
        },
        eachChild: function(t, e) {
            for (var i = this._children, n = 0; n < i.length; n++) {
                var a = i[n];
                t.call(e, a, n);
            }
            return this;
        },
        traverse: function(t, e) {
            for (var i = 0; i < this._children.length; i++) {
                var n = this._children[i];
                t.call(e, n), "group" === n.type && n.traverse(t, e);
            }
            return this;
        },
        addChildrenToStorage: function(t) {
            for (var e = 0; e < this._children.length; e++) {
                var i = this._children[e];
                t.addToStorage(i), i instanceof Dg && i.addChildrenToStorage(t);
            }
        },
        delChildrenFromStorage: function(t) {
            for (var e = 0; e < this._children.length; e++) {
                var i = this._children[e];
                t.delFromStorage(i), i instanceof Dg && i.delChildrenFromStorage(t);
            }
        },
        dirty: function() {
            return this.__dirty = !0, this.__zr && this.__zr.refresh(), this;
        },
        getBoundingRect: function(t) {
            for (var e = null, i = new Xt(0, 0, 0, 0), n = t || this._children, a = [], o = 0; o < n.length; o++) {
                var r = n[o];
                if (!r.ignore && !r.invisible) {
                    var s = r.getBoundingRect(), l = r.getLocalTransform(a);
                    l ? (i.copy(s), i.applyTransform(l), (e = e || i.clone()).union(i)) : (e = e || s.clone()).union(s);
                }
            }
            return e || i;
        }
    }, o(Dg, xg);
    var Ag = 32, Cg = 7, Lg = function() {
        this._roots = [], this._displayList = [], this._displayListLen = 0;
    };
    Lg.prototype = {
        constructor: Lg,
        traverse: function(t, e) {
            for (var i = 0; i < this._roots.length; i++) this._roots[i].traverse(t, e);
        },
        getDisplayList: function(t, e) {
            return e = e || !1, t && this.updateDisplayList(e), this._displayList;
        },
        updateDisplayList: function(t) {
            this._displayListLen = 0;
            for (var e = this._roots, i = this._displayList, n = 0, a = e.length; n < a; n++) this._updateAndAddDisplayable(e[n], null, t);
            i.length = this._displayListLen, Sp.canvasSupported && Qt(i, te);
        },
        _updateAndAddDisplayable: function(t, e, i) {
            if (!t.ignore || i) {
                t.beforeUpdate(), t.__dirty && t.update(), t.afterUpdate();
                var n = t.clipPath;
                if (n) {
                    e = e ? e.slice() : [];
                    for (var a = n, o = t; a; ) a.parent = o, a.updateTransform(), e.push(a), a = (o = a).clipPath;
                }
                if (t.isGroup) {
                    for (var r = t._children, s = 0; s < r.length; s++) {
                        var l = r[s];
                        t.__dirty && (l.__dirty = !0), this._updateAndAddDisplayable(l, e, i);
                    }
                    t.__dirty = !1;
                } else t.__clipPaths = e, this._displayList[this._displayListLen++] = t;
            }
        },
        addRoot: function(t) {
            t.__storage !== this && (t instanceof Dg && t.addChildrenToStorage(this), this.addToStorage(t), 
            this._roots.push(t));
        },
        delRoot: function(t) {
            if (null == t) {
                for (i = 0; i < this._roots.length; i++) {
                    var e = this._roots[i];
                    e instanceof Dg && e.delChildrenFromStorage(this);
                }
                return this._roots = [], this._displayList = [], void (this._displayListLen = 0);
            }
            if (t instanceof Array) for (var i = 0, n = t.length; i < n; i++) this.delRoot(t[i]); else {
                var a = C(this._roots, t);
                0 <= a && (this.delFromStorage(t), this._roots.splice(a, 1), t instanceof Dg && t.delChildrenFromStorage(this));
            }
        },
        addToStorage: function(t) {
            return t && (t.__storage = this, t.dirty(!1)), this;
        },
        delFromStorage: function(t) {
            return t && (t.__storage = null), this;
        },
        dispose: function() {
            this._renderList = this._roots = null;
        },
        displayableSortFunc: te
    };
    var kg = {
        shadowBlur: 1,
        shadowOffsetX: 1,
        shadowOffsetY: 1,
        textShadowBlur: 1,
        textShadowOffsetX: 1,
        textShadowOffsetY: 1,
        textBoxShadowBlur: 1,
        textBoxShadowOffsetX: 1,
        textBoxShadowOffsetY: 1
    }, Pg = function(t, e, i) {
        return kg.hasOwnProperty(e) ? i *= t.dpr : i;
    }, Ng = [ [ "shadowBlur", 0 ], [ "shadowOffsetX", 0 ], [ "shadowOffsetY", 0 ], [ "shadowColor", "#000" ], [ "lineCap", "butt" ], [ "lineJoin", "miter" ], [ "miterLimit", 10 ] ], Og = function(t, e) {
        this.extendFrom(t, !1), this.host = e;
    };
    Og.prototype = {
        constructor: Og,
        host: null,
        fill: "#000",
        stroke: null,
        opacity: 1,
        lineDash: null,
        lineDashOffset: 0,
        shadowBlur: 0,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        lineWidth: 1,
        strokeNoScale: !1,
        text: null,
        font: null,
        textFont: null,
        fontStyle: null,
        fontWeight: null,
        fontSize: null,
        fontFamily: null,
        textTag: null,
        textFill: "#000",
        textStroke: null,
        textWidth: null,
        textHeight: null,
        textStrokeWidth: 0,
        textLineHeight: null,
        textPosition: "inside",
        textRect: null,
        textOffset: null,
        textAlign: null,
        textVerticalAlign: null,
        textDistance: 5,
        textShadowColor: "transparent",
        textShadowBlur: 0,
        textShadowOffsetX: 0,
        textShadowOffsetY: 0,
        textBoxShadowColor: "transparent",
        textBoxShadowBlur: 0,
        textBoxShadowOffsetX: 0,
        textBoxShadowOffsetY: 0,
        transformText: !1,
        textRotation: 0,
        textOrigin: null,
        textBackgroundColor: null,
        textBorderColor: null,
        textBorderWidth: 0,
        textBorderRadius: 0,
        textPadding: null,
        rich: null,
        truncate: null,
        blend: null,
        bind: function(t, e, i) {
            for (var n = this, a = i && i.style, o = !a, r = 0; r < Ng.length; r++) {
                var s = Ng[r], l = s[0];
                (o || n[l] !== a[l]) && (t[l] = Pg(t, l, n[l] || s[1]));
            }
            if ((o || n.fill !== a.fill) && (t.fillStyle = n.fill), (o || n.stroke !== a.stroke) && (t.strokeStyle = n.stroke), 
            (o || n.opacity !== a.opacity) && (t.globalAlpha = null == n.opacity ? 1 : n.opacity), 
            (o || n.blend !== a.blend) && (t.globalCompositeOperation = n.blend || "source-over"), 
            this.hasStroke()) {
                var h = n.lineWidth;
                t.lineWidth = h / (this.strokeNoScale && e && e.getLineScale ? e.getLineScale() : 1);
            }
        },
        hasFill: function() {
            var t = this.fill;
            return null != t && "none" !== t;
        },
        hasStroke: function() {
            var t = this.stroke;
            return null != t && "none" !== t && 0 < this.lineWidth;
        },
        extendFrom: function(t, e) {
            if (t) for (var i in t) !t.hasOwnProperty(i) || !0 !== e && (!1 === e ? this.hasOwnProperty(i) : null == t[i]) || (this[i] = t[i]);
        },
        set: function(t, e) {
            "string" == typeof t ? this[t] = e : this.extendFrom(t, !0);
        },
        clone: function() {
            var t = new this.constructor();
            return t.extendFrom(this, !0), t;
        },
        getGradient: function(t, e, i) {
            for (var n = ("radial" === e.type ? function(t, e, i) {
                var n = i.width, a = i.height, o = Math.min(n, a), r = null == e.x ? .5 : e.x, s = null == e.y ? .5 : e.y, l = null == e.r ? .5 : e.r;
                return e.global || (r = r * n + i.x, s = s * a + i.y, l *= o), t.createRadialGradient(r, s, 0, r, s, l);
            } : function(t, e, i) {
                var n = null == e.x ? 0 : e.x, a = null == e.x2 ? 1 : e.x2, o = null == e.y ? 0 : e.y, r = null == e.y2 ? 0 : e.y2;
                return e.global || (n = n * i.width + i.x, a = a * i.width + i.x, o = o * i.height + i.y, 
                r = r * i.height + i.y), n = isNaN(n) ? 0 : n, a = isNaN(a) ? 1 : a, o = isNaN(o) ? 0 : o, 
                r = isNaN(r) ? 0 : r, t.createLinearGradient(n, o, a, r);
            })(t, e, i), a = e.colorStops, o = 0; o < a.length; o++) n.addColorStop(a[o].offset, a[o].color);
            return n;
        }
    };
    for (var Eg = Og.prototype, Rg = 0; Rg < Ng.length; Rg++) {
        var zg = Ng[Rg];
        zg[0] in Eg || (Eg[zg[0]] = zg[1]);
    }
    Og.getGradient = Eg.getGradient;
    var Bg = function(t, e) {
        this.image = t, this.repeat = e, this.type = "pattern";
    }, Vg = function(t, e, i) {
        var n;
        i = i || mg, "string" == typeof t ? n = ie(t, e, i) : B(t) && (t = (n = t).id), 
        this.id = t;
        var a = (this.dom = n).style;
        a && (n.onselectstart = ee, a["-webkit-user-select"] = "none", a["user-select"] = "none", 
        a["-webkit-touch-callout"] = "none", a["-webkit-tap-highlight-color"] = "rgba(0,0,0,0)", 
        a.padding = 0, a.margin = 0, a["border-width"] = 0), this.domBack = null, this.ctxBack = null, 
        this.painter = e, this.config = null, this.clearColor = 0, this.motionBlur = !1, 
        this.lastFrameAlpha = .7, this.dpr = i;
    };
    Vg.prototype = {
        constructor: Vg,
        __dirty: !0,
        __used: !(Bg.prototype.getCanvasPattern = function(t) {
            return t.createPattern(this.image, this.repeat || "repeat");
        }),
        __drawIndex: 0,
        __startIndex: 0,
        __endIndex: 0,
        incremental: !1,
        getElementCount: function() {
            return this.__endIndex - this.__startIndex;
        },
        initContext: function() {
            this.ctx = this.dom.getContext("2d"), this.ctx.dpr = this.dpr;
        },
        createBackBuffer: function() {
            var t = this.dpr;
            this.domBack = ie("back-" + this.id, this.painter, t), this.ctxBack = this.domBack.getContext("2d"), 
            1 != t && this.ctxBack.scale(t, t);
        },
        resize: function(t, e) {
            var i = this.dpr, n = this.dom, a = n.style, o = this.domBack;
            a && (a.width = t + "px", a.height = e + "px"), n.width = t * i, n.height = e * i, 
            o && (o.width = t * i, o.height = e * i, 1 != i && this.ctxBack.scale(i, i));
        },
        clear: function(t, e) {
            var i, n = this.dom, a = this.ctx, o = n.width, r = n.height, s = (e = e || this.clearColor, 
            this.motionBlur && !t), l = this.lastFrameAlpha, h = this.dpr;
            (s && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = "copy", 
            this.ctxBack.drawImage(n, 0, 0, o / h, r / h)), a.clearRect(0, 0, o, r), e && "transparent" !== e) && (e.colorStops ? (i = e.__canvasGradient || Og.getGradient(a, e, {
                x: 0,
                y: 0,
                width: o,
                height: r
            }), e.__canvasGradient = i) : e.image && (i = Bg.prototype.getCanvasPattern.call(e, a)), 
            a.save(), a.fillStyle = i || e, a.fillRect(0, 0, o, r), a.restore());
            if (s) {
                var u = this.domBack;
                a.save(), a.globalAlpha = l, a.drawImage(u, 0, 0, o, r), a.restore();
            }
        }
    };
    var Gg = "undefined" != typeof window && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(t) {
        setTimeout(t, 16);
    }, Wg = new og(50), Fg = {}, Hg = 0, Zg = 5e3, Ug = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g, jg = "12px sans-serif", Xg = {
        measureText: function(t, e) {
            var i = n();
            return i.font = e || jg, i.measureText(t);
        }
    }, Yg = {
        left: 1,
        right: 1,
        center: 1
    }, qg = {
        top: 1,
        bottom: 1,
        middle: 1
    }, Kg = new Xt(), $g = function() {};
    ze.prototype = {
        constructor: ze,
        type: "displayable",
        __dirty: !0,
        invisible: !($g.prototype = {
            constructor: $g,
            drawRectText: function(t, e) {
                var i = this.style;
                e = i.textRect || e, this.__dirty && be(i);
                var n = i.text;
                if (null != n && (n += ""), Re(n, i)) {
                    t.save();
                    var a = this.transform;
                    i.transformText ? this.setTransform(t) : a && (Kg.copy(e), Kg.applyTransform(a), 
                    e = Kg), Me(this, t, n, i, e), t.restore();
                }
            }
        }),
        z: 0,
        z2: 0,
        zlevel: 0,
        draggable: !1,
        dragging: !1,
        silent: !1,
        culling: !1,
        cursor: "pointer",
        rectHover: !1,
        progressive: !1,
        incremental: !1,
        inplace: !1,
        beforeBrush: function(t) {},
        afterBrush: function(t) {},
        brush: function(t, e) {},
        getBoundingRect: function() {},
        contain: function(t, e) {
            return this.rectContain(t, e);
        },
        traverse: function(t, e) {
            t.call(e, this);
        },
        rectContain: function(t, e) {
            var i = this.transformCoordToLocal(t, e);
            return this.getBoundingRect().contain(i[0], i[1]);
        },
        dirty: function() {
            this.__dirty = !0, this._rect = null, this.__zr && this.__zr.refresh();
        },
        animateStyle: function(t) {
            return this.animate("style", t);
        },
        attrKV: function(t, e) {
            "style" !== t ? xg.prototype.attrKV.call(this, t, e) : this.style.set(e);
        },
        setStyle: function(t, e) {
            return this.style.set(t, e), this.dirty(!1), this;
        },
        useStyle: function(t) {
            return this.style = new Og(t, this), this.dirty(!1), this;
        }
    }, o(ze, xg), a(ze, $g), Be.prototype = {
        constructor: Be,
        type: "image",
        brush: function(t, e) {
            var i = this.style, n = i.image;
            i.bind(t, this, e);
            var a = this._image = ae(n, this._image, this, this.onload);
            if (a && re(a)) {
                var o = i.x || 0, r = i.y || 0, s = i.width, l = i.height, h = a.width / a.height;
                if (null == s && null != l ? s = l * h : null == l && null != s ? l = s / h : null == s && null == l && (s = a.width, 
                l = a.height), this.setTransform(t), i.sWidth && i.sHeight) {
                    var u = i.sx || 0, c = i.sy || 0;
                    t.drawImage(a, u, c, i.sWidth, i.sHeight, o, r, s, l);
                } else if (i.sx && i.sy) {
                    var d = s - (u = i.sx), f = l - (c = i.sy);
                    t.drawImage(a, u, c, d, f, o, r, s, l);
                } else t.drawImage(a, o, r, s, l);
                null != i.text && (this.restoreTransform(t), this.drawRectText(t, this.getBoundingRect()));
            }
        },
        getBoundingRect: function() {
            var t = this.style;
            return this._rect || (this._rect = new Xt(t.x || 0, t.y || 0, t.width || 0, t.height || 0)), 
            this._rect;
        }
    }, o(Be, ze);
    var Jg = new Xt(0, 0, 0, 0), Qg = new Xt(0, 0, 0, 0), tm = function(t, e, i) {
        this.type = "canvas";
        var n = !t.nodeName || "CANVAS" === t.nodeName.toUpperCase();
        this._opts = i = P({}, i || {}), this.dpr = i.devicePixelRatio || mg, this._singleCanvas = n;
        var a = (this.root = t).style;
        a && (a["-webkit-tap-highlight-color"] = "transparent", a["-webkit-user-select"] = a["user-select"] = a["-webkit-touch-callout"] = "none", 
        t.innerHTML = ""), this.storage = e;
        var o, r, s, l = this._zlevelList = [], h = this._layers = {};
        if (this._layerConfig = {}, this._needsManuallyCompositing = !1, n) {
            var u = t.width, c = t.height;
            null != i.width && (u = i.width), null != i.height && (c = i.height), this.dpr = i.devicePixelRatio || 1, 
            t.width = u * this.dpr, t.height = c * this.dpr, this._width = u, this._height = c;
            var d = new Vg(t, this, this.dpr);
            d.__builtin__ = !0, d.initContext(), (h[314159] = d).zlevel = 314159, l.push(314159), 
            this._domRoot = t;
        } else {
            this._width = this._getSize(0), this._height = this._getSize(1);
            var f = this._domRoot = (o = this._width, r = this._height, (s = document.createElement("div")).style.cssText = [ "position:relative", "overflow:hidden", "width:" + o + "px", "height:" + r + "px", "padding:0", "margin:0", "border-width:0" ].join(";") + ";", 
            s);
            t.appendChild(f);
        }
        this._hoverlayer = null, this._hoverElements = [];
    };
    tm.prototype = {
        constructor: tm,
        getType: function() {
            return "canvas";
        },
        isSingleCanvas: function() {
            return this._singleCanvas;
        },
        getViewportRoot: function() {
            return this._domRoot;
        },
        getViewportRootOffset: function() {
            var t = this.getViewportRoot();
            if (t) return {
                offsetLeft: t.offsetLeft || 0,
                offsetTop: t.offsetTop || 0
            };
        },
        refresh: function(t) {
            var e = this.storage.getDisplayList(!0), i = this._zlevelList;
            this._redrawId = Math.random(), this._paintList(e, t, this._redrawId);
            for (var n = 0; n < i.length; n++) {
                var a = i[n], o = this._layers[a];
                if (!o.__builtin__ && o.refresh) {
                    var r = 0 === n ? this._backgroundColor : null;
                    o.refresh(r);
                }
            }
            return this.refreshHover(), this;
        },
        addHover: function(t, e) {
            if (!t.__hoverMir) {
                var i = new t.constructor({
                    style: t.style,
                    shape: t.shape
                });
                ((i.__from = t).__hoverMir = i).setStyle(e), this._hoverElements.push(i);
            }
        },
        removeHover: function(t) {
            var e = t.__hoverMir, i = this._hoverElements, n = C(i, e);
            0 <= n && i.splice(n, 1), t.__hoverMir = null;
        },
        clearHover: function(t) {
            for (var e = this._hoverElements, i = 0; i < e.length; i++) {
                var n = e[i].__from;
                n && (n.__hoverMir = null);
            }
            e.length = 0;
        },
        refreshHover: function() {
            var t = this._hoverElements, e = t.length, i = this._hoverlayer;
            if (i && i.clear(), e) {
                Qt(t, this.storage.displayableSortFunc), i || (i = this._hoverlayer = this.getLayer(1e5));
                var n = {};
                i.ctx.save();
                for (var a = 0; a < e; ) {
                    var o = t[a], r = o.__from;
                    r && r.__zr ? (a++, r.invisible || (o.transform = r.transform, o.invTransform = r.invTransform, 
                    o.__clipPaths = r.__clipPaths, this._doPaintEl(o, i, !0, n))) : (t.splice(a, 1), 
                    r.__hoverMir = null, e--);
                }
                i.ctx.restore();
            }
        },
        getHoverLayer: function() {
            return this.getLayer(1e5);
        },
        _paintList: function(t, e, i) {
            if (this._redrawId === i) {
                e = e || !1, this._updateLayerStatus(t);
                var n = this._doPaintList(t, e);
                if (this._needsManuallyCompositing && this._compositeManually(), !n) {
                    var a = this;
                    Gg(function() {
                        a._paintList(t, e, i);
                    });
                }
            }
        },
        _compositeManually: function() {
            var e = this.getLayer(314159).ctx, i = this._domRoot.width, n = this._domRoot.height;
            e.clearRect(0, 0, i, n), this.eachBuiltinLayer(function(t) {
                t.virtual && e.drawImage(t.dom, 0, 0, i, n);
            });
        },
        _doPaintList: function(t, e) {
            for (var i = [], n = 0; n < this._zlevelList.length; n++) {
                var a = this._zlevelList[n];
                (s = this._layers[a]).__builtin__ && s !== this._hoverlayer && (s.__dirty || e) && i.push(s);
            }
            for (var o = !0, r = 0; r < i.length; r++) {
                var s = i[r], l = s.ctx, h = {};
                l.save();
                var u = e ? s.__startIndex : s.__drawIndex, c = !e && s.incremental && Date.now, d = c && Date.now(), f = s.zlevel === this._zlevelList[0] ? this._backgroundColor : null;
                if (s.__startIndex === s.__endIndex) s.clear(!1, f); else if (u === s.__startIndex) {
                    var p = t[u];
                    p.incremental && p.notClear && !e || s.clear(!1, f);
                }
                -1 === u && (console.error("For some unknown reason. drawIndex is -1"), u = s.__startIndex);
                for (var g = u; g < s.__endIndex; g++) {
                    var m = t[g];
                    if (this._doPaintEl(m, s, e, h), m.__dirty = !1, c && 15 < Date.now() - d) break;
                }
                s.__drawIndex = g, s.__drawIndex < s.__endIndex && (o = !1), h.prevElClipPaths && l.restore(), 
                l.restore();
            }
            return Sp.wxa && R(this._layers, function(t) {
                t && t.ctx && t.ctx.draw && t.ctx.draw();
            }), o;
        },
        _doPaintEl: function(t, e, i, n) {
            var a, o, r, s = e.ctx, l = t.transform;
            if ((e.__dirty || i) && !t.invisible && 0 !== t.style.opacity && (!l || l[0] || l[3]) && (!t.culling || (a = t, 
            o = this._width, r = this._height, Jg.copy(a.getBoundingRect()), a.transform && Jg.applyTransform(a.transform), 
            Qg.width = o, Qg.height = r, Jg.intersect(Qg)))) {
                var h = t.__clipPaths;
                n.prevElClipPaths && !function(t, e) {
                    if (t == e) return !1;
                    if (!t || !e || t.length !== e.length) return !0;
                    for (var i = 0; i < t.length; i++) if (t[i] !== e[i]) return !0;
                }(h, n.prevElClipPaths) || (n.prevElClipPaths && (e.ctx.restore(), n.prevElClipPaths = null, 
                n.prevEl = null), h && (s.save(), function(t, e) {
                    for (var i = 0; i < t.length; i++) {
                        var n = t[i];
                        n.setTransform(e), e.beginPath(), n.buildPath(e, n.shape), e.clip(), n.restoreTransform(e);
                    }
                }(h, s), n.prevElClipPaths = h)), t.beforeBrush && t.beforeBrush(s), t.brush(s, n.prevEl || null), 
                (n.prevEl = t).afterBrush && t.afterBrush(s);
            }
        },
        getLayer: function(t, e) {
            this._singleCanvas && !this._needsManuallyCompositing && (t = 314159);
            var i = this._layers[t];
            return i || ((i = new Vg("zr_" + t, this, this.dpr)).zlevel = t, i.__builtin__ = !0, 
            this._layerConfig[t] && g(i, this._layerConfig[t], !0), e && (i.virtual = e), this.insertLayer(t, i), 
            i.initContext()), i;
        },
        insertLayer: function(t, e) {
            var i, n = this._layers, a = this._zlevelList, o = a.length, r = null, s = -1, l = this._domRoot;
            if (n[t]) vg("ZLevel " + t + " has been used already"); else if ((i = e) && (i.__builtin__ || "function" == typeof i.resize && "function" == typeof i.refresh)) {
                if (0 < o && t > a[0]) {
                    for (s = 0; s < o - 1 && !(a[s] < t && a[s + 1] > t); s++) ;
                    r = n[a[s]];
                }
                if (a.splice(s + 1, 0, t), !(n[t] = e).virtual) if (r) {
                    var h = r.dom;
                    h.nextSibling ? l.insertBefore(e.dom, h.nextSibling) : l.appendChild(e.dom);
                } else l.firstChild ? l.insertBefore(e.dom, l.firstChild) : l.appendChild(e.dom);
            } else vg("Layer of zlevel " + t + " is not valid");
        },
        eachLayer: function(t, e) {
            var i, n, a = this._zlevelList;
            for (n = 0; n < a.length; n++) i = a[n], t.call(e, this._layers[i], i);
        },
        eachBuiltinLayer: function(t, e) {
            var i, n, a, o = this._zlevelList;
            for (a = 0; a < o.length; a++) n = o[a], (i = this._layers[n]).__builtin__ && t.call(e, i, n);
        },
        eachOtherLayer: function(t, e) {
            var i, n, a, o = this._zlevelList;
            for (a = 0; a < o.length; a++) n = o[a], (i = this._layers[n]).__builtin__ || t.call(e, i, n);
        },
        getLayers: function() {
            return this._layers;
        },
        _updateLayerStatus: function(t) {
            function e(t) {
                i && (i.__endIndex !== t && (i.__dirty = !0), i.__endIndex = t);
            }
            if (this.eachBuiltinLayer(function(t, e) {
                t.__dirty = t.__used = !1;
            }), this._singleCanvas) for (a = 1; a < t.length; a++) if ((r = t[a]).zlevel !== t[a - 1].zlevel || r.incremental) {
                this._needsManuallyCompositing = !0;
                break;
            }
            for (var i = null, n = 0, a = 0; a < t.length; a++) {
                var o, r = t[a], s = r.zlevel;
                r.incremental ? ((o = this.getLayer(s + .001, this._needsManuallyCompositing)).incremental = !0, 
                n = 1) : o = this.getLayer(s + (0 < n ? .01 : 0), this._needsManuallyCompositing), 
                o.__builtin__ || vg("ZLevel " + s + " has been used by unkown layer " + o.id), o !== i && (o.__used = !0, 
                o.__startIndex !== a && (o.__dirty = !0), o.__startIndex = a, o.incremental ? o.__drawIndex = -1 : o.__drawIndex = a, 
                e(a), i = o), r.__dirty && (o.__dirty = !0, o.incremental && o.__drawIndex < 0 && (o.__drawIndex = a));
            }
            e(a), this.eachBuiltinLayer(function(t, e) {
                !t.__used && 0 < t.getElementCount() && (t.__dirty = !0, t.__startIndex = t.__endIndex = t.__drawIndex = 0), 
                t.__dirty && t.__drawIndex < 0 && (t.__drawIndex = t.__startIndex);
            });
        },
        clear: function() {
            return this.eachBuiltinLayer(this._clearLayer), this;
        },
        _clearLayer: function(t) {
            t.clear();
        },
        setBackgroundColor: function(t) {
            this._backgroundColor = t;
        },
        configLayer: function(t, e) {
            if (e) {
                var i = this._layerConfig;
                i[t] ? g(i[t], e, !0) : i[t] = e;
                for (var n = 0; n < this._zlevelList.length; n++) {
                    var a = this._zlevelList[n];
                    a !== t && a !== t + .01 || g(this._layers[a], i[t], !0);
                }
            }
        },
        delLayer: function(t) {
            var e = this._layers, i = this._zlevelList, n = e[t];
            n && (n.dom.parentNode.removeChild(n.dom), delete e[t], i.splice(C(i, t), 1));
        },
        resize: function(e, i) {
            if (this._domRoot.style) {
                var t = this._domRoot;
                t.style.display = "none";
                var n = this._opts;
                if (null != e && (n.width = e), null != i && (n.height = i), e = this._getSize(0), 
                i = this._getSize(1), t.style.display = "", this._width != e || i != this._height) {
                    for (var a in t.style.width = e + "px", t.style.height = i + "px", this._layers) this._layers.hasOwnProperty(a) && this._layers[a].resize(e, i);
                    R(this._progressiveLayers, function(t) {
                        t.resize(e, i);
                    }), this.refresh(!0);
                }
                this._width = e, this._height = i;
            } else {
                if (null == e || null == i) return;
                this._width = e, this._height = i, this.getLayer(314159).resize(e, i);
            }
            return this;
        },
        clearLayer: function(t) {
            var e = this._layers[t];
            e && e.clear();
        },
        dispose: function() {
            this.root.innerHTML = "", this.root = this.storage = this._domRoot = this._layers = null;
        },
        getRenderedCanvas: function(t) {
            if (t = t || {}, this._singleCanvas && !this._compositeManually) return this._layers[314159].dom;
            var e = new Vg("image", this, t.pixelRatio || this.dpr);
            if (e.initContext(), e.clear(!1, t.backgroundColor || this._backgroundColor), t.pixelRatio <= this.dpr) {
                this.refresh();
                var i = e.dom.width, n = e.dom.height, a = e.ctx;
                this.eachLayer(function(t) {
                    t.__builtin__ ? a.drawImage(t.dom, 0, 0, i, n) : t.renderToCanvas && (e.ctx.save(), 
                    t.renderToCanvas(e.ctx), e.ctx.restore());
                });
            } else for (var o = {}, r = this.storage.getDisplayList(!0), s = 0; s < r.length; s++) {
                var l = r[s];
                this._doPaintEl(l, e, !0, o);
            }
            return e.dom;
        },
        getWidth: function() {
            return this._width;
        },
        getHeight: function() {
            return this._height;
        },
        _getSize: function(t) {
            var e = this._opts, i = [ "width", "height" ][t], n = [ "clientWidth", "clientHeight" ][t], a = [ "paddingLeft", "paddingTop" ][t], o = [ "paddingRight", "paddingBottom" ][t];
            if (null != e[i] && "auto" !== e[i]) return parseFloat(e[i]);
            var r = this.root, s = document.defaultView.getComputedStyle(r);
            return (r[n] || Ve(s[i]) || Ve(r.style[i])) - (Ve(s[a]) || 0) - (Ve(s[o]) || 0) | 0;
        },
        pathToImage: function(t, e) {
            e = e || this.dpr;
            var i = document.createElement("canvas"), n = i.getContext("2d"), a = t.getBoundingRect(), o = t.style, r = o.shadowBlur * e, s = o.shadowOffsetX * e, l = o.shadowOffsetY * e, h = o.hasStroke() ? o.lineWidth : 0, u = Math.max(h / 2, -s + r), c = Math.max(h / 2, s + r), d = Math.max(h / 2, -l + r), f = Math.max(h / 2, l + r), p = a.width + u + c, g = a.height + d + f;
            i.width = p * e, i.height = g * e, n.scale(e, e), n.clearRect(0, 0, p, g), n.dpr = e;
            var m = {
                position: t.position,
                rotation: t.rotation,
                scale: t.scale
            };
            t.position = [ u - a.x, d - a.y ], t.rotation = 0, t.scale = [ 1, 1 ], t.updateTransform(), 
            t && t.brush(n);
            var v = new Be({
                style: {
                    x: 0,
                    y: 0,
                    image: i
                }
            });
            return null != m.position && (v.position = t.position = m.position), null != m.rotation && (v.rotation = t.rotation = m.rotation), 
            null != m.scale && (v.scale = t.scale = m.scale), v;
        }
    };
    var em = "undefined" != typeof window && !!window.addEventListener, im = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, nm = em ? function(t) {
        t.preventDefault(), t.stopPropagation(), t.cancelBubble = !0;
    } : function(t) {
        t.returnValue = !1, t.cancelBubble = !0;
    }, am = function(t) {
        t = t || {}, this.stage = t.stage || {}, this.onframe = t.onframe || function() {}, 
        this._clips = [], this._running = !1, this._time, this._pausedTime, this._pauseStart, 
        this._paused = !1, Up.call(this);
    };
    am.prototype = {
        constructor: am,
        addClip: function(t) {
            this._clips.push(t);
        },
        addAnimator: function(t) {
            t.animation = this;
            for (var e = t.getClips(), i = 0; i < e.length; i++) this.addClip(e[i]);
        },
        removeClip: function(t) {
            var e = C(this._clips, t);
            0 <= e && this._clips.splice(e, 1);
        },
        removeAnimator: function(t) {
            for (var e = t.getClips(), i = 0; i < e.length; i++) this.removeClip(e[i]);
            t.animation = null;
        },
        _update: function() {
            for (var t = new Date().getTime() - this._pausedTime, e = t - this._time, i = this._clips, n = i.length, a = [], o = [], r = 0; r < n; r++) {
                var s = i[r], l = s.step(t, e);
                l && (a.push(l), o.push(s));
            }
            for (r = 0; r < n; ) i[r]._needsRemove ? (i[r] = i[n - 1], i.pop(), n--) : r++;
            for (n = a.length, r = 0; r < n; r++) o[r].fire(a[r]);
            this._time = t, this.onframe(e), this.trigger("frame", e), this.stage.update && this.stage.update();
        },
        _startLoop: function() {
            var e = this;
            this._running = !0, Gg(function t() {
                e._running && (Gg(t), !e._paused && e._update());
            });
        },
        start: function() {
            this._time = new Date().getTime(), this._pausedTime = 0, this._startLoop();
        },
        stop: function() {
            this._running = !1;
        },
        pause: function() {
            this._paused || (this._pauseStart = new Date().getTime(), this._paused = !0);
        },
        resume: function() {
            this._paused && (this._pausedTime += new Date().getTime() - this._pauseStart, this._paused = !1);
        },
        clear: function() {
            this._clips = [];
        },
        isFinished: function() {
            return !this._clips.length;
        },
        animate: function(t, e) {
            var i = new pg(t, (e = e || {}).loop, e.getter, e.setter);
            return this.addAnimator(i), i;
        }
    }, a(am, Up);
    var om = function() {
        this._track = [];
    };
    om.prototype = {
        constructor: om,
        recognize: function(t, e, i) {
            return this._doTrack(t, e, i), this._recognize(t);
        },
        clear: function() {
            return this._track.length = 0, this;
        },
        _doTrack: function(t, e, i) {
            var n = t.touches;
            if (n) {
                for (var a = {
                    points: [],
                    touches: [],
                    target: e,
                    event: t
                }, o = 0, r = n.length; o < r; o++) {
                    var s = n[o], l = Ge(i, s, {});
                    a.points.push([ l.zrX, l.zrY ]), a.touches.push(s);
                }
                this._track.push(a);
            }
        },
        _recognize: function(t) {
            for (var e in rm) if (rm.hasOwnProperty(e)) {
                var i = rm[e](this._track, t);
                if (i) return i;
            }
        }
    };
    var rm = {
        pinch: function(t, e) {
            var i, n = t.length;
            if (n) {
                var a = (t[n - 1] || {}).points, o = (t[n - 2] || {}).points || a;
                if (o && 1 < o.length && a && 1 < a.length) {
                    var r = Ue(a) / Ue(o);
                    !isFinite(r) && (r = 1), e.pinchScale = r;
                    var s = [ ((i = a)[0][0] + i[1][0]) / 2, (i[0][1] + i[1][1]) / 2 ];
                    return e.pinchX = s[0], e.pinchY = s[1], {
                        type: "pinch",
                        target: t[0].target,
                        event: e
                    };
                }
            }
        }
    }, sm = [ "click", "dblclick", "mousewheel", "mouseout", "mouseup", "mousedown", "mousemove", "contextmenu" ], lm = [ "touchstart", "touchend", "touchmove" ], hm = {
        pointerdown: 1,
        pointerup: 1,
        pointermove: 1,
        pointerout: 1
    }, um = L(sm, function(t) {
        var e = t.replace("mouse", "pointer");
        return hm[e] ? e : t;
    }), cm = {
        mousemove: function(t) {
            t = Fe(this.dom, t), this.trigger("mousemove", t);
        },
        mouseout: function(t) {
            var e = (t = Fe(this.dom, t)).toElement || t.relatedTarget;
            if (e != this.dom) for (;e && 9 != e.nodeType; ) {
                if (e === this.dom) return;
                e = e.parentNode;
            }
            this.trigger("mouseout", t);
        },
        touchstart: function(t) {
            (t = Fe(this.dom, t)).zrByTouch = !0, this._lastTouchMoment = new Date(), Xe(this, t, "start"), 
            cm.mousemove.call(this, t), cm.mousedown.call(this, t), Ye(this);
        },
        touchmove: function(t) {
            (t = Fe(this.dom, t)).zrByTouch = !0, Xe(this, t, "change"), cm.mousemove.call(this, t), 
            Ye(this);
        },
        touchend: function(t) {
            (t = Fe(this.dom, t)).zrByTouch = !0, Xe(this, t, "end"), cm.mouseup.call(this, t), 
            +new Date() - this._lastTouchMoment < 300 && cm.click.call(this, t), Ye(this);
        },
        pointerdown: function(t) {
            cm.mousedown.call(this, t);
        },
        pointermove: function(t) {
            qe(t) || cm.mousemove.call(this, t);
        },
        pointerup: function(t) {
            cm.mouseup.call(this, t);
        },
        pointerout: function(t) {
            qe(t) || cm.mouseout.call(this, t);
        }
    };
    R([ "click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu" ], function(e) {
        cm[e] = function(t) {
            t = Fe(this.dom, t), this.trigger(e, t);
        };
    });
    var dm = Ke.prototype;
    dm.dispose = function() {
        for (var t = sm.concat(lm), e = 0; e < t.length; e++) {
            var i = t[e];
            n = this.dom, a = je(i), o = this._handlers[i], em ? n.removeEventListener(a, o) : n.detachEvent("on" + a, o);
        }
        var n, a, o;
    }, dm.setCursor = function(t) {
        this.dom.style && (this.dom.style.cursor = t || "default");
    }, a(Ke, Up);
    var fm = !Sp.canvasSupported, pm = {
        canvas: tm
    }, gm = {}, mm = function(t, e, i) {
        i = i || {}, this.dom = e, this.id = t;
        var n = this, a = new Lg(), o = i.renderer;
        if (fm) {
            if (!pm.vml) throw new Error("You need to require 'zrender/vml/vml' to support IE8");
            o = "vml";
        } else o && pm[o] || (o = "canvas");
        var r = new pm[o](e, a, i, t);
        this.storage = a, this.painter = r;
        var s = Sp.node || Sp.worker ? null : new Ke(r.getViewportRoot());
        this.handler = new Yp(a, r, s, r.root), this.animation = new am({
            stage: {
                update: _(this.flush, this)
            }
        }), this.animation.start(), this._needsRefresh;
        var l = a.delFromStorage, h = a.addToStorage;
        a.delFromStorage = function(t) {
            l.call(a, t), t && t.removeSelfFromZr(n);
        }, a.addToStorage = function(t) {
            h.call(a, t), t.addSelfToZr(n);
        };
    };
    mm.prototype = {
        constructor: mm,
        getId: function() {
            return this.id;
        },
        add: function(t) {
            this.storage.addRoot(t), this._needsRefresh = !0;
        },
        remove: function(t) {
            this.storage.delRoot(t), this._needsRefresh = !0;
        },
        configLayer: function(t, e) {
            this.painter.configLayer && this.painter.configLayer(t, e), this._needsRefresh = !0;
        },
        setBackgroundColor: function(t) {
            this.painter.setBackgroundColor && this.painter.setBackgroundColor(t), this._needsRefresh = !0;
        },
        refreshImmediately: function() {
            this._needsRefresh = !1, this.painter.refresh(), this._needsRefresh = !1;
        },
        refresh: function() {
            this._needsRefresh = !0;
        },
        flush: function() {
            var t;
            this._needsRefresh && (t = !0, this.refreshImmediately()), this._needsRefreshHover && (t = !0, 
            this.refreshHoverImmediately()), t && this.trigger("rendered");
        },
        addHover: function(t, e) {
            this.painter.addHover && (this.painter.addHover(t, e), this.refreshHover());
        },
        removeHover: function(t) {
            this.painter.removeHover && (this.painter.removeHover(t), this.refreshHover());
        },
        clearHover: function() {
            this.painter.clearHover && (this.painter.clearHover(), this.refreshHover());
        },
        refreshHover: function() {
            this._needsRefreshHover = !0;
        },
        refreshHoverImmediately: function() {
            this._needsRefreshHover = !1, this.painter.refreshHover && this.painter.refreshHover();
        },
        resize: function(t) {
            t = t || {}, this.painter.resize(t.width, t.height), this.handler.resize();
        },
        clearAnimation: function() {
            this.animation.clear();
        },
        getWidth: function() {
            return this.painter.getWidth();
        },
        getHeight: function() {
            return this.painter.getHeight();
        },
        pathToImage: function(t, e) {
            return this.painter.pathToImage(t, e);
        },
        setCursorStyle: function(t) {
            this.handler.setCursorStyle(t);
        },
        findHover: function(t, e) {
            return this.handler.findHover(t, e);
        },
        on: function(t, e, i) {
            this.handler.on(t, e, i);
        },
        off: function(t, e) {
            this.handler.off(t, e);
        },
        trigger: function(t, e) {
            this.handler.trigger(t, e);
        },
        clear: function() {
            this.storage.delRoot(), this.painter.clear();
        },
        dispose: function() {
            var t;
            this.animation.stop(), this.clear(), this.storage.dispose(), this.painter.dispose(), 
            this.handler.dispose(), this.animation = this.storage = this.painter = this.handler = null, 
            t = this.id, delete gm[t];
        }
    };
    var vm = (Object.freeze || Object)({
        version: "4.0.3",
        init: $e,
        dispose: function(t) {
            if (t) t.dispose(); else {
                for (var e in gm) gm.hasOwnProperty(e) && gm[e].dispose();
                gm = {};
            }
            return this;
        },
        getInstance: function(t) {
            return gm[t];
        },
        registerPainter: Je
    }), ym = R, xm = B, _m = N, wm = "series\0", bm = [ "fontStyle", "fontWeight", "fontSize", "fontFamily", "rich", "tag", "color", "textBorderColor", "textBorderWidth", "width", "height", "lineHeight", "align", "verticalAlign", "baseline", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY", "backgroundColor", "borderColor", "borderWidth", "borderRadius", "padding" ], Sm = 0, Mm = ".", Im = "___EC__COMPONENT__CONTAINER___", Tm = 0, Dm = function(s) {
        for (var t = 0; t < s.length; t++) s[t][1] || (s[t][1] = s[t][0]);
        return function(t, e, i) {
            for (var n = {}, a = 0; a < s.length; a++) {
                var o = s[a][1];
                if (!(e && 0 <= C(e, o) || i && C(i, o) < 0)) {
                    var r = t.getShallow(o);
                    null != r && (n[s[a][0]] = r);
                }
            }
            return n;
        };
    }, Am = Dm([ [ "lineWidth", "width" ], [ "stroke", "color" ], [ "opacity" ], [ "shadowBlur" ], [ "shadowOffsetX" ], [ "shadowOffsetY" ], [ "shadowColor" ] ]), Cm = {
        getLineStyle: function(t) {
            var e = Am(this, t), i = this.getLineDash(e.lineWidth);
            return i && (e.lineDash = i), e;
        },
        getLineDash: function(t) {
            null == t && (t = 1);
            var e = this.get("type"), i = Math.max(t, 2), n = 4 * t;
            return "solid" === e || null == e ? null : "dashed" === e ? [ n, n ] : [ i, i ];
        }
    }, Lm = Dm([ [ "fill", "color" ], [ "shadowBlur" ], [ "shadowOffsetX" ], [ "shadowOffsetY" ], [ "opacity" ], [ "shadowColor" ] ]), km = {
        getAreaStyle: function(t, e) {
            return Lm(this, t, e);
        }
    }, Pm = Math.pow, Nm = Math.sqrt, Om = 1e-8, Em = 1e-4, Rm = Nm(3), zm = 1 / 3, Bm = M(), Vm = M(), Gm = M(), Wm = Math.min, Fm = Math.max, Hm = Math.sin, Zm = Math.cos, Um = 2 * Math.PI, jm = M(), Xm = M(), Ym = M(), qm = [], Km = [], $m = {
        M: 1,
        L: 2,
        C: 3,
        Q: 4,
        A: 5,
        Z: 6,
        R: 7
    }, Jm = [], Qm = [], tv = [], ev = [], iv = Math.min, nv = Math.max, av = Math.cos, ov = Math.sin, rv = Math.sqrt, sv = Math.abs, lv = "undefined" != typeof Float32Array, hv = function(t) {
        this._saveData = !t, this._saveData && (this.data = []), this._ctx = null;
    };
    hv.prototype = {
        constructor: hv,
        _xi: 0,
        _yi: 0,
        _x0: 0,
        _y0: 0,
        _ux: 0,
        _uy: 0,
        _len: 0,
        _lineDash: null,
        _dashOffset: 0,
        _dashIdx: 0,
        _dashSum: 0,
        setScale: function(t, e) {
            this._ux = sv(1 / mg / t) || 0, this._uy = sv(1 / mg / e) || 0;
        },
        getContext: function() {
            return this._ctx;
        },
        beginPath: function(t) {
            return (this._ctx = t) && t.beginPath(), t && (this.dpr = t.dpr), this._saveData && (this._len = 0), 
            this._lineDash && (this._lineDash = null, this._dashOffset = 0), this;
        },
        moveTo: function(t, e) {
            return this.addData($m.M, t, e), this._ctx && this._ctx.moveTo(t, e), this._x0 = t, 
            this._y0 = e, this._xi = t, this._yi = e, this;
        },
        lineTo: function(t, e) {
            var i = sv(t - this._xi) > this._ux || sv(e - this._yi) > this._uy || this._len < 5;
            return this.addData($m.L, t, e), this._ctx && i && (this._needsDash() ? this._dashedLineTo(t, e) : this._ctx.lineTo(t, e)), 
            i && (this._xi = t, this._yi = e), this;
        },
        bezierCurveTo: function(t, e, i, n, a, o) {
            return this.addData($m.C, t, e, i, n, a, o), this._ctx && (this._needsDash() ? this._dashedBezierTo(t, e, i, n, a, o) : this._ctx.bezierCurveTo(t, e, i, n, a, o)), 
            this._xi = a, this._yi = o, this;
        },
        quadraticCurveTo: function(t, e, i, n) {
            return this.addData($m.Q, t, e, i, n), this._ctx && (this._needsDash() ? this._dashedQuadraticTo(t, e, i, n) : this._ctx.quadraticCurveTo(t, e, i, n)), 
            this._xi = i, this._yi = n, this;
        },
        arc: function(t, e, i, n, a, o) {
            return this.addData($m.A, t, e, i, i, n, a - n, 0, o ? 0 : 1), this._ctx && this._ctx.arc(t, e, i, n, a, o), 
            this._xi = av(a) * i + t, this._yi = ov(a) * i + t, this;
        },
        arcTo: function(t, e, i, n, a) {
            return this._ctx && this._ctx.arcTo(t, e, i, n, a), this;
        },
        rect: function(t, e, i, n) {
            return this._ctx && this._ctx.rect(t, e, i, n), this.addData($m.R, t, e, i, n), 
            this;
        },
        closePath: function() {
            this.addData($m.Z);
            var t = this._ctx, e = this._x0, i = this._y0;
            return t && (this._needsDash() && this._dashedLineTo(e, i), t.closePath()), this._xi = e, 
            this._yi = i, this;
        },
        fill: function(t) {
            t && t.fill(), this.toStatic();
        },
        stroke: function(t) {
            t && t.stroke(), this.toStatic();
        },
        setLineDash: function(t) {
            if (t instanceof Array) {
                this._lineDash = t;
                for (var e = this._dashIdx = 0, i = 0; i < t.length; i++) e += t[i];
                this._dashSum = e;
            }
            return this;
        },
        setLineDashOffset: function(t) {
            return this._dashOffset = t, this;
        },
        len: function() {
            return this._len;
        },
        setData: function(t) {
            var e = t.length;
            this.data && this.data.length == e || !lv || (this.data = new Float32Array(e));
            for (var i = 0; i < e; i++) this.data[i] = t[i];
            this._len = e;
        },
        appendPath: function(t) {
            t instanceof Array || (t = [ t ]);
            for (var e = t.length, i = 0, n = this._len, a = 0; a < e; a++) i += t[a].len();
            for (lv && this.data instanceof Float32Array && (this.data = new Float32Array(n + i)), 
            a = 0; a < e; a++) for (var o = t[a].data, r = 0; r < o.length; r++) this.data[n++] = o[r];
            this._len = n;
        },
        addData: function(t) {
            if (this._saveData) {
                var e = this.data;
                this._len + arguments.length > e.length && (this._expandData(), e = this.data);
                for (var i = 0; i < arguments.length; i++) e[this._len++] = arguments[i];
                this._prevCmd = t;
            }
        },
        _expandData: function() {
            if (!(this.data instanceof Array)) {
                for (var t = [], e = 0; e < this._len; e++) t[e] = this.data[e];
                this.data = t;
            }
        },
        _needsDash: function() {
            return this._lineDash;
        },
        _dashedLineTo: function(t, e) {
            var i, n, a = this._dashSum, o = this._dashOffset, r = this._lineDash, s = this._ctx, l = this._xi, h = this._yi, u = t - l, c = e - h, d = rv(u * u + c * c), f = l, p = h, g = r.length;
            for (o < 0 && (o = a + o), f -= (o %= a) * (u /= d), p -= o * (c /= d); 0 < u && f <= t || u < 0 && t <= f || 0 == u && (0 < c && p <= e || c < 0 && e <= p); ) f += u * (i = r[n = this._dashIdx]), 
            p += c * i, this._dashIdx = (n + 1) % g, 0 < u && f < l || u < 0 && l < f || 0 < c && p < h || c < 0 && h < p || s[n % 2 ? "moveTo" : "lineTo"](0 <= u ? iv(f, t) : nv(f, t), 0 <= c ? iv(p, e) : nv(p, e));
            u = f - t, c = p - e, this._dashOffset = -rv(u * u + c * c);
        },
        _dashedBezierTo: function(t, e, i, n, a, o) {
            var r, s, l, h, u, c = this._dashSum, d = this._dashOffset, f = this._lineDash, p = this._ctx, g = this._xi, m = this._yi, v = xi, y = 0, x = this._dashIdx, _ = f.length, w = 0;
            for (d < 0 && (d = c + d), d %= c, r = 0; r < 1; r += .1) s = v(g, t, i, a, r + .1) - v(g, t, i, a, r), 
            l = v(m, e, n, o, r + .1) - v(m, e, n, o, r), y += rv(s * s + l * l);
            for (;x < _ && !((w += f[x]) > d); x++) ;
            for (r = (w - d) / y; r <= 1; ) h = v(g, t, i, a, r), u = v(m, e, n, o, r), x % 2 ? p.moveTo(h, u) : p.lineTo(h, u), 
            r += f[x] / y, x = (x + 1) % _;
            x % 2 != 0 && p.lineTo(a, o), s = a - h, l = o - u, this._dashOffset = -rv(s * s + l * l);
        },
        _dashedQuadraticTo: function(t, e, i, n) {
            var a = i, o = n;
            i = (i + 2 * t) / 3, n = (n + 2 * e) / 3, t = (this._xi + 2 * t) / 3, e = (this._yi + 2 * e) / 3, 
            this._dashedBezierTo(t, e, i, n, a, o);
        },
        toStatic: function() {
            var t = this.data;
            t instanceof Array && (t.length = this._len, lv && (this.data = new Float32Array(t)));
        },
        getBoundingRect: function() {
            Jm[0] = Jm[1] = tv[0] = tv[1] = Number.MAX_VALUE, Qm[0] = Qm[1] = ev[0] = ev[1] = -Number.MAX_VALUE;
            for (var t = this.data, e = 0, i = 0, n = 0, a = 0, o = 0; o < t.length; ) {
                var r = t[o++];
                switch (1 == o && (n = e = t[o], a = i = t[o + 1]), r) {
                  case $m.M:
                    e = n = t[o++], i = a = t[o++], tv[0] = n, tv[1] = a, ev[0] = n, ev[1] = a;
                    break;

                  case $m.L:
                    Ai(e, i, t[o], t[o + 1], tv, ev), e = t[o++], i = t[o++];
                    break;

                  case $m.C:
                    Ci(e, i, t[o++], t[o++], t[o++], t[o++], t[o], t[o + 1], tv, ev), e = t[o++], i = t[o++];
                    break;

                  case $m.Q:
                    p = e, g = i, m = t[o++], v = t[o++], y = t[o], x = t[o + 1], _ = tv, w = ev, S = b = void 0, 
                    S = Si, M = Fm(Wm((b = Ii)(p, m, y), 1), 0), I = Fm(Wm(b(g, v, x), 1), 0), T = S(p, m, y, M), 
                    D = S(g, v, x, I), _[0] = Wm(p, y, T), _[1] = Wm(g, x, D), w[0] = Fm(p, y, T), w[1] = Fm(g, x, D), 
                    e = t[o++], i = t[o++];
                    break;

                  case $m.A:
                    var s = t[o++], l = t[o++], h = t[o++], u = t[o++], c = t[o++], d = t[o++] + c, f = (t[o++], 
                    1 - t[o++]);
                    1 == o && (n = av(c) * h + s, a = ov(c) * u + l), Li(s, l, h, u, c, d, f, tv, ev), 
                    e = av(d) * h + s, i = ov(d) * u + l;
                    break;

                  case $m.R:
                    Ai(n = e = t[o++], a = i = t[o++], n + t[o++], a + t[o++], tv, ev);
                    break;

                  case $m.Z:
                    e = n, i = a;
                }
                tt(Jm, Jm, tv), et(Qm, Qm, ev);
            }
            var p, g, m, v, y, x, _, w, b, S, M, I, T, D;
            return 0 === o && (Jm[0] = Jm[1] = Qm[0] = Qm[1] = 0), new Xt(Jm[0], Jm[1], Qm[0] - Jm[0], Qm[1] - Jm[1]);
        },
        rebuildPath: function(t) {
            for (var e, i, n, a, o, r, s = this.data, l = this._ux, h = this._uy, u = this._len, c = 0; c < u; ) {
                var d = s[c++];
                switch (1 == c && (e = n = s[c], i = a = s[c + 1]), d) {
                  case $m.M:
                    e = n = s[c++], i = a = s[c++], t.moveTo(n, a);
                    break;

                  case $m.L:
                    o = s[c++], r = s[c++], (sv(o - n) > l || sv(r - a) > h || c === u - 1) && (t.lineTo(o, r), 
                    n = o, a = r);
                    break;

                  case $m.C:
                    t.bezierCurveTo(s[c++], s[c++], s[c++], s[c++], s[c++], s[c++]), n = s[c - 2], a = s[c - 1];
                    break;

                  case $m.Q:
                    t.quadraticCurveTo(s[c++], s[c++], s[c++], s[c++]), n = s[c - 2], a = s[c - 1];
                    break;

                  case $m.A:
                    var f = s[c++], p = s[c++], g = s[c++], m = s[c++], v = s[c++], y = s[c++], x = s[c++], _ = s[c++], w = m < g ? g : m, b = m < g ? 1 : g / m, S = m < g ? m / g : 1, M = v + y;
                    .001 < Math.abs(g - m) ? (t.translate(f, p), t.rotate(x), t.scale(b, S), t.arc(0, 0, w, v, M, 1 - _), 
                    t.scale(1 / b, 1 / S), t.rotate(-x), t.translate(-f, -p)) : t.arc(f, p, w, v, M, 1 - _), 
                    1 == c && (e = av(v) * g + f, i = ov(v) * m + p), n = av(M) * g + f, a = ov(M) * m + p;
                    break;

                  case $m.R:
                    e = n = s[c], i = a = s[c + 1], t.rect(s[c++], s[c++], s[c++], s[c++]);
                    break;

                  case $m.Z:
                    t.closePath(), n = e, a = i;
                }
            }
        }
    }, hv.CMD = $m;
    var uv = 2 * Math.PI, cv = 2 * Math.PI, dv = hv.CMD, fv = 2 * Math.PI, pv = 1e-4, gv = [ -1, -1, -1 ], mv = [ -1, -1 ], vv = Bg.prototype.getCanvasPattern, yv = Math.abs, xv = new hv(!0);
    Wi.prototype = {
        constructor: Wi,
        type: "path",
        __dirtyPath: !0,
        strokeContainThreshold: 5,
        brush: function(t, e) {
            var i, n = this.style, a = this.path || xv, o = n.hasStroke(), r = n.hasFill(), s = n.fill, l = n.stroke, h = r && !!s.colorStops, u = o && !!l.colorStops, c = r && !!s.image, d = o && !!l.image;
            (n.bind(t, this, e), this.setTransform(t), this.__dirty) && (h && (i = i || this.getBoundingRect(), 
            this._fillGradient = n.getGradient(t, s, i)), u && (i = i || this.getBoundingRect(), 
            this._strokeGradient = n.getGradient(t, l, i)));
            h ? t.fillStyle = this._fillGradient : c && (t.fillStyle = vv.call(s, t)), u ? t.strokeStyle = this._strokeGradient : d && (t.strokeStyle = vv.call(l, t));
            var f = n.lineDash, p = n.lineDashOffset, g = !!t.setLineDash, m = this.getGlobalScale();
            a.setScale(m[0], m[1]), this.__dirtyPath || f && !g && o ? (a.beginPath(t), f && !g && (a.setLineDash(f), 
            a.setLineDashOffset(p)), this.buildPath(a, this.shape, !1), this.path && (this.__dirtyPath = !1)) : (t.beginPath(), 
            this.path.rebuildPath(t)), r && a.fill(t), f && g && (t.setLineDash(f), t.lineDashOffset = p), 
            o && a.stroke(t), f && g && t.setLineDash([]), null != n.text && (this.restoreTransform(t), 
            this.drawRectText(t, this.getBoundingRect()));
        },
        buildPath: function(t, e, i) {},
        createPathProxy: function() {
            this.path = new hv();
        },
        getBoundingRect: function() {
            var t = this._rect, e = this.style, i = !t;
            if (i) {
                var n = this.path;
                n || (n = this.path = new hv()), this.__dirtyPath && (n.beginPath(), this.buildPath(n, this.shape, !1)), 
                t = n.getBoundingRect();
            }
            if (this._rect = t, e.hasStroke()) {
                var a = this._rectWithStroke || (this._rectWithStroke = t.clone());
                if (this.__dirty || i) {
                    a.copy(t);
                    var o = e.lineWidth, r = e.strokeNoScale ? this.getLineScale() : 1;
                    e.hasFill() || (o = Math.max(o, this.strokeContainThreshold || 4)), 1e-10 < r && (a.width += o / r, 
                    a.height += o / r, a.x -= o / r / 2, a.y -= o / r / 2);
                }
                return a;
            }
            return t;
        },
        contain: function(t, e) {
            var i = this.transformCoordToLocal(t, e), n = this.getBoundingRect(), a = this.style;
            if (t = i[0], e = i[1], n.contain(t, e)) {
                var o = this.path.data;
                if (a.hasStroke()) {
                    var r = a.lineWidth, s = a.strokeNoScale ? this.getLineScale() : 1;
                    if (1e-10 < s && (a.hasFill() || (r = Math.max(r, this.strokeContainThreshold)), 
                    Gi(o, r / s, !0, t, e))) return !0;
                }
                if (a.hasFill()) return Gi(o, 0, !1, t, e);
            }
            return !1;
        },
        dirty: function(t) {
            null == t && (t = !0), t && (this.__dirtyPath = t, this._rect = null), this.__dirty = !0, 
            this.__zr && this.__zr.refresh(), this.__clipTarget && this.__clipTarget.dirty();
        },
        animateShape: function(t) {
            return this.animate("shape", t);
        },
        attrKV: function(t, e) {
            "shape" === t ? (this.setShape(e), this.__dirtyPath = !0, this._rect = null) : ze.prototype.attrKV.call(this, t, e);
        },
        setShape: function(t, e) {
            var i = this.shape;
            if (i) {
                if (B(t)) for (var n in t) t.hasOwnProperty(n) && (i[n] = t[n]); else i[t] = e;
                this.dirty(!0);
            }
            return this;
        },
        getLineScale: function() {
            var t = this.transform;
            return t && 1e-10 < yv(t[0] - 1) && 1e-10 < yv(t[3] - 1) ? Math.sqrt(yv(t[0] * t[3] - t[2] * t[1])) : 1;
        }
    }, Wi.extend = function(a) {
        var t = function(t) {
            Wi.call(this, t), a.style && this.style.extendFrom(a.style, !1);
            var e = a.shape;
            if (e) {
                this.shape = this.shape || {};
                var i = this.shape;
                for (var n in e) !i.hasOwnProperty(n) && e.hasOwnProperty(n) && (i[n] = e[n]);
            }
            a.init && a.init.call(this, t);
        };
        for (var e in o(t, Wi), a) "style" !== e && "shape" !== e && (t.prototype[e] = a[e]);
        return t;
    }, o(Wi, ze);
    var _v = hv.CMD, wv = [ [], [], [] ], bv = Math.sqrt, Sv = Math.atan2, Mv = function(t, e) {
        var i, n, a, o, r, s, l = t.data, h = _v.M, u = _v.C, c = _v.L, d = _v.R, f = _v.A, p = _v.Q;
        for (o = a = 0; a < l.length; ) {
            switch (i = l[a++], o = a, n = 0, i) {
              case h:
              case c:
                n = 1;
                break;

              case u:
                n = 3;
                break;

              case p:
                n = 2;
                break;

              case f:
                var g = e[4], m = e[5], v = bv(e[0] * e[0] + e[1] * e[1]), y = bv(e[2] * e[2] + e[3] * e[3]), x = Sv(-e[1] / y, e[0] / v);
                l[a] *= v, l[a++] += g, l[a] *= y, l[a++] += m, l[a++] *= v, l[a++] *= y, l[a++] += x, 
                l[a++] += x, o = a += 2;
                break;

              case d:
                s[0] = l[a++], s[1] = l[a++], Q(s, s, e), l[o++] = s[0], l[o++] = s[1], s[0] += l[a++], 
                s[1] += l[a++], Q(s, s, e), l[o++] = s[0], l[o++] = s[1];
            }
            for (r = 0; r < n; r++) (s = wv[r])[0] = l[a++], s[1] = l[a++], Q(s, s, e), l[o++] = s[0], 
            l[o++] = s[1];
        }
    }, Iv = [ "m", "M", "l", "L", "v", "V", "h", "H", "z", "Z", "c", "C", "q", "Q", "t", "T", "s", "S", "a", "A" ], Tv = Math.sqrt, Dv = Math.sin, Av = Math.cos, Cv = Math.PI, Lv = function(t) {
        return Math.sqrt(t[0] * t[0] + t[1] * t[1]);
    }, kv = function(t, e) {
        return (t[0] * e[0] + t[1] * e[1]) / (Lv(t) * Lv(e));
    }, Pv = function(t, e) {
        return (t[0] * e[1] < t[1] * e[0] ? -1 : 1) * Math.acos(kv(t, e));
    }, Nv = function(t) {
        ze.call(this, t);
    };
    Nv.prototype = {
        constructor: Nv,
        type: "text",
        brush: function(t, e) {
            var i = this.style;
            this.__dirty && be(i), i.fill = i.stroke = i.shadowBlur = i.shadowColor = i.shadowOffsetX = i.shadowOffsetY = null;
            var n = i.text;
            null != n && (n += ""), i.bind(t, this, e), Re(n, i) && (this.setTransform(t), Me(this, t, n, i), 
            this.restoreTransform(t));
        },
        getBoundingRect: function() {
            var t = this.style;
            if (this.__dirty && be(t), !this._rect) {
                var e = t.text;
                null != e ? e += "" : e = "";
                var i = le(t.text + "", t.font, t.textAlign, t.textVerticalAlign, t.textPadding, t.rich);
                if (i.x += t.x || 0, i.y += t.y || 0, Pe(t.textStroke, t.textStrokeWidth)) {
                    var n = t.textStrokeWidth;
                    i.x -= n / 2, i.y -= n / 2, i.width += n, i.height += n;
                }
                this._rect = i;
            }
            return this._rect;
        }
    }, o(Nv, ze);
    var Ov = Wi.extend({
        type: "circle",
        shape: {
            cx: 0,
            cy: 0,
            r: 0
        },
        buildPath: function(t, e, i) {
            i && t.moveTo(e.cx + e.r, e.cy), t.arc(e.cx, e.cy, e.r, 0, 2 * Math.PI, !0);
        }
    }), Ev = [ [ "shadowBlur", 0 ], [ "shadowColor", "#000" ], [ "shadowOffsetX", 0 ], [ "shadowOffsetY", 0 ] ], Rv = function(l) {
        return Sp.browser.ie && 11 <= Sp.browser.version ? function() {
            var t, e = this.__clipPaths, i = this.style;
            if (e) for (var n = 0; n < e.length; n++) {
                var a = e[n], o = a && a.shape, r = a && a.type;
                if (o && ("sector" === r && o.startAngle === o.endAngle || "rect" === r && (!o.width || !o.height))) {
                    for (s = 0; s < Ev.length; s++) Ev[s][2] = i[Ev[s][0]], i[Ev[s][0]] = Ev[s][1];
                    t = !0;
                    break;
                }
            }
            if (l.apply(this, arguments), t) for (var s = 0; s < Ev.length; s++) i[Ev[s][0]] = Ev[s][2];
        } : l;
    }, zv = Wi.extend({
        type: "sector",
        shape: {
            cx: 0,
            cy: 0,
            r0: 0,
            r: 0,
            startAngle: 0,
            endAngle: 2 * Math.PI,
            clockwise: !0
        },
        brush: Rv(Wi.prototype.brush),
        buildPath: function(t, e) {
            var i = e.cx, n = e.cy, a = Math.max(e.r0 || 0, 0), o = Math.max(e.r, 0), r = e.startAngle, s = e.endAngle, l = e.clockwise, h = Math.cos(r), u = Math.sin(r);
            t.moveTo(h * a + i, u * a + n), t.lineTo(h * o + i, u * o + n), t.arc(i, n, o, r, s, !l), 
            t.lineTo(Math.cos(s) * a + i, Math.sin(s) * a + n), 0 !== a && t.arc(i, n, a, s, r, l), 
            t.closePath();
        }
    }), Bv = Wi.extend({
        type: "ring",
        shape: {
            cx: 0,
            cy: 0,
            r: 0,
            r0: 0
        },
        buildPath: function(t, e) {
            var i = e.cx, n = e.cy, a = 2 * Math.PI;
            t.moveTo(i + e.r, n), t.arc(i, n, e.r, 0, a, !1), t.moveTo(i + e.r0, n), t.arc(i, n, e.r0, 0, a, !0);
        }
    }), Vv = Wi.extend({
        type: "polygon",
        shape: {
            points: null,
            smooth: !1,
            smoothConstraint: null
        },
        buildPath: function(t, e) {
            Ui(t, e, !0);
        }
    }), Gv = Wi.extend({
        type: "polyline",
        shape: {
            points: null,
            smooth: !1,
            smoothConstraint: null
        },
        style: {
            stroke: "#000",
            fill: null
        },
        buildPath: function(t, e) {
            Ui(t, e, !1);
        }
    }), Wv = Wi.extend({
        type: "rect",
        shape: {
            r: 0,
            x: 0,
            y: 0,
            width: 0,
            height: 0
        },
        buildPath: function(t, e) {
            var i = e.x, n = e.y, a = e.width, o = e.height;
            e.r ? we(t, e) : t.rect(i, n, a, o), t.closePath();
        }
    }), Fv = Wi.extend({
        type: "line",
        shape: {
            x1: 0,
            y1: 0,
            x2: 0,
            y2: 0,
            percent: 1
        },
        style: {
            stroke: "#000",
            fill: null
        },
        buildPath: function(t, e) {
            var i = e.x1, n = e.y1, a = e.x2, o = e.y2, r = e.percent;
            0 !== r && (t.moveTo(i, n), r < 1 && (a = i * (1 - r) + a * r, o = n * (1 - r) + o * r), 
            t.lineTo(a, o));
        },
        pointAt: function(t) {
            var e = this.shape;
            return [ e.x1 * (1 - t) + e.x2 * t, e.y1 * (1 - t) + e.y2 * t ];
        }
    }), Hv = [], Zv = Wi.extend({
        type: "bezier-curve",
        shape: {
            x1: 0,
            y1: 0,
            x2: 0,
            y2: 0,
            cpx1: 0,
            cpy1: 0,
            percent: 1
        },
        style: {
            stroke: "#000",
            fill: null
        },
        buildPath: function(t, e) {
            var i = e.x1, n = e.y1, a = e.x2, o = e.y2, r = e.cpx1, s = e.cpy1, l = e.cpx2, h = e.cpy2, u = e.percent;
            0 !== u && (t.moveTo(i, n), null == l || null == h ? (u < 1 && (Ti(i, r, a, u, Hv), 
            r = Hv[1], a = Hv[2], Ti(n, s, o, u, Hv), s = Hv[1], o = Hv[2]), t.quadraticCurveTo(r, s, a, o)) : (u < 1 && (bi(i, r, l, a, u, Hv), 
            r = Hv[1], l = Hv[2], a = Hv[3], bi(n, s, h, o, u, Hv), s = Hv[1], h = Hv[2], o = Hv[3]), 
            t.bezierCurveTo(r, s, l, h, a, o)));
        },
        pointAt: function(t) {
            return ji(this.shape, t, !1);
        },
        tangentAt: function(t) {
            var e = ji(this.shape, t, !0);
            return q(e, e);
        }
    }), Uv = Wi.extend({
        type: "arc",
        shape: {
            cx: 0,
            cy: 0,
            r: 0,
            startAngle: 0,
            endAngle: 2 * Math.PI,
            clockwise: !0
        },
        style: {
            stroke: "#000",
            fill: null
        },
        buildPath: function(t, e) {
            var i = e.cx, n = e.cy, a = Math.max(e.r, 0), o = e.startAngle, r = e.endAngle, s = e.clockwise, l = Math.cos(o), h = Math.sin(o);
            t.moveTo(l * a + i, h * a + n), t.arc(i, n, a, o, r, !s);
        }
    }), jv = Wi.extend({
        type: "compound",
        shape: {
            paths: null
        },
        _updatePathDirty: function() {
            for (var t = this.__dirtyPath, e = this.shape.paths, i = 0; i < e.length; i++) t = t || e[i].__dirtyPath;
            this.__dirtyPath = t, this.__dirty = this.__dirty || t;
        },
        beforeBrush: function() {
            this._updatePathDirty();
            for (var t = this.shape.paths || [], e = this.getGlobalScale(), i = 0; i < t.length; i++) t[i].path || t[i].createPathProxy(), 
            t[i].path.setScale(e[0], e[1]);
        },
        buildPath: function(t, e) {
            for (var i = e.paths || [], n = 0; n < i.length; n++) i[n].buildPath(t, i[n].shape, !0);
        },
        afterBrush: function() {
            for (var t = this.shape.paths || [], e = 0; e < t.length; e++) t[e].__dirtyPath = !1;
        },
        getBoundingRect: function() {
            return this._updatePathDirty(), Wi.prototype.getBoundingRect.call(this);
        }
    }), Xv = function(t) {
        this.colorStops = t || [];
    };
    Xv.prototype = {
        constructor: Xv,
        addColorStop: function(t, e) {
            this.colorStops.push({
                offset: t,
                color: e
            });
        }
    };
    var Yv = function(t, e, i, n, a, o) {
        this.x = null == t ? 0 : t, this.y = null == e ? 0 : e, this.x2 = null == i ? 1 : i, 
        this.y2 = null == n ? 0 : n, this.type = "linear", this.global = o || !1, Xv.call(this, a);
    };
    Yv.prototype = {
        constructor: Yv
    }, o(Yv, Xv);
    var qv = function(t, e, i, n, a) {
        this.x = null == t ? .5 : t, this.y = null == e ? .5 : e, this.r = null == i ? .5 : i, 
        this.type = "radial", this.global = a || !1, Xv.call(this, n);
    };
    qv.prototype = {
        constructor: qv
    }, o(qv, Xv), Xi.prototype.incremental = !0, Xi.prototype.clearDisplaybles = function() {
        this._displayables = [], this._temporaryDisplayables = [], this._cursor = 0, this.dirty(), 
        this.notClear = !1;
    }, Xi.prototype.addDisplayable = function(t, e) {
        e ? this._temporaryDisplayables.push(t) : this._displayables.push(t), this.dirty();
    }, Xi.prototype.addDisplayables = function(t, e) {
        e = e || !1;
        for (var i = 0; i < t.length; i++) this.addDisplayable(t[i], e);
    }, Xi.prototype.eachPendingDisplayable = function(t) {
        for (e = this._cursor; e < this._displayables.length; e++) t && t(this._displayables[e]);
        for (var e = 0; e < this._temporaryDisplayables.length; e++) t && t(this._temporaryDisplayables[e]);
    }, Xi.prototype.update = function() {
        for (this.updateTransform(), t = this._cursor; t < this._displayables.length; t++) (e = this._displayables[t]).parent = this, 
        e.update(), e.parent = null;
        for (var t = 0; t < this._temporaryDisplayables.length; t++) {
            var e = this._temporaryDisplayables[t];
            e.parent = this, e.update(), e.parent = null;
        }
    }, Xi.prototype.brush = function(t, e) {
        for (i = this._cursor; i < this._displayables.length; i++) (n = this._temporaryDisplayables[i]).beforeBrush && n.beforeBrush(t), 
        n.brush(t, i === this._cursor ? null : this._displayables[i - 1]), n.afterBrush && n.afterBrush(t);
        this._cursor = i;
        for (var i = 0; i < this._temporaryDisplayables.length; i++) {
            var n = this._temporaryDisplayables[i];
            n.beforeBrush && n.beforeBrush(t), n.brush(t, 0 === i ? null : this._temporaryDisplayables[i - 1]), 
            n.afterBrush && n.afterBrush(t);
        }
        this._temporaryDisplayables = [], this.notClear = !0;
    };
    var Kv = [];
    Xi.prototype.getBoundingRect = function() {
        if (!this._rect) {
            for (var t = new Xt(1 / 0, 1 / 0, -1 / 0, -1 / 0), e = 0; e < this._displayables.length; e++) {
                var i = this._displayables[e], n = i.getBoundingRect().clone();
                i.needLocalTransform() && n.applyTransform(i.getLocalTransform(Kv)), t.union(n);
            }
            this._rect = t;
        }
        return this._rect;
    }, Xi.prototype.contain = function(t, e) {
        var i = this.transformCoordToLocal(t, e);
        if (this.getBoundingRect().contain(i[0], i[1])) for (var n = 0; n < this._displayables.length; n++) if (this._displayables[n].contain(t, e)) return !0;
        return !1;
    }, o(Xi, ze);
    var $v = Math.round, Jv = Math.max, Qv = Math.min, ty = {}, ey = function(t, e) {
        for (var i = [], n = t.length, a = 0; a < n; a++) {
            var o = t[a];
            o.path || o.createPathProxy(), o.__dirtyPath && o.buildPath(o.path, o.shape, !0), 
            i.push(o.path);
        }
        var r = new Wi(e);
        return r.createPathProxy(), r.buildPath = function(t) {
            t.appendPath(i);
            var e = t.getContext();
            e && t.rebuildPath(e);
        }, r;
    }, iy = (Object.freeze || Object)({
        extendShape: Yi,
        extendPath: function(t, e) {
            return Wi.extend(Hi(t, e));
        },
        makePath: qi,
        makeImage: Ki,
        mergePath: ey,
        resizePath: Ji,
        subPixelOptimizeLine: Qi,
        subPixelOptimizeRect: tn,
        subPixelOptimize: en,
        setHoverStyle: gn,
        setLabelStyle: mn,
        setTextStyle: vn,
        setText: function(t, e, i) {
            var n, a = {
                isRectText: !0
            };
            !1 === i ? n = !0 : a.autoColor = i, yn(t, e, a, n), t.host && t.host.dirty && t.host.dirty(!1);
        },
        getFont: bn,
        updateProps: Mn,
        initProps: In,
        getTransform: Tn,
        applyTransform: Dn,
        transformDirection: An,
        groupTransition: Cn,
        clipPointsByRect: Ln,
        clipRectByRect: function(t, e) {
            var i = Jv(t.x, e.x), n = Qv(t.x + t.width, e.x + e.width), a = Jv(t.y, e.y), o = Qv(t.y + t.height, e.y + e.height);
            if (i <= n && a <= o) return {
                x: i,
                y: a,
                width: n - i,
                height: o - a
            };
        },
        createIcon: kn,
        Group: Dg,
        Image: Be,
        Text: Nv,
        Circle: Ov,
        Sector: zv,
        Ring: Bv,
        Polygon: Vv,
        Polyline: Gv,
        Rect: Wv,
        Line: Fv,
        BezierCurve: Zv,
        Arc: Uv,
        IncrementalDisplayable: Xi,
        CompoundPath: jv,
        LinearGradient: Yv,
        RadialGradient: qv,
        BoundingRect: Xt
    }), ny = [ "textStyle", "color" ], ay = {
        getTextColor: function(t) {
            var e = this.ecModel;
            return this.getShallow("color") || (!t && e ? e.get(ny) : null);
        },
        getFont: function() {
            return bn({
                fontStyle: this.getShallow("fontStyle"),
                fontWeight: this.getShallow("fontWeight"),
                fontSize: this.getShallow("fontSize"),
                fontFamily: this.getShallow("fontFamily")
            }, this.ecModel);
        },
        getTextRect: function(t) {
            return le(t, this.getFont(), this.getShallow("align"), this.getShallow("verticalAlign") || this.getShallow("baseline"), this.getShallow("padding"), this.getShallow("rich"), this.getShallow("truncateText"));
        }
    }, oy = Dm([ [ "fill", "color" ], [ "stroke", "borderColor" ], [ "lineWidth", "borderWidth" ], [ "opacity" ], [ "shadowBlur" ], [ "shadowOffsetX" ], [ "shadowOffsetY" ], [ "shadowColor" ], [ "textPosition" ], [ "textAlign" ] ]), ry = {
        getItemStyle: function(t, e) {
            var i = oy(this, t, e), n = this.getBorderLineDash();
            return n && (i.lineDash = n), i;
        },
        getBorderLineDash: function() {
            var t = this.get("borderType");
            return "solid" === t || null == t ? null : "dashed" === t ? [ 5, 5 ] : [ 1, 1 ];
        }
    }, sy = a, ly = si();
    Pn.prototype = {
        constructor: Pn,
        init: null,
        mergeOption: function(t) {
            g(this.option, t, !0);
        },
        get: function(t, e) {
            return null == t ? this.option : Nn(this.option, this.parsePath(t), !e && On(this, t));
        },
        getShallow: function(t, e) {
            var i = this.option, n = null == i ? i : i[t], a = !e && On(this, t);
            return null == n && a && (n = a.getShallow(t)), n;
        },
        getModel: function(t, e) {
            var i;
            return new Pn(null == t ? this.option : Nn(this.option, t = this.parsePath(t)), e = e || (i = On(this, t)) && i.getModel(t), this.ecModel);
        },
        isEmpty: function() {
            return null == this.option;
        },
        restoreData: function() {},
        clone: function() {
            return new this.constructor(A(this.option));
        },
        setReadOnly: function(t) {},
        parsePath: function(t) {
            return "string" == typeof t && (t = t.split(".")), t;
        },
        customizeGetParent: function(t) {
            ly(this).getParent = t;
        },
        isAnimationEnabled: function() {
            if (!Sp.node) {
                if (null != this.option.animation) return !!this.option.animation;
                if (this.parentModel) return this.parentModel.isAnimationEnabled();
            }
        }
    }, di(Pn), fi(Pn), sy(Pn, Cm), sy(Pn, km), sy(Pn, ay), sy(Pn, ry);
    var hy, uy, cy = 0, dy = 1e-4, fy = 9007199254740991, py = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d\d)(?::(\d\d)(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/, gy = (Object.freeze || Object)({
        linearMap: Rn,
        parsePercent: zn,
        round: Bn,
        asc: Vn,
        getPrecision: Gn,
        getPrecisionSafe: Wn,
        getPixelPrecision: Fn,
        getPercentWithPrecision: Hn,
        MAX_SAFE_INTEGER: fy,
        remRadian: Zn,
        isRadianAroundZero: Un,
        parseDate: jn,
        quantity: Xn,
        nice: qn,
        reformIntervals: Kn,
        isNumeric: $n
    }), my = l, vy = /([&<>"'])/g, yy = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
    }, xy = [ "a", "b", "c", "d", "e", "f", "g" ], _y = function(t, e) {
        return "{" + t + (null == e ? "" : e) + "}";
    }, wy = de, by = le, Sy = (Object.freeze || Object)({
        addCommas: Jn,
        toCamelCase: Qn,
        normalizeCssArray: my,
        encodeHTML: ta,
        formatTpl: ea,
        formatTplSimple: ia,
        getTooltipMarker: na,
        formatTime: oa,
        capitalFirst: ra,
        truncateText: wy,
        getTextRect: by
    }), My = R, Iy = [ "left", "right", "top", "bottom", "width", "height" ], Ty = [ [ "width", "left", "right" ], [ "height", "top", "bottom" ] ], Dy = sa, Ay = (z(sa, "vertical"), 
    z(sa, "horizontal"), si()), Cy = Pn.extend({
        type: "component",
        id: "",
        name: "",
        mainType: "",
        subType: "",
        componentIndex: 0,
        defaultOption: null,
        ecModel: null,
        dependentModels: [],
        uid: null,
        layoutMode: null,
        $constructor: function(t, e, i, n) {
            Pn.call(this, t, e, i, n), this.uid = En("ec_cpt_model");
        },
        init: function(t, e, i, n) {
            this.mergeDefaultAndTheme(t, i);
        },
        mergeDefaultAndTheme: function(t, e) {
            var i = this.layoutMode, n = i ? ca(t) : {};
            g(t, e.getTheme().get(this.mainType)), g(t, this.getDefaultOption()), i && ua(t, n, i);
        },
        mergeOption: function(t, e) {
            g(this.option, t, !0);
            var i = this.layoutMode;
            i && ua(this.option, t, i);
        },
        optionUpdated: function(t, e) {},
        getDefaultOption: function() {
            var t = Ay(this);
            if (!t.defaultOption) {
                for (var e = [], i = this.constructor; i; ) {
                    var n = i.prototype.defaultOption;
                    n && e.push(n), i = i.superClass;
                }
                for (var a = {}, o = e.length - 1; 0 <= o; o--) a = g(a, e[o], !0);
                t.defaultOption = a;
            }
            return t.defaultOption;
        },
        getReferringComponents: function(t) {
            return this.ecModel.queryComponents({
                mainType: t,
                index: this.get(t + "Index", !0),
                id: this.get(t + "Id", !0)
            });
        }
    });
    mi(Cy, {
        registerWhenExtend: !0
    }), uy = {}, (hy = Cy).registerSubTypeDefaulter = function(t, e) {
        t = ci(t), uy[t.main] = e;
    }, hy.determineSubType = function(t, e) {
        var i = e.type;
        if (!i) {
            var n = ci(t).main;
            hy.hasSubTypes(t) && uy[n] && (i = uy[n](e));
        }
        return i;
    }, function(t, e) {
        function d(l) {
            var h = {}, u = [];
            return R(l, function(i) {
                var t, e, n, a, o, r = c(h, i), s = (t = r.originalDeps = (a = i, o = [], R(Cy.getClassesByMainType(a), function(t) {
                    o = o.concat(t.prototype.dependencies || []);
                }), o = L(o, function(t) {
                    return ci(t).main;
                }), "dataset" !== a && C(o, "dataset") <= 0 && o.unshift("dataset"), o), e = l, 
                n = [], R(t, function(t) {
                    0 <= C(e, t) && n.push(t);
                }), n);
                r.entryCount = s.length, 0 === r.entryCount && u.push(i), R(s, function(t) {
                    C(r.predecessor, t) < 0 && r.predecessor.push(t);
                    var e = c(h, t);
                    C(e.successor, t) < 0 && e.successor.push(i);
                });
            }), {
                graph: h,
                noEntryList: u
            };
        }
        function c(t, e) {
            return t[e] || (t[e] = {
                predecessor: [],
                successor: []
            }), t[e];
        }
        Cy.topologicalTravel = function(t, e, i, n) {
            function a(t) {
                r[t].entryCount--, 0 === r[t].entryCount && s.push(t);
            }
            if (t.length) {
                var o = d(e), r = o.graph, s = o.noEntryList, l = {};
                for (R(t, function(t) {
                    l[t] = !0;
                }); s.length; ) {
                    var h = s.pop(), u = r[h], c = !!l[h];
                    c && (i.call(n, h, u.originalDeps.slice()), delete l[h]), R(u.successor, c ? function(t) {
                        l[t] = !0, a(t);
                    } : a);
                }
                R(l, function() {
                    throw new Error("Circle dependency may exists");
                });
            }
        };
    }(), a(Cy, {
        getBoxLayoutParams: function() {
            return {
                left: this.get("left"),
                top: this.get("top"),
                right: this.get("right"),
                bottom: this.get("bottom"),
                width: this.get("width"),
                height: this.get("height")
            };
        }
    });
    var Ly = "";
    "undefined" != typeof navigator && (Ly = navigator.platform || "");
    var ky = {
        color: [ "#c23531", "#2f4554", "#61a0a8", "#d48265", "#91c7ae", "#749f83", "#ca8622", "#bda29a", "#6e7074", "#546570", "#c4ccd3" ],
        gradientColor: [ "#f6efa6", "#d88273", "#bf444c" ],
        textStyle: {
            fontFamily: Ly.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
            fontSize: 12,
            fontStyle: "normal",
            fontWeight: "normal"
        },
        blendMode: null,
        animation: "auto",
        animationDuration: 1e3,
        animationDurationUpdate: 300,
        animationEasing: "exponentialOut",
        animationEasingUpdate: "cubicOut",
        animationThreshold: 2e3,
        progressiveThreshold: 3e3,
        progressive: 400,
        hoverLayerThreshold: 3e3,
        useUTC: !1
    }, Py = si(), Ny = {
        clearColorPalette: function() {
            Py(this).colorIdx = 0, Py(this).colorNameMap = {};
        },
        getColorFromPalette: function(t, e, i) {
            var n = Py(e = e || this), a = n.colorIdx || 0, o = n.colorNameMap = n.colorNameMap || {};
            if (o.hasOwnProperty(t)) return o[t];
            var r = Qe(this.get("color", !0)), s = this.get("colorLayer", !0), l = null != i && s ? function(t, e) {
                for (var i = t.length, n = 0; n < i; n++) if (t[n].length > e) return t[n];
                return t[i - 1];
            }(s, i) : r;
            if ((l = l || r) && l.length) {
                var h = l[a];
                return t && (o[t] = h), n.colorIdx = (a + 1) % l.length, h;
            }
        }
    }, Oy = {
        cartesian2d: function(t, e, i, n) {
            var a = t.getReferringComponents("xAxis")[0], o = t.getReferringComponents("yAxis")[0];
            e.coordSysDims = [ "x", "y" ], i.set("x", a), i.set("y", o), pa(a) && (n.set("x", a), 
            e.firstCategoryDimIndex = 0), pa(o) && (n.set("y", o), e.firstCategoryDimIndex = 1);
        },
        singleAxis: function(t, e, i, n) {
            var a = t.getReferringComponents("singleAxis")[0];
            e.coordSysDims = [ "single" ], i.set("single", a), pa(a) && (n.set("single", a), 
            e.firstCategoryDimIndex = 0);
        },
        polar: function(t, e, i, n) {
            var a = t.getReferringComponents("polar")[0], o = a.findAxisModel("radiusAxis"), r = a.findAxisModel("angleAxis");
            e.coordSysDims = [ "radius", "angle" ], i.set("radius", o), i.set("angle", r), pa(o) && (n.set("radius", o), 
            e.firstCategoryDimIndex = 0), pa(r) && (n.set("angle", r), e.firstCategoryDimIndex = 1);
        },
        geo: function(t, e, i, n) {
            e.coordSysDims = [ "lng", "lat" ];
        },
        parallel: function(t, a, o, r) {
            var s = t.ecModel, e = s.getComponent("parallel", t.get("parallelIndex")), l = a.coordSysDims = e.dimensions.slice();
            R(e.parallelAxisIndex, function(t, e) {
                var i = s.getComponent("parallelAxis", t), n = l[e];
                o.set(n, i), pa(i) && null == a.firstCategoryDimIndex && (r.set(n, i), a.firstCategoryDimIndex = e);
            });
        }
    }, Ey = "original", Ry = "arrayRows", zy = "objectRows", By = "keyedColumns", Vy = "unknown", Gy = "typedArray", Wy = "column", Fy = "row";
    ga.seriesDataToSource = function(t) {
        return new ga({
            data: t,
            sourceFormat: v(t) ? Gy : Ey,
            fromDataset: !1
        });
    }, fi(ga);
    var Hy = si(), Zy = "\0_ec_inner", Uy = Pn.extend({
        init: function(t, e, i, n) {
            i = i || {}, this.option = null, this._theme = new Pn(i), this._optionManager = n;
        },
        setOption: function(t, e) {
            c(!(Zy in t), "please use chart.getOption()"), this._optionManager.setOption(t, e), 
            this.resetOption(null);
        },
        resetOption: function(t) {
            var e = !1, i = this._optionManager;
            if (!t || "recreate" === t) {
                var n = i.mountOption("recreate" === t);
                this.option && "recreate" !== t ? (this.restoreData(), this.mergeOption(n)) : _a.call(this, n), 
                e = !0;
            }
            if ("timeline" !== t && "media" !== t || this.restoreData(), !t || "recreate" === t || "timeline" === t) {
                var a = i.getTimelineOption(this);
                a && (this.mergeOption(a), e = !0);
            }
            if (!t || "recreate" === t || "media" === t) {
                var o = i.getMediaOption(this, this._api);
                o.length && R(o, function(t) {
                    this.mergeOption(t, e = !0);
                }, this);
            }
            return e;
        },
        mergeOption: function(n) {
            var l = this.option, h = this._componentsMap, i = [];
            Hy(this).datasetMap = W(), R(n, function(t, e) {
                null != t && (Cy.hasClass(e) ? e && i.push(e) : l[e] = null == l[e] ? A(t) : g(l[e], t, !0));
            }), Cy.topologicalTravel(i, Cy.getAllClassMainTypes(), function(r, t) {
                var e = Qe(n[r]), i = ii(h.get(r), e);
                ni(i), R(i, function(t, e) {
                    var i, n, a, o = t.option;
                    B(o) && (t.keyInfo.mainType = r, t.keyInfo.subType = (i = r, n = o, a = t.exist, 
                    n.type ? n.type : a ? a.subType : Cy.determineSubType(i, n)));
                });
                var s = function(e, t) {
                    N(t) || (t = t ? [ t ] : []);
                    var i = {};
                    return R(t, function(t) {
                        i[t] = (e.get(t) || []).slice();
                    }), i;
                }(h, t);
                l[r] = [], h.set(r, []), R(i, function(t, e) {
                    var i = t.exist, n = t.option;
                    if (c(B(n) || i, "Empty component definition"), n) {
                        var a = Cy.getClass(r, t.keyInfo.subType, !0);
                        if (i && i instanceof a) i.name = t.keyInfo.name, i.mergeOption(n, this), i.optionUpdated(n, !1); else {
                            var o = P({
                                dependentModels: s,
                                componentIndex: e
                            }, t.keyInfo);
                            P(i = new a(n, this, this, o), o), i.init(n, this, this, o), i.optionUpdated(null, !0);
                        }
                    } else i.mergeOption({}, this), i.optionUpdated({}, !1);
                    h.get(r)[e] = i, l[r][e] = i.option;
                }, this), "series" === r && wa(this, h.get("series"));
            }, this), this._seriesIndicesMap = W(this._seriesIndices = this._seriesIndices || []);
        },
        getOption: function() {
            var n = A(this.option);
            return R(n, function(t, e) {
                if (Cy.hasClass(e)) {
                    for (var i = (t = Qe(t)).length - 1; 0 <= i; i--) oi(t[i]) && t.splice(i, 1);
                    n[e] = t;
                }
            }), delete n[Zy], n;
        },
        getTheme: function() {
            return this._theme;
        },
        getComponent: function(t, e) {
            var i = this._componentsMap.get(t);
            if (i) return i[e || 0];
        },
        queryComponents: function(t) {
            var e = t.mainType;
            if (!e) return [];
            var i, n = t.index, a = t.id, o = t.name, r = this._componentsMap.get(e);
            if (!r || !r.length) return [];
            if (null != n) N(n) || (n = [ n ]), i = I(L(n, function(t) {
                return r[t];
            }), function(t) {
                return !!t;
            }); else if (null != a) {
                var s = N(a);
                i = I(r, function(t) {
                    return s && 0 <= C(a, t.id) || !s && t.id === a;
                });
            } else if (null != o) {
                var l = N(o);
                i = I(r, function(t) {
                    return l && 0 <= C(o, t.name) || !l && t.name === o;
                });
            } else i = r.slice();
            return ba(i, t);
        },
        findComponents: function(t) {
            var e, i, n, a, o, r = t.query, s = t.mainType, l = (i = s + "Index", n = s + "Id", 
            a = s + "Name", !(e = r) || null == e[i] && null == e[n] && null == e[a] ? null : {
                mainType: s,
                index: e[i],
                id: e[n],
                name: e[a]
            });
            return o = ba(l ? this.queryComponents(l) : this._componentsMap.get(s), t), t.filter ? I(o, t.filter) : o;
        },
        eachComponent: function(t, n, a) {
            var e = this._componentsMap;
            "function" == typeof t ? (a = n, n = t, e.each(function(t, i) {
                R(t, function(t, e) {
                    n.call(a, i, t, e);
                });
            })) : b(t) ? R(e.get(t), n, a) : B(t) && R(this.findComponents(t), n, a);
        },
        getSeriesByName: function(e) {
            return I(this._componentsMap.get("series"), function(t) {
                return t.name === e;
            });
        },
        getSeriesByIndex: function(t) {
            return this._componentsMap.get("series")[t];
        },
        getSeriesByType: function(e) {
            return I(this._componentsMap.get("series"), function(t) {
                return t.subType === e;
            });
        },
        getSeries: function() {
            return this._componentsMap.get("series").slice();
        },
        getSeriesCount: function() {
            return this._componentsMap.get("series").length;
        },
        eachSeries: function(i, n) {
            R(this._seriesIndices, function(t) {
                var e = this._componentsMap.get("series")[t];
                i.call(n, e, t);
            }, this);
        },
        eachRawSeries: function(t, e) {
            R(this._componentsMap.get("series"), t, e);
        },
        eachSeriesByType: function(i, n, a) {
            R(this._seriesIndices, function(t) {
                var e = this._componentsMap.get("series")[t];
                e.subType === i && n.call(a, e, t);
            }, this);
        },
        eachRawSeriesByType: function(t, e, i) {
            return R(this.getSeriesByType(t), e, i);
        },
        isSeriesFiltered: function(t) {
            return null == this._seriesIndicesMap.get(t.componentIndex);
        },
        getCurrentSeriesIndices: function() {
            return (this._seriesIndices || []).slice();
        },
        filterSeries: function(t, e) {
            wa(this, I(this._componentsMap.get("series"), t, e));
        },
        restoreData: function(i) {
            var n = this._componentsMap;
            wa(this, n.get("series"));
            var a = [];
            n.each(function(t, e) {
                a.push(e);
            }), Cy.topologicalTravel(a, Cy.getAllClassMainTypes(), function(e, t) {
                R(n.get(e), function(t) {
                    ("series" !== e || !function(t, e) {
                        if (e) {
                            var i = e.seiresIndex, n = e.seriesId, a = e.seriesName;
                            return null != i && t.componentIndex !== i || null != n && t.id !== n || null != a && t.name !== a;
                        }
                    }(t, i)) && t.restoreData();
                });
            });
        }
    });
    a(Uy, Ny);
    var jy = [ "getDom", "getZr", "getWidth", "getHeight", "getDevicePixelRatio", "dispatchAction", "isDisposed", "on", "off", "getDataURL", "getConnectedDataURL", "getModel", "getOption", "getViewOfComponentModel", "getViewOfSeriesModel" ], Xy = {};
    Ma.prototype = {
        constructor: Ma,
        create: function(n, a) {
            var o = [];
            R(Xy, function(t, e) {
                var i = t.create(n, a);
                o = o.concat(i || []);
            }), this._coordinateSystems = o;
        },
        update: function(e, i) {
            R(this._coordinateSystems, function(t) {
                t.update && t.update(e, i);
            });
        },
        getCoordinateSystems: function() {
            return this._coordinateSystems.slice();
        }
    }, Ma.register = function(t, e) {
        Xy[t] = e;
    }, Ma.get = function(t) {
        return Xy[t];
    };
    var Yy = R, qy = A, Ky = L, $y = g, Jy = /^(min|max)?(.+)$/;
    Ia.prototype = {
        constructor: Ia,
        setOption: function(t, e) {
            t && R(Qe(t.series), function(t) {
                t && t.data && v(t.data) && d(t.data);
            }), t = qy(t, !0);
            var a, i, n = this._optionBackup, o = function(t, i, n) {
                var e, a, o = [], r = [], s = t.timeline;
                if (t.baseOption && (a = t.baseOption), (s || t.options) && (a = a || {}, o = (t.options || []).slice()), 
                t.media) {
                    a = a || {};
                    var l = t.media;
                    Yy(l, function(t) {
                        t && t.option && (t.query ? r.push(t) : e || (e = t));
                    });
                }
                return a || (a = t), a.timeline || (a.timeline = s), Yy([ a ].concat(o).concat(L(r, function(t) {
                    return t.option;
                })), function(e) {
                    Yy(i, function(t) {
                        t(e, n);
                    });
                }), {
                    baseOption: a,
                    timelineOptions: o,
                    mediaDefault: e,
                    mediaList: r
                };
            }.call(this, t, e, !n);
            this._newBaseOption = o.baseOption, n ? (a = n.baseOption, i = o.baseOption, Yy(i = i || {}, function(t, e) {
                if (null != t) {
                    var i = a[e];
                    if (Cy.hasClass(e)) {
                        t = Qe(t);
                        var n = ii(i = Qe(i), t);
                        a[e] = Ky(n, function(t) {
                            return t.option && t.exist ? $y(t.exist, t.option, !0) : t.exist || t.option;
                        });
                    } else a[e] = $y(i, t, !0);
                }
            }), o.timelineOptions.length && (n.timelineOptions = o.timelineOptions), o.mediaList.length && (n.mediaList = o.mediaList), 
            o.mediaDefault && (n.mediaDefault = o.mediaDefault)) : this._optionBackup = o;
        },
        mountOption: function(t) {
            var e = this._optionBackup;
            return this._timelineOptions = Ky(e.timelineOptions, qy), this._mediaList = Ky(e.mediaList, qy), 
            this._mediaDefault = qy(e.mediaDefault), this._currentMediaIndices = [], qy(t ? e.baseOption : this._newBaseOption);
        },
        getTimelineOption: function(t) {
            var e, i = this._timelineOptions;
            if (i.length) {
                var n = t.getComponent("timeline");
                n && (e = qy(i[n.getCurrentIndex()], !0));
            }
            return e;
        },
        getMediaOption: function(t) {
            var e, i, n = this._api.getWidth(), a = this._api.getHeight(), o = this._mediaList, r = this._mediaDefault, s = [], l = [];
            if (!o.length && !r) return l;
            for (var h = 0, u = o.length; h < u; h++) Ta(o[h].query, n, a) && s.push(h);
            return !s.length && r && (s = [ -1 ]), s.length && (e = s, i = this._currentMediaIndices, 
            !(e.join(",") === i.join(","))) && (l = Ky(s, function(t) {
                return qy(-1 === t ? r.option : o[t].option);
            })), this._currentMediaIndices = s, l;
        }
    };
    var Qy = R, tx = B, ex = [ "areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine" ], ix = function(e, t) {
        Qy(Pa(e.series), function(t) {
            tx(t) && function(t) {
                if (tx(t)) {
                    Da(t), Ca(t), La(t, "label"), La(t, "upperLabel"), La(t, "edgeLabel"), t.emphasis && (La(t.emphasis, "label"), 
                    La(t.emphasis, "upperLabel"), La(t.emphasis, "edgeLabel"));
                    var e = t.markPoint;
                    e && (Da(e), ka(e));
                    var i = t.markLine;
                    i && (Da(i), ka(i));
                    var n = t.markArea;
                    n && ka(n);
                    var a = t.data;
                    if ("graph" === t.type) {
                        a = a || t.nodes;
                        var o = t.links || t.edges;
                        if (o && !v(o)) for (s = 0; s < o.length; s++) ka(o[s]);
                        R(t.categories, function(t) {
                            Ca(t);
                        });
                    }
                    if (a && !v(a)) for (s = 0; s < a.length; s++) ka(a[s]);
                    if ((e = t.markPoint) && e.data) for (var r = e.data, s = 0; s < r.length; s++) ka(r[s]);
                    if ((i = t.markLine) && i.data) {
                        var l = i.data;
                        for (s = 0; s < l.length; s++) N(l[s]) ? (ka(l[s][0]), ka(l[s][1])) : ka(l[s]);
                    }
                    "gauge" === t.type ? (La(t, "axisLabel"), La(t, "title"), La(t, "detail")) : "treemap" === t.type ? (Aa(t.breadcrumb, "itemStyle"), 
                    R(t.levels, function(t) {
                        Ca(t);
                    })) : "tree" === t.type && Ca(t.leaves);
                }
            }(t);
        });
        var i = [ "xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "parallelAxis", "radar" ];
        t && i.push("valueAxis", "categoryAxis", "logAxis", "timeAxis"), Qy(i, function(t) {
            Qy(Pa(e[t]), function(t) {
                t && (La(t, "axisLabel"), La(t.axisPointer, "label"));
            });
        }), Qy(Pa(e.parallel), function(t) {
            var e = t && t.parallelAxisDefault;
            La(e, "axisLabel"), La(e && e.axisPointer, "label");
        }), Qy(Pa(e.calendar), function(t) {
            Aa(t, "itemStyle"), La(t, "dayLabel"), La(t, "monthLabel"), La(t, "yearLabel");
        }), Qy(Pa(e.radar), function(t) {
            La(t, "name");
        }), Qy(Pa(e.geo), function(t) {
            tx(t) && (ka(t), Qy(Pa(t.regions), function(t) {
                ka(t);
            }));
        }), Qy(Pa(e.timeline), function(t) {
            ka(t), Aa(t, "label"), Aa(t, "itemStyle"), Aa(t, "controlStyle", !0);
            var e = t.data;
            N(e) && R(e, function(t) {
                B(t) && (Aa(t, "label"), Aa(t, "itemStyle"));
            });
        }), Qy(Pa(e.toolbox), function(t) {
            Aa(t, "iconStyle"), Qy(t.feature, function(t) {
                Aa(t, "iconStyle");
            });
        }), La(Na(e.axisPointer), "label"), La(Na(e.tooltip).axisPointer, "label");
    }, nx = [ [ "x", "left" ], [ "y", "top" ], [ "x2", "right" ], [ "y2", "bottom" ] ], ax = [ "grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline" ], ox = function(i, t) {
        ix(i, t), i.series = Qe(i.series), R(i.series, function(t) {
            if (B(t)) {
                var e = t.type;
                if ("pie" !== e && "gauge" !== e || null != t.clockWise && (t.clockwise = t.clockWise), 
                "gauge" === e) {
                    var i = function(t, e) {
                        e = e.split(",");
                        for (var i = t, n = 0; n < e.length && null != (i = i && i[e[n]]); n++) ;
                        return i;
                    }(t, "pointer.color");
                    null != i && function(t, e, i, n) {
                        e = e.split(",");
                        for (var a, o = t, r = 0; r < e.length - 1; r++) null == o[a = e[r]] && (o[a] = {}), 
                        o = o[a];
                        (n || null == o[e[r]]) && (o[e[r]] = i);
                    }(t, "itemStyle.normal.color", i);
                }
                Oa(t);
            }
        }), i.dataRange && (i.visualMap = i.dataRange), R(ax, function(t) {
            var e = i[t];
            e && (N(e) || (e = [ e ]), R(e, function(t) {
                Oa(t);
            }));
        });
    }, rx = Ra.prototype;
    rx.pure = !1;
    var sx = {
        arrayRows_column: {
            pure: rx.persistent = !0,
            count: function() {
                return Math.max(0, this._data.length - this._source.startIndex);
            },
            getItem: function(t) {
                return this._data[t + this._source.startIndex];
            },
            appendData: Va
        },
        arrayRows_row: {
            pure: !0,
            count: function() {
                var t = this._data[0];
                return t ? Math.max(0, t.length - this._source.startIndex) : 0;
            },
            getItem: function(t) {
                t += this._source.startIndex;
                for (var e = [], i = this._data, n = 0; n < i.length; n++) {
                    var a = i[n];
                    e.push(a ? a[t] : null);
                }
                return e;
            },
            appendData: function() {
                throw new Error('Do not support appendData when set seriesLayoutBy: "row".');
            }
        },
        objectRows: {
            pure: !0,
            count: za,
            getItem: Ba,
            appendData: Va
        },
        keyedColumns: {
            pure: !0,
            count: function() {
                var t = this._source.dimensionsDefine[0].name, e = this._data[t];
                return e ? e.length : 0;
            },
            getItem: function(t) {
                for (var e = [], i = this._source.dimensionsDefine, n = 0; n < i.length; n++) {
                    var a = this._data[i[n].name];
                    e.push(a ? a[t] : null);
                }
                return e;
            },
            appendData: function(t) {
                var a = this._data;
                R(t, function(t, e) {
                    for (var i = a[e] || (a[e] = []), n = 0; n < (t || []).length; n++) i.push(t[n]);
                });
            }
        },
        original: {
            count: za,
            getItem: Ba,
            appendData: Va
        },
        typedArray: {
            persistent: !(rx.getSource = function() {
                return this._source;
            }),
            pure: !0,
            count: function() {
                return this._data ? this._data.length / this._dimSize : 0;
            },
            getItem: function(t) {
                t -= this._offset;
                for (var e = [], i = this._dimSize * t, n = 0; n < this._dimSize; n++) e[n] = this._data[i + n];
                return e;
            },
            appendData: function(t) {
                this._data = t;
            },
            clean: function() {
                this._offset += this.count(), this._data = null;
            }
        }
    }, lx = {
        arrayRows: Ga,
        objectRows: function(t, e, i, n) {
            return null != i ? t[n] : t;
        },
        keyedColumns: Ga,
        original: function(t, e, i, n) {
            var a = ei(t);
            return null != i && a instanceof Array ? a[i] : a;
        },
        typedArray: Ga
    }, hx = {
        arrayRows: Wa,
        objectRows: function(t, e, i, n) {
            return Fa(t[e], this._dimensionInfos[e]);
        },
        keyedColumns: Wa,
        original: function(t, e, i, n) {
            var a, o = t && (null == t.value ? t : t.value);
            return !this._rawData.pure && (xm(a = t) && !(a instanceof Array)) && (this.hasItemOption = !0), 
            Fa(o instanceof Array ? o[n] : o, this._dimensionInfos[e]);
        },
        typedArray: function(t, e, i, n) {
            return t[n];
        }
    }, ux = /\{@(.+?)\}/g, cx = {
        getDataParams: function(t, e) {
            var i = this.getData(e), n = this.getRawValue(t, e), a = i.getRawIndex(t), o = i.getName(t, !0), r = i.getRawDataItem(t), s = i.getItemVisual(t, "color");
            return {
                componentType: this.mainType,
                componentSubType: this.subType,
                seriesType: "series" === this.mainType ? this.subType : null,
                seriesIndex: this.seriesIndex,
                seriesId: this.id,
                seriesName: this.name,
                name: o,
                dataIndex: a,
                data: r,
                dataType: e,
                value: n,
                color: s,
                marker: na(s),
                $vars: [ "seriesName", "name", "value" ]
            };
        },
        getFormattedLabel: function(n, t, e, i, a) {
            t = t || "normal";
            var o = this.getData(e), r = o.getItemModel(n), s = this.getDataParams(n, e);
            null != i && s.value instanceof Array && (s.value = s.value[i]);
            var l = r.get("normal" === t ? [ a || "label", "formatter" ] : [ t, a || "label", "formatter" ]);
            return "function" == typeof l ? (s.status = t, l(s)) : "string" == typeof l ? ea(l, s).replace(ux, function(t, e) {
                var i = e.length;
                return "[" === e.charAt(0) && "]" === e.charAt(i - 1) && (e = +e.slice(1, i - 1)), 
                Ha(o, n, e);
            }) : void 0;
        },
        getRawValue: function(t, e) {
            return Ha(this.getData(e), t);
        },
        formatTooltip: function() {}
    }, dx = ja.prototype;
    dx.perform = function(t) {
        var e, i, n = this._upstream, a = t && t.skip;
        if (this._dirty && n) {
            var o = this.context;
            o.data = o.outputData = n.context.outputData;
        }
        this.__pipeline && (this.__pipeline.currentTask = this), this._plan && !a && (e = this._plan(this.context)), 
        (this._dirty || "reset" === e) && (this._dirty = !1, i = function(t, e) {
            var i, n;
            t._dueIndex = t._outputDueEnd = t._dueEnd = 0, t._settedOutputEnd = null, !e && t._reset && (i = t._reset(t.context)) && i.progress && (n = i.forceFirstProgress, 
            i = i.progress), t._progress = i;
            var a = t._downstream;
            return a && a.dirty(), n;
        }(this, a));
        var r = t && t.step;
        if (this._dueEnd = n ? n._outputDueEnd : this._count ? this._count(this.context) : 1 / 0, 
        this._progress) {
            var s = this._dueIndex, l = Math.min(null != r ? this._dueIndex + r : 1 / 0, this._dueEnd);
            !a && (i || s < l) && this._progress({
                start: s,
                end: l
            }, this.context), this._dueIndex = l;
            var h = null != this._settedOutputEnd ? this._settedOutputEnd : l;
            this._outputDueEnd = h;
        } else this._dueIndex = this._outputDueEnd = null != this._settedOutputEnd ? this._settedOutputEnd : this._dueEnd;
        return this.unfinished();
    }, dx.dirty = function() {
        this._dirty = !0, this._onDirty && this._onDirty(this.context);
    }, dx.unfinished = function() {
        return this._progress && this._dueIndex < this._dueEnd;
    }, dx.pipe = function(t) {
        (this._downstream !== t || this._dirty) && ((this._downstream = t)._upstream = this, 
        t.dirty());
    }, dx.dispose = function() {
        this._disposed || (this._upstream && (this._upstream._downstream = null), this._downstream && (this._downstream._upstream = null), 
        this._dirty = !1, this._disposed = !0);
    }, dx.getUpstream = function() {
        return this._upstream;
    }, dx.getDownstream = function() {
        return this._downstream;
    }, dx.setOutputEnd = function(t) {
        this._outputDueEnd = this._settedOutputEnd = t;
    };
    var fx = si(), px = Cy.extend({
        type: "series.__base__",
        seriesIndex: 0,
        coordinateSystem: null,
        defaultOption: null,
        legendDataProvider: null,
        visualColorAccessPath: "itemStyle.color",
        layoutMode: null,
        init: function(t, e, i, n) {
            this.seriesIndex = this.componentIndex, this.dataTask = Ua({
                count: Ya,
                reset: qa
            }), this.dataTask.context = {
                model: this
            }, this.mergeDefaultAndTheme(t, i), ma(this);
            var a = this.getInitialData(t, i);
            $a(a, this), this.dataTask.context.data = a, fx(this).dataBeforeProcessed = a, Xa(this);
        },
        mergeDefaultAndTheme: function(t, e) {
            var i = this.layoutMode, n = i ? ca(t) : {}, a = this.subType;
            Cy.hasClass(a) && (a += "Series"), g(t, e.getTheme().get(this.subType)), g(t, this.getDefaultOption()), 
            ti(t, "label", [ "show" ]), this.fillDataTextStyle(t.data), i && ua(t, n, i);
        },
        mergeOption: function(t, e) {
            t = g(this.option, t, !0), this.fillDataTextStyle(t.data);
            var i = this.layoutMode;
            i && ua(this.option, t, i), ma(this);
            var n = this.getInitialData(t, e);
            $a(n, this), this.dataTask.dirty(), this.dataTask.context.data = n, fx(this).dataBeforeProcessed = n, 
            Xa(this);
        },
        fillDataTextStyle: function(t) {
            if (t) for (var e = [ "show" ], i = 0; i < t.length; i++) t[i] && t[i].label && ti(t[i], "label", e);
        },
        getInitialData: function() {},
        appendData: function(t) {
            this.getRawData().appendData(t.data);
        },
        getData: function(t) {
            var e = Qa(this);
            if (e) {
                var i = e.context.data;
                return null == t ? i : i.getLinkedData(t);
            }
            return fx(this).data;
        },
        setData: function(t) {
            var e = Qa(this);
            if (e) {
                var i = e.context;
                i.data !== t && e.isOverallFilter && e.setOutputEnd(t.count()), i.outputData = t, 
                e !== this.dataTask && (i.data = t);
            }
            fx(this).data = t;
        },
        getSource: function() {
            return Hy(this).source;
        },
        getRawData: function() {
            return fx(this).dataBeforeProcessed;
        },
        getBaseAxis: function() {
            var t = this.coordinateSystem;
            return t && t.getBaseAxis && t.getBaseAxis();
        },
        formatTooltip: function(i, l, t) {
            var h = this.getData(), n = h.mapDimension("defaultedTooltip", !0), e = n.length, a = this.getRawValue(i), o = N(a), u = h.getItemVisual(i, "color");
            B(u) && u.colorStops && (u = (u.colorStops[0] || {}).color), u = u || "transparent";
            var r = 1 < e || o && !e ? function(t) {
                function e(t, e) {
                    var i = h.getDimensionInfo(e);
                    if (i && !1 !== i.otherDims.tooltip) {
                        var n = i.type, a = na({
                            color: u,
                            type: "subItem"
                        }), o = (r ? a + ta(i.displayName || "-") + ": " : "") + ta("ordinal" === n ? t + "" : "time" === n ? l ? "" : oa("yyyy/MM/dd hh:mm:ss", t) : Jn(t));
                        o && s.push(o);
                    }
                }
                var r = p(t, function(t, e, i) {
                    var n = h.getDimensionInfo(i);
                    return t | (n && !1 !== n.tooltip && null != n.displayName);
                }, 0), s = [];
                return n.length ? R(n, function(t) {
                    e(Ha(h, i, t), t);
                }) : R(t, e), (r ? "<br/>" : "") + s.join(r ? "<br/>" : ", ");
            }(a) : ta(Jn(e ? Ha(h, i, n[0]) : o ? a[0] : a)), s = na(u), c = h.getName(i), d = this.name;
            return ai(this) || (d = ""), d = d ? ta(d) + (l ? ": " : "<br/>") : "", l ? s + d + r : d + s + (c ? ta(c) + ": " + r : r);
        },
        isAnimationEnabled: function() {
            if (Sp.node) return !1;
            var t = this.getShallow("animation");
            return t && this.getData().count() > this.getShallow("animationThreshold") && (t = !1), 
            t;
        },
        restoreData: function() {
            this.dataTask.dirty();
        },
        getColorFromPalette: function(t, e, i) {
            var n = this.ecModel, a = Ny.getColorFromPalette.call(this, t, e, i);
            return a || (a = n.getColorFromPalette(t, e, i)), a;
        },
        coordDimToDataDim: function(t) {
            return this.getRawData().mapDimension(t, !0);
        },
        getProgressive: function() {
            return this.get("progressive");
        },
        getProgressiveThreshold: function() {
            return this.get("progressiveThreshold");
        },
        getAxisTooltipData: null,
        getTooltipPosition: null,
        pipeTask: null,
        preventIncremental: null,
        pipelineContext: null
    });
    a(px, cx), a(px, Ny);
    var gx = function() {
        this.group = new Dg(), this.uid = En("viewComponent");
    };
    gx.prototype = {
        constructor: gx,
        init: function(t, e) {},
        render: function(t, e, i, n) {},
        dispose: function() {}
    };
    var mx = gx.prototype;
    mx.updateView = mx.updateLayout = mx.updateVisual = function(t, e, i, n) {}, di(gx), 
    mi(gx, {
        registerWhenExtend: !0
    });
    var vx = function() {
        var s = si();
        return function(t) {
            var e = s(t), i = t.pipelineContext, n = e.large, a = e.canProgressiveRender, o = e.large = i.large, r = e.canProgressiveRender = i.canProgressiveRender;
            return !!(n ^ o || a ^ r) && "reset";
        };
    }, yx = si(), xx = vx(), _x = to.prototype = {
        type: "chart",
        init: function(t, e) {},
        render: function(t, e, i, n) {},
        highlight: function(t, e, i, n) {
            io(t.getData(), n, "emphasis");
        },
        downplay: function(t, e, i, n) {
            io(t.getData(), n, "normal");
        },
        remove: function(t, e) {
            this.group.removeAll();
        },
        dispose: function() {},
        incrementalPrepareRender: null,
        incrementalRender: null,
        updateTransform: null
    };
    _x.updateView = _x.updateLayout = _x.updateVisual = function(t, e, i, n) {
        this.render(t, e, i, n);
    }, di(to), mi(to, {
        registerWhenExtend: !0
    }), to.markUpdateMethod = function(t, e) {
        yx(t).updateMethod = e;
    };
    var bx = {
        incrementalPrepareRender: {
            progress: function(t, e) {
                e.view.incrementalRender(t, e.model, e.ecModel, e.api, e.payload);
            }
        },
        render: {
            forceFirstProgress: !0,
            progress: function(t, e) {
                e.view.render(e.model, e.ecModel, e.api, e.payload);
            }
        }
    }, Sx = "\0__throttleOriginMethod", Mx = "\0__throttleRate", Ix = "\0__throttleType", Tx = {
        createOnAllSeries: !0,
        performRawSeries: !0,
        reset: function(e, t) {
            var i = e.getData(), n = (e.visualColorAccessPath || "itemStyle.color").split("."), a = e.get(n) || e.getColorFromPalette(e.name, null, t.getSeriesCount());
            if (i.setVisual("color", a), !t.isSeriesFiltered(e)) return "function" != typeof a || a instanceof Xv || i.each(function(t) {
                i.setItemVisual(t, "color", a(e.getDataParams(t)));
            }), {
                dataEach: i.hasItemOption ? function(t, e) {
                    var i = t.getItemModel(e).get(n, !0);
                    null != i && t.setItemVisual(e, "color", i);
                } : null
            };
        }
    }, Dx = {
        toolbox: {
            brush: {
                title: {
                    rect: "矩形选择",
                    polygon: "圈选",
                    lineX: "横向选择",
                    lineY: "纵向选择",
                    keep: "保持选择",
                    clear: "清除选择"
                }
            },
            dataView: {
                title: "数据视图",
                lang: [ "数据视图", "关闭", "刷新" ]
            },
            dataZoom: {
                title: {
                    zoom: "区域缩放",
                    back: "区域缩放还原"
                }
            },
            magicType: {
                title: {
                    line: "切换为折线图",
                    bar: "切换为柱状图",
                    stack: "切换为堆叠",
                    tiled: "切换为平铺"
                }
            },
            restore: {
                title: "还原"
            },
            saveAsImage: {
                title: "保存为图片",
                lang: [ "右键另存为图片" ]
            }
        },
        series: {
            typeNames: {
                pie: "饼图",
                bar: "柱状图",
                line: "折线图",
                scatter: "散点图",
                effectScatter: "涟漪散点图",
                radar: "雷达图",
                tree: "树图",
                treemap: "矩形树图",
                boxplot: "箱型图",
                candlestick: "K线图",
                k: "K线图",
                heatmap: "热力图",
                map: "地图",
                parallel: "平行坐标图",
                lines: "线图",
                graph: "关系图",
                sankey: "桑基图",
                funnel: "漏斗图",
                gauge: "仪表盘图",
                pictorialBar: "象形柱图",
                themeRiver: "主题河流图",
                sunburst: "旭日图"
            }
        },
        aria: {
            general: {
                withTitle: "这是一个关于“{title}”的图表。",
                withoutTitle: "这是一个图表，"
            },
            series: {
                single: {
                    prefix: "",
                    withName: "图表类型是{seriesType}，表示{seriesName}。",
                    withoutName: "图表类型是{seriesType}。"
                },
                multiple: {
                    prefix: "它由{seriesCount}个图表系列组成。",
                    withName: "第{seriesId}个系列是一个表示{seriesName}的{seriesType}，",
                    withoutName: "第{seriesId}个系列是一个{seriesType}，",
                    separator: {
                        middle: "；",
                        end: "。"
                    }
                }
            },
            data: {
                allData: "其数据是——",
                partialData: "其中，前{displayCnt}项是——",
                withName: "{name}的数据是{value}",
                withoutName: "{value}",
                separator: {
                    middle: "，",
                    end: ""
                }
            }
        }
    }, Ax = function(t, e) {
        function c(t, e) {
            if ("string" != typeof t) return t;
            var i = t;
            return R(e, function(t, e) {
                i = i.replace(new RegExp("\\{\\s*" + e + "\\s*\\}", "g"), t);
            }), i;
        }
        function d(t) {
            var e = o.get(t);
            if (null == e) {
                for (var i = t.split("."), n = Dx.aria, a = 0; a < i.length; ++a) n = n[i[a]];
                return n;
            }
            return e;
        }
        var i, o = e.getModel("aria");
        if (o.get("show")) if (o.get("description")) t.setAttribute("aria-label", o.get("description")); else {
            var f = 0;
            e.eachSeries(function(t, e) {
                ++f;
            }, this);
            var n, p = o.get("data.maxCount") || 10, a = o.get("series.maxCount") || 10, g = Math.min(f, a);
            if (!(f < 1)) {
                var r = ((i = e.getModel("title").option) && i.length && (i = i[0]), i && i.text);
                n = r ? c(d("general.withTitle"), {
                    title: r
                }) : d("general.withoutTitle");
                var m = [];
                n += c(d(1 < f ? "series.multiple.prefix" : "series.single.prefix"), {
                    seriesCount: f
                }), e.eachSeries(function(t, e) {
                    if (e < g) {
                        var i, n = t.get("name"), a = "series." + (1 < f ? "multiple" : "single") + ".";
                        i = c(i = d(n ? a + "withName" : a + "withoutName"), {
                            seriesId: t.seriesIndex,
                            seriesName: t.get("name"),
                            seriesType: (u = t.subType, Dx.series.typeNames[u] || "自定义图")
                        });
                        var o = t.getData();
                        (window.data = o).count() > p ? i += c(d("data.partialData"), {
                            displayCnt: p
                        }) : i += d("data.allData");
                        for (var r = [], s = 0; s < o.count(); s++) if (s < p) {
                            var l = o.getName(s), h = Ha(o, s);
                            r.push(c(d(l ? "data.withName" : "data.withoutName"), {
                                name: l,
                                value: h
                            }));
                        }
                        i += r.join(d("data.separator.middle")) + d("data.separator.end"), m.push(i);
                    }
                    var u;
                }), n += m.join(d("series.multiple.separator.middle")) + d("series.multiple.separator.end"), 
                t.setAttribute("aria-label", n);
            }
        }
    }, Cx = Math.PI, Lx = lo.prototype;
    Lx.restoreData = function(t, e) {
        t.restoreData(e), this._stageTaskMap.each(function(t) {
            var e = t.overallTask;
            e && e.dirty();
        });
    }, Lx.getPerformArgs = function(t, e) {
        if (t.__pipeline) {
            var i = this._pipelineMap.get(t.__pipeline.id), n = i.context;
            return {
                step: !e && i.progressiveEnabled && (!n || n.canProgressiveRender) && t.__idxInPipeline > i.bockIndex ? i.step : null
            };
        }
    }, Lx.getPipeline = function(t) {
        return this._pipelineMap.get(t);
    }, Lx.updateStreamModes = function(t, e) {
        var i = this._pipelineMap.get(t.uid), n = t.getData().count(), a = i.progressiveEnabled && e.incrementalPrepareRender && n >= i.threshold, o = t.get("large") && n >= t.get("largeThreshold");
        t.pipelineContext = i.context = {
            canProgressiveRender: a,
            large: o
        };
    }, Lx.restorePipelines = function(t) {
        var n = this, a = n._pipelineMap = W();
        t.eachSeries(function(t) {
            var e = t.getProgressive(), i = t.uid;
            a.set(i, {
                id: i,
                head: null,
                tail: null,
                threshold: t.getProgressiveThreshold(),
                progressiveEnabled: e && !(t.preventIncremental && t.preventIncremental()),
                bockIndex: -1,
                step: e || 700,
                count: 0
            }), xo(n, t, t.dataTask);
        });
    }, Lx.prepareStageTasks = function() {
        var i = this._stageTaskMap, n = this.ecInstance.getModel(), a = this.api;
        R(this._allHandlers, function(t) {
            var e = i.get(t.uid) || i.set(t.uid, []);
            t.reset && function(n, a, t, o, r) {
                function e(t) {
                    var e = t.uid, i = s.get(e) || s.set(e, Ua({
                        plan: go,
                        reset: mo,
                        count: yo
                    }));
                    i.context = {
                        model: t,
                        ecModel: o,
                        api: r,
                        useClearVisual: a.isVisual && !a.isLayout,
                        plan: a.plan,
                        reset: a.reset,
                        scheduler: n
                    }, xo(n, t, i);
                }
                var s = t.seriesTaskMap || (t.seriesTaskMap = W()), i = a.seriesType, l = a.getTargetSeries;
                a.createOnAllSeries ? o.eachRawSeries(e) : i ? o.eachRawSeriesByType(i, e) : l && l(o, r).each(e);
                var h = n._pipelineMap;
                s.each(function(t, e) {
                    h.get(e) || (t.dispose(), s.removeKey(e));
                });
            }(this, t, e, n, a), t.overallReset && function(n, t, e, i, a) {
                function o(t) {
                    var e = t.uid, i = s.get(e);
                    i || (i = s.set(e, Ua({
                        reset: co,
                        onDirty: po
                    })), r.dirty()), i.context = {
                        model: t,
                        overallProgress: u,
                        isOverallFilter: c
                    }, i.agent = r, i.__block = u, xo(n, t, i);
                }
                var r = e.overallTask = e.overallTask || Ua({
                    reset: uo
                });
                r.context = {
                    ecModel: i,
                    api: a,
                    overallReset: t.overallReset,
                    scheduler: n
                };
                var s = r.agentStubMap = r.agentStubMap || W(), l = t.seriesType, h = t.getTargetSeries, u = !0, c = t.isOverallFilter;
                l ? i.eachRawSeriesByType(l, o) : h ? h(i, a).each(o) : (u = !1, R(i.getSeries(), o));
                var d = n._pipelineMap;
                s.each(function(t, e) {
                    d.get(e) || (t.dispose(), r.dirty(), s.removeKey(e));
                });
            }(this, t, e, n, a);
        }, this);
    }, Lx.prepareView = function(t, e, i, n) {
        var a = t.renderTask, o = a.context;
        o.model = e, o.ecModel = i, o.api = n, a.__block = !t.incrementalPrepareRender, 
        xo(this, e, a);
    }, Lx.performDataProcessorTasks = function(t, e) {
        ho(this, this._dataProcessorHandlers, t, e, {
            block: !0
        });
    }, Lx.performVisualTasks = function(t, e, i) {
        ho(this, this._visualHandlers, t, e, i);
    }, Lx.performSeriesTasks = function(t) {
        var e;
        t.eachSeries(function(t) {
            e |= t.dataTask.perform();
        }), this.unfinished |= e;
    }, Lx.plan = function() {
        this._pipelineMap.each(function(t) {
            var e = t.tail;
            do {
                if (e.__block) {
                    t.bockIndex = e.__idxInPipeline;
                    break;
                }
                e = e.getUpstream();
            } while (e);
        });
    };
    var kx = Lx.updatePayload = function(t, e) {
        "remain" !== e && (t.context.payload = e);
    };
    lo.wrapStageHandler = function(t, e) {
        return m(t) && (t = {
            overallReset: t,
            seriesType: function(t) {
                Px = null;
                try {
                    t(Nx, Ox);
                } catch (t) {}
                return Px;
            }(t)
        }), t.uid = En("stageHandler"), e && (t.visualType = e), t;
    };
    var Px, Nx = {}, Ox = {};
    _o(Nx, Uy), _o(Ox, Sa), Nx.eachSeriesByType = Nx.eachRawSeriesByType = function(t) {
        Px = t;
    }, Nx.eachComponent = function(t) {
        "series" === t.mainType && t.subType && (Px = t.subType);
    };
    var Ex = [ "#37A2DA", "#32C5E9", "#67E0E3", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#E062AE", "#E690D1", "#e7bcf3", "#9d96f5", "#8378EA", "#96BFFF" ], Rx = {
        color: Ex,
        colorLayer: [ [ "#37A2DA", "#ffd85c", "#fd7b5f" ], [ "#37A2DA", "#67E0E3", "#FFDB5C", "#ff9f7f", "#E062AE", "#9d96f5" ], [ "#37A2DA", "#32C5E9", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#e7bcf3", "#8378EA", "#96BFFF" ], Ex ]
    }, zx = [ "#dd6b66", "#759aa0", "#e69d87", "#8dc1a9", "#ea7e53", "#eedd78", "#73a373", "#73b9bc", "#7289ab", "#91ca8c", "#f49f42" ], Bx = {
        color: zx,
        backgroundColor: "#333",
        tooltip: {
            axisPointer: {
                lineStyle: {
                    color: "#eee"
                },
                crossStyle: {
                    color: "#eee"
                }
            }
        },
        legend: {
            textStyle: {
                color: "#eee"
            }
        },
        textStyle: {
            color: "#eee"
        },
        title: {
            textStyle: {
                color: "#eee"
            }
        },
        toolbox: {
            iconStyle: {
                normal: {
                    borderColor: "#eee"
                }
            }
        },
        dataZoom: {
            textStyle: {
                color: "#eee"
            }
        },
        visualMap: {
            textStyle: {
                color: "#eee"
            }
        },
        timeline: {
            lineStyle: {
                color: "#eee"
            },
            itemStyle: {
                normal: {
                    color: zx[1]
                }
            },
            label: {
                normal: {
                    textStyle: {
                        color: "#eee"
                    }
                }
            },
            controlStyle: {
                normal: {
                    color: "#eee",
                    borderColor: "#eee"
                }
            }
        },
        timeAxis: {
            axisLine: {
                lineStyle: {
                    color: "#eee"
                }
            },
            axisTick: {
                lineStyle: {
                    color: "#eee"
                }
            },
            axisLabel: {
                textStyle: {
                    color: "#eee"
                }
            },
            splitLine: {
                lineStyle: {
                    type: "dashed",
                    color: "#aaa"
                }
            },
            splitArea: {
                areaStyle: {
                    color: "#eee"
                }
            }
        },
        logAxis: {
            axisLine: {
                lineStyle: {
                    color: "#eee"
                }
            },
            axisTick: {
                lineStyle: {
                    color: "#eee"
                }
            },
            axisLabel: {
                textStyle: {
                    color: "#eee"
                }
            },
            splitLine: {
                lineStyle: {
                    type: "dashed",
                    color: "#aaa"
                }
            },
            splitArea: {
                areaStyle: {
                    color: "#eee"
                }
            }
        },
        valueAxis: {
            axisLine: {
                lineStyle: {
                    color: "#eee"
                }
            },
            axisTick: {
                lineStyle: {
                    color: "#eee"
                }
            },
            axisLabel: {
                textStyle: {
                    color: "#eee"
                }
            },
            splitLine: {
                lineStyle: {
                    type: "dashed",
                    color: "#aaa"
                }
            },
            splitArea: {
                areaStyle: {
                    color: "#eee"
                }
            }
        },
        categoryAxis: {
            axisLine: {
                lineStyle: {
                    color: "#eee"
                }
            },
            axisTick: {
                lineStyle: {
                    color: "#eee"
                }
            },
            axisLabel: {
                textStyle: {
                    color: "#eee"
                }
            },
            splitLine: {
                lineStyle: {
                    type: "dashed",
                    color: "#aaa"
                }
            },
            splitArea: {
                areaStyle: {
                    color: "#eee"
                }
            }
        },
        line: {
            symbol: "circle"
        },
        graph: {
            color: zx
        },
        gauge: {
            title: {
                textStyle: {
                    color: "#eee"
                }
            }
        },
        candlestick: {
            itemStyle: {
                normal: {
                    color: "#FD1050",
                    color0: "#0CF49B",
                    borderColor: "#FD1050",
                    borderColor0: "#0CF49B"
                }
            }
        }
    };
    Bx.categoryAxis.splitLine.show = !1, Cy.extend({
        type: "dataset",
        defaultOption: {
            seriesLayoutBy: Wy,
            sourceHeader: null,
            dimensions: null,
            source: null
        },
        optionUpdated: function() {
            !function(t) {
                var e = t.option.source, i = Vy;
                if (v(e)) i = Gy; else if (N(e)) for (var n = 0, a = e.length; n < a; n++) {
                    var o = e[n];
                    if (null != o) {
                        if (N(o)) {
                            i = Ry;
                            break;
                        }
                        if (B(o)) {
                            i = zy;
                            break;
                        }
                    }
                } else if (B(e)) {
                    for (var r in e) if (e.hasOwnProperty(r) && O(e[r])) {
                        i = By;
                        break;
                    }
                } else if (null != e) throw new Error("Invalid data");
                Hy(t).sourceFormat = i;
            }(this);
        }
    }), gx.extend({
        type: "dataset"
    });
    var Vx = c, Gx = R, Wx = m, Fx = B, Hx = Cy.parseClassType, Zx = {
        PROCESSOR: {
            FILTER: 1e3,
            STATISTIC: 5e3
        },
        VISUAL: {
            LAYOUT: 1e3,
            GLOBAL: 2e3,
            CHART: 3e3,
            COMPONENT: 4e3,
            BRUSH: 5e3
        }
    }, Ux = "__flagInMainProcess", jx = "__optionUpdated", Xx = /^[a-zA-Z0-9_]+$/;
    bo.prototype.on = wo("on"), bo.prototype.off = wo("off"), bo.prototype.one = wo("one"), 
    a(bo, Up);
    var Yx = So.prototype;
    Yx._onframe = function() {
        if (!this._disposed) {
            var t = this._scheduler;
            if (this[jx]) {
                var e = this[jx].silent;
                this[Ux] = !0, Io(this), qx.update.call(this), this[Ux] = !1, this[jx] = !1, Co.call(this, e), 
                Lo.call(this, e);
            } else if (t.unfinished) {
                var i = 1, n = this._model;
                this._api, t.unfinished = !1;
                do {
                    var a = +new Date();
                    t.performSeriesTasks(n), t.performDataProcessorTasks(n), Do(this, n), t.performVisualTasks(n), 
                    Oo(this, this._model, 0, "remain"), i -= +new Date() - a;
                } while (0 < i && t.unfinished);
                t.unfinished || this._zr.flush();
            }
        }
    }, Yx.getDom = function() {
        return this._dom;
    }, Yx.getZr = function() {
        return this._zr;
    }, Yx.setOption = function(t, e, i) {
        var n;
        if (Fx(e) && (i = e.lazyUpdate, n = e.silent, e = e.notMerge), this[Ux] = !0, !this._model || e) {
            var a = new Ia(this._api), o = this._theme, r = this._model = new Uy(null, null, o, a);
            r.scheduler = this._scheduler, r.init(null, null, o, a);
        }
        this._model.setOption(t, t_), i ? (this[jx] = {
            silent: n
        }, this[Ux] = !1) : (Io(this), qx.update.call(this), this._zr.flush(), this[jx] = !1, 
        this[Ux] = !1, Co.call(this, n), Lo.call(this, n));
    }, Yx.setTheme = function() {
        console.log("ECharts#setTheme() is DEPRECATED in ECharts 3.0");
    }, Yx.getModel = function() {
        return this._model;
    }, Yx.getOption = function() {
        return this._model && this._model.getOption();
    }, Yx.getWidth = function() {
        return this._zr.getWidth();
    }, Yx.getHeight = function() {
        return this._zr.getHeight();
    }, Yx.getDevicePixelRatio = function() {
        return this._zr.painter.dpr || window.devicePixelRatio || 1;
    }, Yx.getRenderedCanvas = function(t) {
        if (Sp.canvasSupported) return (t = t || {}).pixelRatio = t.pixelRatio || 1, t.backgroundColor = t.backgroundColor || this._model.get("backgroundColor"), 
        this._zr.painter.getRenderedCanvas(t);
    }, Yx.getSvgDataUrl = function() {
        if (Sp.svgSupported) {
            var t = this._zr;
            return R(t.storage.getDisplayList(), function(t) {
                t.stopAnimation(!0);
            }), t.painter.pathToDataUrl();
        }
    }, Yx.getDataURL = function(t) {
        var e = (t = t || {}).excludeComponents, i = this._model, n = [], a = this;
        Gx(e, function(t) {
            i.eachComponent({
                mainType: t
            }, function(t) {
                var e = a._componentsMap[t.__viewId];
                e.group.ignore || (n.push(e), e.group.ignore = !0);
            });
        });
        var o = "svg" === this._zr.painter.getType() ? this.getSvgDataUrl() : this.getRenderedCanvas(t).toDataURL("image/" + (t && t.type || "png"));
        return Gx(n, function(t) {
            t.group.ignore = !1;
        }), o;
    }, Yx.getConnectedDataURL = function(a) {
        if (Sp.canvasSupported) {
            var o = this.group, r = Math.min, s = Math.max;
            if (r_[o]) {
                var l = 1 / 0, h = 1 / 0, u = -1 / 0, c = -1 / 0, d = [], i = a && a.pixelRatio || 1;
                R(o_, function(t, e) {
                    if (t.group === o) {
                        var i = t.getRenderedCanvas(A(a)), n = t.getDom().getBoundingClientRect();
                        l = r(n.left, l), h = r(n.top, h), u = s(n.right, u), c = s(n.bottom, c), d.push({
                            dom: i,
                            left: n.left,
                            top: n.top
                        });
                    }
                });
                var t = (u *= i) - (l *= i), e = (c *= i) - (h *= i), n = Op();
                n.width = t, n.height = e;
                var f = $e(n);
                return Gx(d, function(t) {
                    var e = new Be({
                        style: {
                            x: t.left * i - l,
                            y: t.top * i - h,
                            image: t.dom
                        }
                    });
                    f.add(e);
                }), f.refreshImmediately(), n.toDataURL("image/" + (a && a.type || "png"));
            }
            return this.getDataURL(a);
        }
    }, Yx.convertToPixel = z(Mo, "convertToPixel"), Yx.convertFromPixel = z(Mo, "convertFromPixel"), 
    Yx.containPixel = function(t, a) {
        var o;
        return R(t = li(this._model, t), function(t, n) {
            0 <= n.indexOf("Models") && R(t, function(t) {
                var e = t.coordinateSystem;
                if (e && e.containPoint) o |= !!e.containPoint(a); else if ("seriesModels" === n) {
                    var i = this._chartsMap[t.__viewId];
                    i && i.containPoint && (o |= i.containPoint(a, t));
                }
            }, this);
        }, this), !!o;
    }, Yx.getVisual = function(t, e) {
        var i = (t = li(this._model, t, {
            defaultMainType: "series"
        })).seriesModel.getData(), n = t.hasOwnProperty("dataIndexInside") ? t.dataIndexInside : t.hasOwnProperty("dataIndex") ? i.indexOfRawIndex(t.dataIndex) : null;
        return null != n ? i.getItemVisual(n, e) : i.getVisual(e);
    }, Yx.getViewOfComponentModel = function(t) {
        return this._componentsMap[t.__viewId];
    }, Yx.getViewOfSeriesModel = function(t) {
        return this._chartsMap[t.__viewId];
    };
    var qx = {
        prepareAndUpdate: function(t) {
            Io(this), qx.update.call(this, t);
        },
        update: function(t) {
            var e = this._model, i = this._api, n = this._zr, a = this._coordSysMgr, o = this._scheduler;
            if (e) {
                o.restoreData(e, t), o.performSeriesTasks(e), a.create(e, i), o.performDataProcessorTasks(e, t), 
                Do(this, e), a.update(e, i), Po(e), o.performVisualTasks(e, t), No(this, e, i, t);
                var r = e.get("backgroundColor") || "transparent";
                if (Sp.canvasSupported) n.setBackgroundColor(r); else {
                    var s = Tt(r);
                    r = Ot(s, "rgb"), 0 === s[3] && (r = "transparent");
                }
                Eo(e, i);
            }
        },
        updateTransform: function(a) {
            var o = this._model, r = this, s = this._api;
            if (o) {
                var l = [];
                o.eachComponent(function(t, e) {
                    var i = r.getViewOfComponentModel(e);
                    if (i && i.__alive) if (i.updateTransform) {
                        var n = i.updateTransform(e, o, s, a);
                        n && n.update && l.push(i);
                    } else l.push(i);
                });
                var n = W();
                o.eachSeries(function(t) {
                    var e = r._chartsMap[t.__viewId];
                    if (e.updateTransform) {
                        var i = e.updateTransform(t, o, s, a);
                        i && i.update && n.set(t.uid, 1);
                    } else n.set(t.uid, 1);
                }), Po(o), this._scheduler.performVisualTasks(o, a, {
                    setDirty: !0,
                    dirtyMap: n
                }), Oo(r, o, 0, a, n), Eo(o, this._api);
            }
        },
        updateView: function(t) {
            var e = this._model;
            e && (to.markUpdateMethod(t, "updateView"), Po(e), this._scheduler.performVisualTasks(e, t, {
                setDirty: !0
            }), No(this, this._model, this._api, t), Eo(e, this._api));
        },
        updateVisual: function(t) {
            qx.update.call(this, t);
        },
        updateLayout: function(t) {
            qx.update.call(this, t);
        }
    };
    Yx.resize = function(t) {
        this._zr.resize(t);
        var e = this._model;
        if (this._loadingFX && this._loadingFX.resize(), e) {
            var i = e.resetOption("media"), n = t && t.silent;
            this[Ux] = !0, i && Io(this), qx.update.call(this), this[Ux] = !1, Co.call(this, n), 
            Lo.call(this, n);
        }
    }, Yx.showLoading = function(t, e) {
        if (Fx(t) && (e = t, t = ""), t = t || "default", this.hideLoading(), a_[t]) {
            var i = a_[t](this._api, e), n = this._zr;
            this._loadingFX = i, n.add(i);
        }
    }, Yx.hideLoading = function() {
        this._loadingFX && this._zr.remove(this._loadingFX), this._loadingFX = null;
    }, Yx.makeActionFromEvent = function(t) {
        var e = P({}, t);
        return e.type = Jx[t.type], e;
    }, Yx.dispatchAction = function(t, e) {
        Fx(e) || (e = {
            silent: !!e
        }), $x[t.type] && this._model && (this[Ux] ? this._pendingActions.push(t) : (Ao.call(this, t, e.silent), 
        e.flush ? this._zr.flush(!0) : !1 !== e.flush && Sp.browser.weChat && this._throttledZrFlush(), 
        Co.call(this, e.silent), Lo.call(this, e.silent)));
    }, Yx.appendData = function(t) {
        var e = t.seriesIndex;
        this.getModel().getSeriesByIndex(e).appendData(t), this._scheduler.unfinished = !0;
    }, Yx.on = wo("on"), Yx.off = wo("off"), Yx.one = wo("one");
    var Kx = [ "click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "globalout", "contextmenu" ];
    Yx._initEvents = function() {
        Gx(Kx, function(o) {
            this._zr.on(o, function(t) {
                var e, i = this.getModel(), n = t.target;
                if ("globalout" === o) e = {}; else if (n && null != n.dataIndex) {
                    var a = n.dataModel || i.getSeriesByIndex(n.seriesIndex);
                    e = a && a.getDataParams(n.dataIndex, n.dataType) || {};
                } else n && n.eventData && (e = P({}, n.eventData));
                e && (e.event = t, e.type = o, this.trigger(o, e));
            }, this);
        }, this), Gx(Jx, function(t, e) {
            this._messageCenter.on(e, function(t) {
                this.trigger(e, t);
            }, this);
        }, this);
    }, Yx.isDisposed = function() {
        return this._disposed;
    }, Yx.clear = function() {
        this.setOption({
            series: []
        }, !0);
    }, Yx.dispose = function() {
        if (!this._disposed) {
            this._disposed = !0, ui(this.getDom(), h_, "");
            var e = this._api, i = this._model;
            Gx(this._componentsViews, function(t) {
                t.dispose(i, e);
            }), Gx(this._chartsViews, function(t) {
                t.dispose(i, e);
            }), this._zr.dispose(), delete o_[this.id];
        }
    }, a(So, Up);
    var $x = {}, Jx = {}, Qx = [], t_ = [], e_ = [], i_ = [], n_ = {}, a_ = {}, o_ = {}, r_ = {}, s_ = new Date() - 0, l_ = new Date() - 0, h_ = "_echarts_instance_", u_ = {}, c_ = zo;
    Uo(2e3, Tx), Go(ox), Wo(5e3, function(t) {
        var o = W();
        t.eachSeries(function(t) {
            var e = t.get("stack");
            if (e) {
                var i = o.get(e) || o.set(e, []), n = t.getData(), a = {
                    stackResultDimension: n.getCalculationInfo("stackResultDimension"),
                    stackedOverDimension: n.getCalculationInfo("stackedOverDimension"),
                    stackedDimension: n.getCalculationInfo("stackedDimension"),
                    stackedByDimension: n.getCalculationInfo("stackedByDimension"),
                    isStackedByIndex: n.getCalculationInfo("isStackedByIndex"),
                    data: n,
                    seriesModel: t
                };
                if (!a.stackedDimension || !a.isStackedByIndex && !a.stackedByDimension) return;
                i.length && n.setCalculationInfo("stackedOnSeries", i[i.length - 1].seriesModel), 
                i.push(a);
            }
        }), o.each(Ea);
    }), Xo("default", function(n, t) {
        E(t = t || {}, {
            text: "loading",
            color: "#c23531",
            textColor: "#000",
            maskColor: "rgba(255, 255, 255, 0.8)",
            zlevel: 0
        });
        var a = new Wv({
            style: {
                fill: t.maskColor
            },
            zlevel: t.zlevel,
            z: 1e4
        }), o = new Uv({
            shape: {
                startAngle: -Cx / 2,
                endAngle: -Cx / 2 + .1,
                r: 10
            },
            style: {
                stroke: t.color,
                lineCap: "round",
                lineWidth: 5
            },
            zlevel: t.zlevel,
            z: 10001
        }), r = new Wv({
            style: {
                fill: "none",
                text: t.text,
                textPosition: "right",
                textDistance: 10,
                textFill: t.textColor
            },
            zlevel: t.zlevel,
            z: 10001
        });
        o.animateShape(!0).when(1e3, {
            endAngle: 3 * Cx / 2
        }).start("circularInOut"), o.animateShape(!0).when(1e3, {
            startAngle: 3 * Cx / 2
        }).delay(300).start("circularInOut");
        var e = new Dg();
        return e.add(o), e.add(r), e.add(a), e.resize = function() {
            var t = n.getWidth() / 2, e = n.getHeight() / 2;
            o.setShape({
                cx: t,
                cy: e
            });
            var i = o.shape.r;
            r.setShape({
                x: t - i,
                y: e - i,
                width: 2 * i,
                height: 2 * i
            }), a.setShape({
                x: 0,
                y: 0,
                width: n.getWidth(),
                height: n.getHeight()
            });
        }, e.resize(), e;
    }), Fo({
        type: "highlight",
        event: "highlight",
        update: "highlight"
    }, S), Fo({
        type: "downplay",
        event: "downplay",
        update: "downplay"
    }, S), Vo("light", Rx), Vo("dark", Bx), tr.prototype = {
        constructor: tr,
        add: function(t) {
            return this._add = t, this;
        },
        update: function(t) {
            return this._update = t, this;
        },
        remove: function(t) {
            return this._remove = t, this;
        },
        execute: function() {
            var t = this._old, e = this._new, i = {}, n = [], a = [];
            for (er(t, {}, n, "_oldKeyGetter", this), er(e, i, a, "_newKeyGetter", this), o = 0; o < t.length; o++) null != (s = i[r = n[o]]) ? ((h = s.length) ? (1 === h && (i[r] = null), 
            s = s.unshift()) : i[r] = null, this._update && this._update(s, o)) : this._remove && this._remove(o);
            for (var o = 0; o < a.length; o++) {
                var r = a[o];
                if (i.hasOwnProperty(r)) {
                    var s = i[r];
                    if (null == s) continue;
                    if (s.length) for (var l = 0, h = s.length; l < h; l++) this._add && this._add(s[l]); else this._add && this._add(s);
                }
            }
        }
    };
    var d_ = W([ "tooltip", "label", "itemName", "itemId", "seriesName" ]), f_ = B, p_ = "undefined" == typeof window ? global : window, g_ = {
        float: void 0 === p_.Float64Array ? Array : p_.Float64Array,
        int: void 0 === p_.Int32Array ? Array : p_.Int32Array,
        ordinal: Array,
        number: Array,
        time: Array
    }, m_ = void 0 === p_.Uint32Array ? Array : p_.Uint32Array, v_ = void 0 === p_.Uint16Array ? Array : p_.Uint16Array, y_ = [ "hasItemOption", "_nameList", "_idList", "_calculationInfo", "_invertedIndicesMap", "_rawData", "_rawExtent", "_chunkSize", "_chunkCount", "_dimValueGetter", "_count", "_rawCount", "_nameDimIdx", "_idDimIdx" ], x_ = function(t, e) {
        t = t || [ "x", "y" ];
        for (var i = {}, n = [], a = {}, o = 0; o < t.length; o++) {
            var r = t[o];
            b(r) && (r = {
                name: r
            });
            var s = r.name;
            r.type = r.type || "float", r.coordDim || (r.coordDim = s, r.coordDimIndex = 0), 
            r.otherDims = r.otherDims || {}, n.push(s), (i[s] = r).index = o, r.createInvertedIndices && (a[s] = []);
        }
        this.dimensions = n, this._dimensionInfos = i, this.hostModel = e, this.dataType, 
        this._indices = null, this._count = 0, this._rawCount = 0, this._storage = {}, this._nameList = [], 
        this._idList = [], this._optionModels = [], this._visual = {}, this._layout = {}, 
        this._itemVisuals = [], this.hasItemVisual = {}, this._itemLayouts = [], this._graphicEls = [], 
        this._chunkSize = 1e5, this._chunkCount = 0, this._rawData, this._rawExtent = {}, 
        this._extent = {}, this._approximateExtent = {}, this._dimensionsSummary = function(o) {
            var t = {}, r = t.encode = {}, s = W(), l = [];
            R(o.dimensions, function(t) {
                var e, a = o.getDimensionInfo(t), i = a.coordDim;
                if (i) {
                    var n = r[i];
                    r.hasOwnProperty(i) || (n = r[i] = []), n[a.coordDimIndex] = t, a.isExtraCoord || (s.set(i, 1), 
                    "ordinal" !== (e = a.type) && "time" !== e && (l[0] = t));
                }
                d_.each(function(t, e) {
                    var i = r[e];
                    r.hasOwnProperty(e) || (i = r[e] = []);
                    var n = a.otherDims[e];
                    null != n && !1 !== n && (i[n] = a.name);
                });
            });
            var n = [], a = {};
            s.each(function(t, e) {
                var i = r[e];
                a[e] = i[0], n = n.concat(i);
            }), t.dataDimsOnCoord = n, t.encodeFirstDimNotExtra = a;
            var e = r.label;
            e && e.length && (l = e.slice());
            var i = l.slice(), h = r.tooltip;
            return h && h.length && (i = h.slice()), r.defaultedLabel = l, r.defaultedTooltip = i, 
            t;
        }(this), this._invertedIndicesMap = a, this._calculationInfo = {};
    }, __ = x_.prototype;
    __.type = "list", __.hasItemOption = !0, __.getDimension = function(t) {
        return isNaN(t) || (t = this.dimensions[t] || t), t;
    }, __.getDimensionInfo = function(t) {
        return this._dimensionInfos[this.getDimension(t)];
    }, __.getDimensionsOnCoord = function() {
        return this._dimensionsSummary.dataDimsOnCoord.slice();
    }, __.mapDimension = function(t, e) {
        var i = this._dimensionsSummary;
        if (null == e) return i.encodeFirstDimNotExtra[t];
        var n = i.encode[t];
        return !0 === e ? (n || []).slice() : n && n[e];
    }, __.initData = function(t, e, i) {
        (ga.isInstance(t) || O(t)) && (t = new Ra(t, this.dimensions.length)), this._rawData = t, 
        this._storage = {}, this._indices = null, this._nameList = e || [], this._idList = [], 
        this._nameRepeatCount = {}, i || (this.hasItemOption = !1), this.defaultDimValueGetter = hx[this._rawData.getSource().sourceFormat], 
        this._dimValueGetter = i = i || this.defaultDimValueGetter, this._rawExtent = {}, 
        this._initDataFromProvider(0, t.count()), t.pure && (this.hasItemOption = !1);
    }, __.getProvider = function() {
        return this._rawData;
    }, __.appendData = function(t) {
        var e = this._rawData, i = this.count();
        e.appendData(t);
        var n = e.count();
        e.persistent || (n += i), this._initDataFromProvider(i, n);
    }, __._initDataFromProvider = function(t, e) {
        if (!(e <= t)) {
            for (var i, n = this._chunkSize, a = this._rawData, o = this._storage, r = this.dimensions, s = this._dimensionInfos, l = this._nameList, h = this._idList, u = this._rawExtent, c = this._nameRepeatCount = {}, d = this._chunkCount, f = d - 1, p = 0; p < r.length; p++) {
                u[I = r[p]] || (u[I] = [ 1 / 0, -1 / 0 ]);
                var g = s[I];
                0 === g.otherDims.itemName && (i = this._nameDimIdx = p), 0 === g.otherDims.itemId && (this._idDimIdx = p);
                var m = g_[g.type];
                o[I] || (o[I] = []);
                var v = o[I][f];
                if (v && v.length < n) {
                    for (var y = new m(Math.min(e - f * n, n)), x = 0; x < v.length; x++) y[x] = v[x];
                    o[I][f] = y;
                }
                for (M = d * n; M < e; M += n) o[I].push(new m(Math.min(e - M, n)));
                this._chunkCount = o[I].length;
            }
            for (var _ = t; _ < e; _++) {
                for (var w = a.getItem(_), b = Math.floor(_ / n), S = _ % n, M = 0; M < r.length; M++) {
                    var I = r[M], T = o[I][b], D = this._dimValueGetter(w, I, _, M);
                    (T[S] = D) < u[I][0] && (u[I][0] = D), D > u[I][1] && (u[I][1] = D);
                }
                if (!a.pure) {
                    var A = l[_];
                    w && !A && (null != i ? A = this._getNameFromStore(_) : null != w.name && (l[_] = A = w.name));
                    var C = null == w ? null : w.id;
                    null == C && null != A && (c[A] = c[A] || 0, 0 < c[C = A] && (C += "__ec__" + c[A]), 
                    c[A]++), null != C && (h[_] = C);
                }
            }
            !a.persistent && a.clean && a.clean(), this._rawCount = this._count = e, this._extent = {}, 
            R(k = (L = this)._invertedIndicesMap, function(t, e) {
                var i = L._dimensionInfos[e].ordinalMeta;
                if (i) {
                    for (t = k[e] = new m_(i.categories.length), n = 0; n < t.length; n++) t[n] = NaN;
                    for (var n = 0; n < L._count; n++) t[L.get(e, n)] = n;
                }
            });
        }
        var L, k;
    }, __._getNameFromStore = function(t) {
        var e = this._nameDimIdx;
        if (null != e) {
            var i = this._chunkSize, n = Math.floor(t / i), a = t % i, o = this.dimensions[e], r = this._dimensionInfos[o].ordinalMeta;
            if (r) return r.categories[t];
            var s = this._storage[o][n];
            return s && s[a];
        }
    }, __._getIdFromStore = function(t) {
        var e = this._idDimIdx;
        if (null != e) {
            var i = this._chunkSize, n = Math.floor(t / i), a = t % i, o = this.dimensions[e], r = this._dimensionInfos[o].ordinalMeta;
            if (r) return r.categories[t];
            var s = this._storage[o][n];
            return s && s[a];
        }
    }, __.count = function() {
        return this._count;
    }, __.getIndices = function() {
        if (this._indices) return new (t = this._indices.constructor)(this._indices.buffer, 0, this._count);
        for (var t = nr(this), e = new t(this.count()), i = 0; i < e.length; i++) e[i] = i;
        return e;
    }, __.get = function(t, e) {
        if (!(0 <= e && e < this._count)) return NaN;
        var i = this._storage;
        if (!i[t]) return NaN;
        e = this.getRawIndex(e);
        var n = Math.floor(e / this._chunkSize), a = e % this._chunkSize;
        return i[t][n][a];
    }, __.getByRawIndex = function(t, e) {
        if (!(0 <= e && e < this._rawCount)) return NaN;
        var i = this._storage[t];
        if (!i) return NaN;
        var n = Math.floor(e / this._chunkSize), a = e % this._chunkSize;
        return i[n][a];
    }, __._getFast = function(t, e) {
        var i = Math.floor(e / this._chunkSize), n = e % this._chunkSize;
        return this._storage[t][i][n];
    }, __.getValues = function(t, e) {
        var i = [];
        N(t) || (e = t, t = this.dimensions);
        for (var n = 0, a = t.length; n < a; n++) i.push(this.get(t[n], e));
        return i;
    }, __.hasValue = function(t) {
        for (var e = this._dimensionsSummary.dataDimsOnCoord, i = this._dimensionInfos, n = 0, a = e.length; n < a; n++) if ("ordinal" !== i[e[n]].type && isNaN(this.get(e[n], t))) return !1;
        return !0;
    }, __.getDataExtent = function(t) {
        t = this.getDimension(t);
        var e = [ 1 / 0, -1 / 0 ];
        if (!this._storage[t]) return e;
        var i, n = this.count();
        if (!this._indices) return this._rawExtent[t].slice();
        if (i = this._extent[t]) return i.slice();
        for (var a = (i = e)[0], o = i[1], r = 0; r < n; r++) {
            var s = this._getFast(t, this.getRawIndex(r));
            s < a && (a = s), o < s && (o = s);
        }
        return i = [ a, o ], this._extent[t] = i;
    }, __.getApproximateExtent = function(t) {
        return t = this.getDimension(t), this._approximateExtent[t] || this.getDataExtent(t);
    }, __.setApproximateExtent = function(t, e) {
        e = this.getDimension(e), this._approximateExtent[e] = t.slice();
    }, __.getCalculationInfo = function(t) {
        return this._calculationInfo[t];
    }, __.setCalculationInfo = function(t, e) {
        f_(t) ? P(this._calculationInfo, t) : this._calculationInfo[t] = e;
    }, __.getSum = function(t) {
        var e = 0;
        if (this._storage[t]) for (var i = 0, n = this.count(); i < n; i++) {
            var a = this.get(t, i);
            isNaN(a) || (e += a);
        }
        return e;
    }, __.getMedian = function(t) {
        var i = [];
        this.each(t, function(t, e) {
            isNaN(t) || i.push(t);
        });
        var e = [].concat(i).sort(function(t, e) {
            return t - e;
        }), n = this.count();
        return 0 === n ? 0 : n % 2 == 1 ? e[(n - 1) / 2] : (e[n / 2] + e[n / 2 - 1]) / 2;
    }, __.rawIndexOf = function(t, e) {
        var i = (t && this._invertedIndicesMap[t])[e];
        return null == i || isNaN(i) ? -1 : i;
    }, __.indexOfName = function(t) {
        for (var e = 0, i = this.count(); e < i; e++) if (this.getName(e) === t) return e;
        return -1;
    }, __.indexOfRawIndex = function(t) {
        if (!this._indices) return t;
        if (t >= this._rawCount || t < 0) return -1;
        var e = this._indices, i = e[t];
        if (null != i && i < this._count && i === t) return t;
        for (var n = 0, a = this._count - 1; n <= a; ) {
            var o = (n + a) / 2 | 0;
            if (e[o] < t) n = o + 1; else {
                if (!(e[o] > t)) return o;
                a = o - 1;
            }
        }
        return -1;
    }, __.indicesOfNearest = function(t, e, i) {
        var n = [];
        if (!this._storage[t]) return n;
        null == i && (i = 1 / 0);
        for (var a = Number.MAX_VALUE, o = -1, r = 0, s = this.count(); r < s; r++) {
            var l = e - this.get(t, r), h = Math.abs(l);
            l <= i && h <= a && ((h < a || 0 <= l && o < 0) && (a = h, o = l, n.length = 0), 
            n.push(r));
        }
        return n;
    }, __.getRawIndex = or, __.getRawDataItem = function(t) {
        if (this._rawData.persistent) return this._rawData.getItem(this.getRawIndex(t));
        for (var e = [], i = 0; i < this.dimensions.length; i++) {
            var n = this.dimensions[i];
            e.push(this.get(n, t));
        }
        return e;
    }, __.getName = function(t) {
        var e = this.getRawIndex(t);
        return this._nameList[e] || this._getNameFromStore(e) || "";
    }, __.getId = function(t) {
        return sr(this, this.getRawIndex(t));
    }, __.each = function(t, e, i, n) {
        if (this._count) {
            "function" == typeof t && (n = i, i = e, e = t, t = []), i = i || n || this;
            for (var a = (t = L(lr(t), this.getDimension, this)).length, o = 0; o < this.count(); o++) switch (a) {
              case 0:
                e.call(i, o);
                break;

              case 1:
                e.call(i, this.get(t[0], o), o);
                break;

              case 2:
                e.call(i, this.get(t[0], o), this.get(t[1], o), o);
                break;

              default:
                for (var r = 0, s = []; r < a; r++) s[r] = this.get(t[r], o);
                s[r] = o, e.apply(i, s);
            }
        }
    }, __.filterSelf = function(t, e, i, n) {
        if (this._count) {
            "function" == typeof t && (n = i, i = e, e = t, t = []), i = i || n || this, t = L(lr(t), this.getDimension, this);
            for (var a = this.count(), o = new (nr(this))(a), r = [], s = t.length, l = 0, h = t[0], u = 0; u < a; u++) {
                var c, d = this.getRawIndex(u);
                if (0 === s) c = e.call(i, u); else if (1 === s) {
                    var f = this._getFast(h, d);
                    c = e.call(i, f, u);
                } else {
                    for (var p = 0; p < s; p++) r[p] = this._getFast(h, d);
                    r[p] = u, c = e.apply(i, r);
                }
                c && (o[l++] = d);
            }
            return l < a && (this._indices = o), this._count = l, this._extent = {}, this.getRawIndex = this._indices ? rr : or, 
            this;
        }
    }, __.selectRange = function(t) {
        if (this._count) {
            var e = [];
            for (var i in t) t.hasOwnProperty(i) && e.push(i);
            var n = e.length;
            if (n) {
                var a = this.count(), o = new (nr(this))(a), r = 0, s = e[0], l = t[s][0], h = t[s][1], u = !1;
                if (!this._indices) {
                    var c = 0;
                    if (1 === n) {
                        for (var d = this._storage[e[0]], f = 0; f < this._chunkCount; f++) for (var p = d[f], g = Math.min(this._count - f * this._chunkSize, this._chunkSize), m = 0; m < g; m++) (w = p[m]) >= l && w <= h && (o[r++] = c), 
                        c++;
                        u = !0;
                    } else if (2 === n) {
                        d = this._storage[s];
                        var v = this._storage[e[1]], y = t[e[1]][0], x = t[e[1]][1];
                        for (f = 0; f < this._chunkCount; f++) {
                            p = d[f];
                            var _ = v[f];
                            for (g = Math.min(this._count - f * this._chunkSize, this._chunkSize), m = 0; m < g; m++) {
                                var w = p[m], b = _[m];
                                l <= w && w <= h && y <= b && b <= x && (o[r++] = c), c++;
                            }
                        }
                        u = !0;
                    }
                }
                if (!u) if (1 === n) for (m = 0; m < a; m++) M = this.getRawIndex(m), (w = this._getFast(s, M)) >= l && w <= h && (o[r++] = M); else for (m = 0; m < a; m++) {
                    var S = !0, M = this.getRawIndex(m);
                    for (f = 0; f < n; f++) {
                        var I = e[f];
                        ((w = this._getFast(i, M)) < t[I][0] || w > t[I][1]) && (S = !1);
                    }
                    S && (o[r++] = this.getRawIndex(m));
                }
                return r < a && (this._indices = o), this._count = r, this._extent = {}, this.getRawIndex = this._indices ? rr : or, 
                this;
            }
        }
    }, __.mapArray = function(t, e, i, n) {
        "function" == typeof t && (n = i, i = e, e = t, t = []), i = i || n || this;
        var a = [];
        return this.each(t, function() {
            a.push(e && e.apply(this, arguments));
        }, i), a;
    }, __.map = function(t, e, i, n) {
        i = i || n || this;
        var a = hr(this, t = L(lr(t), this.getDimension, this));
        a._indices = this._indices, a.getRawIndex = a._indices ? rr : or;
        for (var o = a._storage, r = [], s = this._chunkSize, l = t.length, h = this.count(), u = [], c = a._rawExtent, d = 0; d < h; d++) {
            for (var f = 0; f < l; f++) u[f] = this.get(t[f], d);
            u[l] = d;
            var p = e && e.apply(i, u);
            if (null != p) {
                "object" != (void 0 === p ? "undefined" : _typeof(p)) && (r[0] = p, p = r);
                for (var g = this.getRawIndex(d), m = Math.floor(g / s), v = g % s, y = 0; y < p.length; y++) {
                    var x = t[y], _ = p[y], w = c[x], b = o[x];
                    b && (b[m][v] = _), _ < w[0] && (w[0] = _), _ > w[1] && (w[1] = _);
                }
            }
        }
        return a;
    }, __.downSample = function(t, e, i, n) {
        for (var a = hr(this, [ t ]), o = a._storage, r = [], s = Math.floor(1 / e), l = o[t], h = this.count(), u = this._chunkSize, c = a._rawExtent[t], d = new (nr(this))(h), f = 0, p = 0; p < h; p += s) {
            h - p < s && (s = h - p, r.length = s);
            for (var g = 0; g < s; g++) {
                var m = this.getRawIndex(p + g), v = Math.floor(m / u), y = m % u;
                r[g] = l[v][y];
            }
            var x = i(r), _ = this.getRawIndex(Math.min(p + n(r, x) || 0, h - 1)), w = _ % u;
            (l[Math.floor(_ / u)][w] = x) < c[0] && (c[0] = x), x > c[1] && (c[1] = x), d[f++] = _;
        }
        return a._count = f, a._indices = d, a.getRawIndex = rr, a;
    }, __.getItemModel = function(t) {
        var e = this.hostModel;
        return new Pn(this.getRawDataItem(t), e, e && e.ecModel);
    }, __.diff = function(e) {
        var i = this;
        return new tr(e ? e.getIndices() : [], this.getIndices(), function(t) {
            return sr(e, t);
        }, function(t) {
            return sr(i, t);
        });
    }, __.getVisual = function(t) {
        var e = this._visual;
        return e && e[t];
    }, __.setVisual = function(t, e) {
        if (f_(t)) for (var i in t) t.hasOwnProperty(i) && this.setVisual(i, t[i]); else this._visual = this._visual || {}, 
        this._visual[t] = e;
    }, __.setLayout = function(t, e) {
        if (f_(t)) for (var i in t) t.hasOwnProperty(i) && this.setLayout(i, t[i]); else this._layout[t] = e;
    }, __.getLayout = function(t) {
        return this._layout[t];
    }, __.getItemLayout = function(t) {
        return this._itemLayouts[t];
    }, __.setItemLayout = function(t, e, i) {
        this._itemLayouts[t] = i ? P(this._itemLayouts[t] || {}, e) : e;
    }, __.clearItemLayouts = function() {
        this._itemLayouts.length = 0;
    }, __.getItemVisual = function(t, e, i) {
        var n = this._itemVisuals[t], a = n && n[e];
        return null != a || i ? a : this.getVisual(e);
    }, __.setItemVisual = function(t, e, i) {
        var n = this._itemVisuals[t] || {}, a = this.hasItemVisual;
        if (this._itemVisuals[t] = n, f_(e)) for (var o in e) e.hasOwnProperty(o) && (n[o] = e[o], 
        a[o] = !0); else n[e] = i, a[e] = !0;
    }, __.clearAllVisual = function() {
        this._visual = {}, this._itemVisuals = [], this.hasItemVisual = {};
    };
    var w_ = function(t) {
        t.seriesIndex = this.seriesIndex, t.dataIndex = this.dataIndex, t.dataType = this.dataType;
    };
    __.setItemGraphicEl = function(t, e) {
        var i = this.hostModel;
        e && (e.dataIndex = t, e.dataType = this.dataType, e.seriesIndex = i && i.seriesIndex, 
        "group" === e.type && e.traverse(w_, e)), this._graphicEls[t] = e;
    }, __.getItemGraphicEl = function(t) {
        return this._graphicEls[t];
    }, __.eachItemGraphicEl = function(i, n) {
        R(this._graphicEls, function(t, e) {
            t && i && i.call(n, t, e);
        });
    }, __.cloneShallow = function(t) {
        if (!t) {
            var e = L(this.dimensions, this.getDimensionInfo, this);
            t = new x_(e, this.hostModel);
        }
        if (t._storage = this._storage, ar(t, this), this._indices) {
            var i = this._indices.constructor;
            t._indices = new i(this._indices);
        } else t._indices = null;
        return t.getRawIndex = t._indices ? rr : or, t._extent = A(this._extent), t._approximateExtent = A(this._approximateExtent), 
        t;
    }, __.wrapMethod = function(t, e) {
        var i = this[t];
        "function" == typeof i && (this.__wrappedMethods = this.__wrappedMethods || [], 
        this.__wrappedMethods.push(t), this[t] = function() {
            var t = i.apply(this, arguments);
            return e.apply(this, [ t ].concat(s(arguments)));
        });
    }, __.TRANSFERABLE_METHODS = [ "cloneShallow", "downSample", "map" ], __.CHANGABLE_METHODS = [ "filterSelf", "selectRange" ];
    var b_ = function(t, e) {
        return cr((e = e || {}).coordDimensions || [], t, {
            dimsDef: e.dimensionsDefine || t.dimensionsDefine,
            encodeDef: e.encodeDefine || t.encodeDefine,
            dimCount: e.dimensionsCount,
            generateCoord: e.generateCoord,
            generateCoordCount: e.generateCoordCount
        });
    };
    mr.prototype.parse = function(t) {
        return t;
    }, mr.prototype.getSetting = function(t) {
        return this._setting[t];
    }, mr.prototype.contain = function(t) {
        var e = this._extent;
        return t >= e[0] && t <= e[1];
    }, mr.prototype.normalize = function(t) {
        var e = this._extent;
        return e[1] === e[0] ? .5 : (t - e[0]) / (e[1] - e[0]);
    }, mr.prototype.scale = function(t) {
        var e = this._extent;
        return t * (e[1] - e[0]) + e[0];
    }, mr.prototype.unionExtent = function(t) {
        var e = this._extent;
        t[0] < e[0] && (e[0] = t[0]), t[1] > e[1] && (e[1] = t[1]);
    }, mr.prototype.unionExtentFromData = function(t, e) {
        this.unionExtent(t.getApproximateExtent(e));
    }, mr.prototype.getExtent = function() {
        return this._extent.slice();
    }, mr.prototype.setExtent = function(t, e) {
        var i = this._extent;
        isNaN(t) || (i[0] = t), isNaN(e) || (i[1] = e);
    }, mr.prototype.getTicksLabels = function() {
        for (var t = [], e = this.getTicks(), i = 0; i < e.length; i++) t.push(this.getLabel(e[i]));
        return t;
    }, mr.prototype.isBlank = function() {
        return this._isBlank;
    }, mr.prototype.setBlank = function(t) {
        this._isBlank = t;
    }, di(mr), mi(mr, {
        registerWhenExtend: !0
    }), vr.createByAxisModel = function(t) {
        var e = t.option, i = e.data, n = i && L(i, xr);
        return new vr({
            categories: n,
            needCollect: !n,
            deduplication: !1 !== e.dedplication
        });
    };
    var S_ = vr.prototype;
    S_.getOrdinal = function(t) {
        return yr(this).get(t);
    }, S_.parseAndCollect = function(t) {
        var e, i = this._needCollect;
        if ("string" != typeof t && !i) return t;
        if (i && !this._deduplication) return e = this.categories.length, this.categories[e] = t, 
        e;
        var n = yr(this);
        return null == (e = n.get(t)) && (i ? (e = this.categories.length, this.categories[e] = t, 
        n.set(t, e)) : e = NaN), e;
    };
    var M_ = mr.prototype, I_ = mr.extend({
        type: "ordinal",
        init: function(t, e) {
            t && !N(t) || (t = new vr({
                categories: t
            })), this._ordinalMeta = t, this._extent = e || [ 0, t.categories.length - 1 ];
        },
        parse: function(t) {
            return "string" == typeof t ? this._ordinalMeta.getOrdinal(t) : Math.round(t);
        },
        contain: function(t) {
            return t = this.parse(t), M_.contain.call(this, t) && null != this._ordinalMeta.categories[t];
        },
        normalize: function(t) {
            return M_.normalize.call(this, this.parse(t));
        },
        scale: function(t) {
            return Math.round(M_.scale.call(this, t));
        },
        getTicks: function() {
            for (var t = [], e = this._extent, i = e[0]; i <= e[1]; ) t.push(i), i++;
            return t;
        },
        getLabel: function(t) {
            return this._ordinalMeta.categories[t];
        },
        count: function() {
            return this._extent[1] - this._extent[0] + 1;
        },
        unionExtentFromData: function(t, e) {
            this.unionExtent(t.getApproximateExtent(e));
        },
        niceTicks: S,
        niceExtent: S
    });
    I_.create = function() {
        return new I_();
    };
    var T_ = Bn, D_ = Bn, A_ = mr.extend({
        type: "interval",
        _interval: 0,
        _intervalPrecision: 2,
        setExtent: function(t, e) {
            var i = this._extent;
            isNaN(t) || (i[0] = parseFloat(t)), isNaN(e) || (i[1] = parseFloat(e));
        },
        unionExtent: function(t) {
            var e = this._extent;
            t[0] < e[0] && (e[0] = t[0]), t[1] > e[1] && (e[1] = t[1]), A_.prototype.setExtent.call(this, e[0], e[1]);
        },
        getInterval: function() {
            return this._interval;
        },
        setInterval: function(t) {
            this._interval = t, this._niceExtent = this._extent.slice(), this._intervalPrecision = _r(t);
        },
        getTicks: function() {
            return function(t, e, i, n) {
                var a = [];
                if (!t) return a;
                e[0] < i[0] && a.push(e[0]);
                for (var o = i[0]; o <= i[1] && (a.push(o), (o = T_(o + t, n)) !== a[a.length - 1]); ) if (1e4 < a.length) return [];
                return e[1] > (a.length ? a[a.length - 1] : i[1]) && a.push(e[1]), a;
            }(this._interval, this._extent, this._niceExtent, this._intervalPrecision);
        },
        getTicksLabels: function() {
            for (var t = [], e = this.getTicks(), i = 0; i < e.length; i++) t.push(this.getLabel(e[i]));
            return t;
        },
        getLabel: function(t, e) {
            if (null == t) return "";
            var i = e && e.precision;
            return null == i ? i = Wn(t) || 0 : "auto" === i && (i = this._intervalPrecision), 
            Jn(t = D_(t, i, !0));
        },
        niceTicks: function(t, e, i) {
            t = t || 5;
            var n = this._extent, a = n[1] - n[0];
            if (isFinite(a)) {
                a < 0 && (a = -a, n.reverse());
                var o = function(t, e, i, n) {
                    var a = {}, o = t[1] - t[0], r = a.interval = qn(o / e, !0);
                    null != i && r < i && (r = a.interval = i), null != n && n < r && (r = a.interval = n);
                    var s = a.intervalPrecision = _r(r);
                    return br(a.niceTickExtent = [ T_(Math.ceil(t[0] / r) * r, s), T_(Math.floor(t[1] / r) * r, s) ], t), 
                    a;
                }(n, t, e, i);
                this._intervalPrecision = o.intervalPrecision, this._interval = o.interval, this._niceExtent = o.niceTickExtent;
            }
        },
        niceExtent: function(t) {
            var e = this._extent;
            if (e[0] === e[1]) if (0 !== e[0]) {
                var i = e[0];
                t.fixMax || (e[1] += i / 2), e[0] -= i / 2;
            } else e[1] = 1;
            var n = e[1] - e[0];
            isFinite(n) || (e[0] = 0, e[1] = 1), this.niceTicks(t.splitNumber, t.minInterval, t.maxInterval);
            var a = this._interval;
            t.fixMin || (e[0] = D_(Math.floor(e[0] / a) * a)), t.fixMax || (e[1] = D_(Math.ceil(e[1] / a) * a));
        }
    });
    A_.create = function() {
        return new A_();
    };
    var C_ = "__ec_stack_", L_ = A_.prototype, k_ = Math.ceil, P_ = Math.floor, N_ = A_.extend({
        type: "time",
        getLabel: function(t) {
            var e = this._stepLvl, i = new Date(t);
            return oa(e[0], i, this.getSetting("useUTC"));
        },
        niceExtent: function(t) {
            var e = this._extent;
            if (e[0] === e[1] && (e[0] -= 864e5, e[1] += 864e5), e[1] === -1 / 0 && e[0] === 1 / 0) {
                var i = new Date();
                e[1] = +new Date(i.getFullYear(), i.getMonth(), i.getDate()), e[0] = e[1] - 864e5;
            }
            this.niceTicks(t.splitNumber, t.minInterval, t.maxInterval);
            var n = this._interval;
            t.fixMin || (e[0] = Bn(P_(e[0] / n) * n)), t.fixMax || (e[1] = Bn(k_(e[1] / n) * n));
        },
        niceTicks: function(t, e, i) {
            t = t || 10;
            var n = this._extent, a = n[1] - n[0], o = a / t;
            null != e && o < e && (o = e), null != i && i < o && (o = i);
            var r = O_.length, s = function(t, e, i, n) {
                for (;i < n; ) {
                    var a = i + n >>> 1;
                    t[a][1] < e ? i = a + 1 : n = a;
                }
                return i;
            }(O_, o, 0, r), l = O_[Math.min(s, r - 1)], h = l[1];
            "year" === l[0] && (h *= qn(a / h / t, !0));
            var u = this.getSetting("useUTC") ? 0 : 60 * new Date(+n[0] || +n[1]).getTimezoneOffset() * 1e3, c = [ Math.round(k_((n[0] - u) / h) * h + u), Math.round(P_((n[1] - u) / h) * h + u) ];
            br(c, n), this._stepLvl = l, this._interval = h, this._niceExtent = c;
        },
        parse: function(t) {
            return +jn(t);
        }
    });
    R([ "contain", "normalize" ], function(e) {
        N_.prototype[e] = function(t) {
            return L_[e].call(this, this.parse(t));
        };
    });
    var O_ = [ [ "hh:mm:ss", 1e3 ], [ "hh:mm:ss", 5e3 ], [ "hh:mm:ss", 1e4 ], [ "hh:mm:ss", 15e3 ], [ "hh:mm:ss", 3e4 ], [ "hh:mm\nMM-dd", 6e4 ], [ "hh:mm\nMM-dd", 3e5 ], [ "hh:mm\nMM-dd", 6e5 ], [ "hh:mm\nMM-dd", 9e5 ], [ "hh:mm\nMM-dd", 18e5 ], [ "hh:mm\nMM-dd", 36e5 ], [ "hh:mm\nMM-dd", 72e5 ], [ "hh:mm\nMM-dd", 216e5 ], [ "hh:mm\nMM-dd", 432e5 ], [ "MM-dd\nyyyy", 864e5 ], [ "MM-dd\nyyyy", 1728e5 ], [ "MM-dd\nyyyy", 2592e5 ], [ "MM-dd\nyyyy", 3456e5 ], [ "MM-dd\nyyyy", 432e6 ], [ "MM-dd\nyyyy", 5184e5 ], [ "week", 6048e5 ], [ "MM-dd\nyyyy", 864e6 ], [ "week", 12096e5 ], [ "week", 18144e5 ], [ "month", 26784e5 ], [ "week", 36288e5 ], [ "month", 53568e5 ], [ "week", 36288e5 ], [ "quarter", 8208e6 ], [ "month", 107136e5 ], [ "month", 13392e6 ], [ "half-year", 16416e6 ], [ "month", 214272e5 ], [ "month", 26784e6 ], [ "year", 32832e6 ] ];
    N_.create = function(t) {
        return new N_({
            useUTC: t.ecModel.get("useUTC")
        });
    };
    var E_ = mr.prototype, R_ = A_.prototype, z_ = Wn, B_ = Bn, V_ = Math.floor, G_ = Math.ceil, W_ = Math.pow, F_ = Math.log, H_ = mr.extend({
        type: "log",
        base: 10,
        $constructor: function() {
            mr.apply(this, arguments), this._originalScale = new A_();
        },
        getTicks: function() {
            var i = this._originalScale, n = this._extent, a = i.getExtent();
            return L(R_.getTicks.call(this), function(t) {
                var e = Bn(W_(this.base, t));
                return e = t === n[0] && i.__fixMin ? Ar(e, a[0]) : e, t === n[1] && i.__fixMax ? Ar(e, a[1]) : e;
            }, this);
        },
        getLabel: R_.getLabel,
        scale: function(t) {
            return t = E_.scale.call(this, t), W_(this.base, t);
        },
        setExtent: function(t, e) {
            var i = this.base;
            t = F_(t) / F_(i), e = F_(e) / F_(i), R_.setExtent.call(this, t, e);
        },
        getExtent: function() {
            var t = this.base, e = E_.getExtent.call(this);
            e[0] = W_(t, e[0]), e[1] = W_(t, e[1]);
            var i = this._originalScale, n = i.getExtent();
            return i.__fixMin && (e[0] = Ar(e[0], n[0])), i.__fixMax && (e[1] = Ar(e[1], n[1])), 
            e;
        },
        unionExtent: function(t) {
            this._originalScale.unionExtent(t);
            var e = this.base;
            t[0] = F_(t[0]) / F_(e), t[1] = F_(t[1]) / F_(e), E_.unionExtent.call(this, t);
        },
        unionExtentFromData: function(t, e) {
            this.unionExtent(t.getApproximateExtent(e));
        },
        niceTicks: function(t) {
            t = t || 10;
            var e = this._extent, i = e[1] - e[0];
            if (!(i === 1 / 0 || i <= 0)) {
                var n = Xn(i);
                for (t / i * n <= .5 && (n *= 10); !isNaN(n) && Math.abs(n) < 1 && 0 < Math.abs(n); ) n *= 10;
                var a = [ Bn(G_(e[0] / n) * n), Bn(V_(e[1] / n) * n) ];
                this._interval = n, this._niceExtent = a;
            }
        },
        niceExtent: function(t) {
            R_.niceExtent.call(this, t);
            var e = this._originalScale;
            e.__fixMin = t.fixMin, e.__fixMax = t.fixMax;
        }
    });
    R([ "contain", "normalize" ], function(e) {
        H_.prototype[e] = function(t) {
            return t = F_(t) / F_(this.base), E_[e].call(this, t);
        };
    }), H_.create = function() {
        return new H_();
    };
    var Z_ = {
        getFormattedLabels: function() {
            return Nr(this.axis, this.get("axisLabel.formatter"));
        },
        getMin: function(t) {
            var e = this.option, i = t || null == e.rangeStart ? e.min : e.rangeStart;
            return this.axis && null != i && "dataMin" !== i && "function" != typeof i && !y(i) && (i = this.axis.scale.parse(i)), 
            i;
        },
        getMax: function(t) {
            var e = this.option, i = t || null == e.rangeEnd ? e.max : e.rangeEnd;
            return this.axis && null != i && "dataMax" !== i && "function" != typeof i && !y(i) && (i = this.axis.scale.parse(i)), 
            i;
        },
        getNeedCrossZero: function() {
            var t = this.option;
            return null == t.rangeStart && null == t.rangeEnd && !t.scale;
        },
        getCoordSysModel: S,
        setRange: function(t, e) {
            this.option.rangeStart = t, this.option.rangeEnd = e;
        },
        resetRange: function() {
            this.option.rangeStart = this.option.rangeEnd = null;
        }
    }, U_ = Yi({
        type: "triangle",
        shape: {
            cx: 0,
            cy: 0,
            width: 0,
            height: 0
        },
        buildPath: function(t, e) {
            var i = e.cx, n = e.cy, a = e.width / 2, o = e.height / 2;
            t.moveTo(i, n - o), t.lineTo(i + a, n + o), t.lineTo(i - a, n + o), t.closePath();
        }
    }), j_ = Yi({
        type: "diamond",
        shape: {
            cx: 0,
            cy: 0,
            width: 0,
            height: 0
        },
        buildPath: function(t, e) {
            var i = e.cx, n = e.cy, a = e.width / 2, o = e.height / 2;
            t.moveTo(i, n - o), t.lineTo(i + a, n), t.lineTo(i, n + o), t.lineTo(i - a, n), 
            t.closePath();
        }
    }), X_ = Yi({
        type: "pin",
        shape: {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        },
        buildPath: function(t, e) {
            var i = e.x, n = e.y, a = e.width / 5 * 3, o = Math.max(a, e.height), r = a / 2, s = r * r / (o - r), l = n - o + r + s, h = Math.asin(s / r), u = Math.cos(h) * r, c = Math.sin(h), d = Math.cos(h), f = .6 * r, p = .7 * r;
            t.moveTo(i - u, l + s), t.arc(i, l, r, Math.PI - h, 2 * Math.PI + h), t.bezierCurveTo(i + u - c * f, l + s + d * f, i, n - p, i, n), 
            t.bezierCurveTo(i, n - p, i - u + c * f, l + s + d * f, i - u, l + s), t.closePath();
        }
    }), Y_ = Yi({
        type: "arrow",
        shape: {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        },
        buildPath: function(t, e) {
            var i = e.height, n = e.width, a = e.x, o = e.y, r = n / 3 * 2;
            t.moveTo(a, o), t.lineTo(a + r, o + i), t.lineTo(a, o + i / 4 * 3), t.lineTo(a - r, o + i), 
            t.lineTo(a, o), t.closePath();
        }
    }), q_ = {
        line: function(t, e, i, n, a) {
            a.x1 = t, a.y1 = e + n / 2, a.x2 = t + i, a.y2 = e + n / 2;
        },
        rect: function(t, e, i, n, a) {
            a.x = t, a.y = e, a.width = i, a.height = n;
        },
        roundRect: function(t, e, i, n, a) {
            a.x = t, a.y = e, a.width = i, a.height = n, a.r = Math.min(i, n) / 4;
        },
        square: function(t, e, i, n, a) {
            var o = Math.min(i, n);
            a.x = t, a.y = e, a.width = o, a.height = o;
        },
        circle: function(t, e, i, n, a) {
            a.cx = t + i / 2, a.cy = e + n / 2, a.r = Math.min(i, n) / 2;
        },
        diamond: function(t, e, i, n, a) {
            a.cx = t + i / 2, a.cy = e + n / 2, a.width = i, a.height = n;
        },
        pin: function(t, e, i, n, a) {
            a.x = t + i / 2, a.y = e + n / 2, a.width = i, a.height = n;
        },
        arrow: function(t, e, i, n, a) {
            a.x = t + i / 2, a.y = e + n / 2, a.width = i, a.height = n;
        },
        triangle: function(t, e, i, n, a) {
            a.cx = t + i / 2, a.cy = e + n / 2, a.width = i, a.height = n;
        }
    }, K_ = {};
    R({
        line: Fv,
        rect: Wv,
        roundRect: Wv,
        square: Wv,
        circle: Ov,
        diamond: j_,
        pin: X_,
        arrow: Y_,
        triangle: U_
    }, function(t, e) {
        K_[e] = new t();
    });
    var $_ = Yi({
        type: "symbol",
        shape: {
            symbolType: "",
            x: 0,
            y: 0,
            width: 0,
            height: 0
        },
        beforeBrush: function() {
            var t = this.style;
            "pin" === this.shape.symbolType && "inside" === t.textPosition && (t.textPosition = [ "50%", "40%" ], 
            t.textAlign = "center", t.textVerticalAlign = "middle");
        },
        buildPath: function(t, e, i) {
            var n = e.symbolType, a = K_[n];
            "none" !== e.symbolType && (a || (a = K_[n = "rect"]), q_[n](e.x, e.y, e.width, e.height, a.shape), 
            a.buildPath(t, a.shape, i));
        }
    }), J_ = {
        isDimensionStacked: pr,
        enableDataStack: fr
    }, Q_ = (Object.freeze || Object)({
        createList: function(t) {
            return gr(t.getSource(), t);
        },
        getLayoutRect: la,
        dataStack: J_,
        createScale: function(t, e) {
            var i = e;
            Pn.isInstance(e) || a(i = new Pn(e), Z_);
            var n = kr(i);
            return n.setExtent(t[0], t[1]), Lr(n, i), n;
        },
        mixinAxisModelCommonMethods: function(t) {
            a(t, Z_);
        },
        completeDimensions: cr,
        createDimensions: b_,
        createSymbol: Rr
    }), tw = 1e-8;
    Vr.prototype = {
        constructor: Vr,
        properties: null,
        getBoundingRect: function() {
            var t = this._rect;
            if (t) return t;
            for (var e = Number.MAX_VALUE, i = [ e, e ], n = [ -e, -e ], a = [], o = [], r = this.geometries, s = 0; s < r.length; s++) "polygon" === r[s].type && (Di(r[s].exterior, a, o), 
            tt(i, i, a), et(n, n, o));
            return 0 === s && (i[0] = i[1] = n[0] = n[1] = 0), this._rect = new Xt(i[0], i[1], n[0] - i[0], n[1] - i[1]);
        },
        contain: function(t) {
            var e = this.getBoundingRect(), i = this.geometries;
            if (!e.contain(t[0], t[1])) return !1;
            t: for (var n = 0, a = i.length; n < a; n++) if ("polygon" === i[n].type) {
                var o = i[n].exterior, r = i[n].interiors;
                if (Br(o, t[0], t[1])) {
                    for (var s = 0; s < (r ? r.length : 0); s++) if (Br(r[s])) continue t;
                    return !0;
                }
            }
            return !1;
        },
        transformTo: function(t, e, i, n) {
            var a = this.getBoundingRect(), o = a.width / a.height;
            i ? n || (n = i / o) : i = o * n;
            for (var r = new Xt(t, e, i, n), s = a.calculateTransform(r), l = this.geometries, h = 0; h < l.length; h++) if ("polygon" === l[h].type) {
                for (var u = l[h].exterior, c = l[h].interiors, d = 0; d < u.length; d++) Q(u[d], u[d], s);
                for (var f = 0; f < (c ? c.length : 0); f++) for (d = 0; d < c[f].length; d++) Q(c[f][d], c[f][d], s);
            }
            (a = this._rect).copy(r), this.center = [ a.x + a.width / 2, a.y + a.height / 2 ];
        }
    };
    var ew = function(t) {
        return function(t) {
            if (!t.UTF8Encoding) return;
            var e = t.UTF8Scale;
            null == e && (e = 1024);
            for (var i = t.features, n = 0; n < i.length; n++) for (var a = i[n].geometry, o = a.coordinates, r = a.encodeOffsets, s = 0; s < o.length; s++) {
                var l = o[s];
                if ("Polygon" === a.type) o[s] = Gr(l, r[s], e); else if ("MultiPolygon" === a.type) for (var h = 0; h < l.length; h++) {
                    var u = l[h];
                    l[h] = Gr(u, r[s][h], e);
                }
            }
            t.UTF8Encoding = !1;
        }(t), L(I(t.features, function(t) {
            return t.geometry && t.properties && 0 < t.geometry.coordinates.length;
        }), function(t) {
            var e = t.properties, i = t.geometry, n = i.coordinates, a = [];
            "Polygon" === i.type && a.push({
                type: "polygon",
                exterior: n[0],
                interiors: n.slice(1)
            }), "MultiPolygon" === i.type && R(n, function(t) {
                t[0] && a.push({
                    type: "polygon",
                    exterior: t[0],
                    interiors: t.slice(1)
                });
            });
            var o = new Vr(e.name, a, e.cp);
            return o.properties = e, o;
        });
    }, iw = Rn, nw = [ 0, 1 ], aw = function(t, e, i) {
        this.dim = t, this.scale = e, this._extent = i || [ 0, 0 ], this.inverse = !1, this.onBand = !1, 
        this._labelInterval;
    };
    aw.prototype = {
        constructor: aw,
        contain: function(t) {
            var e = this._extent, i = Math.min(e[0], e[1]), n = Math.max(e[0], e[1]);
            return i <= t && t <= n;
        },
        containData: function(t) {
            return this.contain(this.dataToCoord(t));
        },
        getExtent: function() {
            return this._extent.slice();
        },
        getPixelPrecision: function(t) {
            return Fn(t || this.scale.getExtent(), this._extent);
        },
        setExtent: function(t, e) {
            var i = this._extent;
            i[0] = t, i[1] = e;
        },
        dataToCoord: function(t, e) {
            var i = this._extent, n = this.scale;
            return t = n.normalize(t), this.onBand && "ordinal" === n.type && Wr(i = i.slice(), n.count()), 
            iw(t, nw, i, e);
        },
        coordToData: function(t, e) {
            var i = this._extent, n = this.scale;
            this.onBand && "ordinal" === n.type && Wr(i = i.slice(), n.count());
            var a = iw(t, i, nw, e);
            return this.scale.scale(a);
        },
        pointToData: function(t, e) {},
        getTicksCoords: function(t) {
            if (this.onBand && !t) {
                for (var e = this.getBands(), i = [], n = 0; n < e.length; n++) i.push(e[n][0]);
                return e[n - 1] && i.push(e[n - 1][1]), i;
            }
            return L(this.scale.getTicks(), this.dataToCoord, this);
        },
        getLabelsCoords: function() {
            return L(this.scale.getTicks(), this.dataToCoord, this);
        },
        getBands: function() {
            for (var t = this.getExtent(), e = [], i = this.scale.count(), n = t[0], a = t[1] - n, o = 0; o < i; o++) e.push([ a * o / i + n, a * (o + 1) / i + n ]);
            return e;
        },
        getBandWidth: function() {
            var t = this._extent, e = this.scale.getExtent(), i = e[1] - e[0] + (this.onBand ? 1 : 0);
            0 === i && (i = 1);
            var n = Math.abs(t[1] - t[0]);
            return Math.abs(n) / i;
        },
        isHorizontal: null,
        getRotate: null,
        getLabelInterval: function() {
            var t = this._labelInterval;
            if (!t) {
                var e = this.model, i = e.getModel("axisLabel");
                t = i.get("interval"), "category" !== this.type || null != t && "auto" !== t || (t = Pr(L(this.scale.getTicks(), this.dataToCoord, this), e.getFormattedLabels(), i.getFont(), this.getRotate ? this.getRotate() : this.isHorizontal && !this.isHorizontal() ? 90 : 0, i.get("rotate"))), 
                this._labelInterval = t;
            }
            return t;
        }
    };
    var ow = ew, rw = {};
    R([ "map", "each", "filter", "indexOf", "inherits", "reduce", "filter", "bind", "curry", "isArray", "isString", "isObject", "isFunction", "extend", "defaults", "clone", "merge" ], function(t) {
        rw[t] = zp[t];
    }), px.extend({
        type: "series.line",
        dependencies: [ "grid", "polar" ],
        getInitialData: function(t, e) {
            return gr(this.getSource(), this);
        },
        defaultOption: {
            zlevel: 0,
            z: 2,
            coordinateSystem: "cartesian2d",
            legendHoverLink: !0,
            hoverAnimation: !0,
            clipOverflow: !0,
            label: {
                position: "top"
            },
            lineStyle: {
                width: 2,
                type: "solid"
            },
            step: !1,
            smooth: !1,
            smoothMonotone: null,
            symbol: "emptyCircle",
            symbolSize: 4,
            symbolRotate: null,
            showSymbol: !0,
            showAllSymbol: !1,
            connectNulls: !1,
            sampling: "none",
            animationEasing: "linear",
            progressive: 0,
            hoverLayerThreshold: 1 / 0
        }
    });
    var sw = Zr.prototype;
    sw._createSymbol = function(t, e, i, n, a) {
        this.removeAll();
        var o = Rr(t, -1, -1, 2, 2, e.getItemVisual(i, "color"), a);
        o.attr({
            z2: 100,
            culling: !0,
            scale: Hr(n)
        }), o.drift = Ur, this._symbolType = t, this.add(o);
    }, sw.stopSymbolAnimation = function(t) {
        this.childAt(0).stopAnimation(t);
    }, sw.getSymbolPath = function() {
        return this.childAt(0);
    }, sw.getScale = function() {
        return this.childAt(0).scale;
    }, sw.highlight = function() {
        this.childAt(0).trigger("emphasis");
    }, sw.downplay = function() {
        this.childAt(0).trigger("normal");
    }, sw.setZ = function(t, e) {
        var i = this.childAt(0);
        i.zlevel = t, i.z = e;
    }, sw.setDraggable = function(t) {
        var e = this.childAt(0);
        e.draggable = t, e.cursor = t ? "move" : "pointer";
    }, sw.updateData = function(t, e, i) {
        this.silent = !1;
        var n, a, o = t.getItemVisual(e, "symbol") || "circle", r = t.hostModel, s = (n = e, 
        (a = t.getItemVisual(n, "symbolSize")) instanceof Array ? a.slice() : [ +a, +a ]), l = o !== this._symbolType;
        if (l) {
            var h = t.getItemVisual(e, "symbolKeepAspect");
            this._createSymbol(o, t, e, s, h);
        } else (u = this.childAt(0)).silent = !1, Mn(u, {
            scale: Hr(s)
        }, r, e);
        if (this._updateCommon(t, e, s, i), l) {
            var u = this.childAt(0), c = i && i.fadeIn, d = {
                scale: u.scale.slice()
            };
            c && (d.style = {
                opacity: u.style.opacity
            }), u.scale = [ 0, 0 ], c && (u.style.opacity = 0), In(u, d, r, e);
        }
        this._seriesModel = r;
    };
    var lw = [ "itemStyle" ], hw = [ "emphasis", "itemStyle" ], uw = [ "label" ], cw = [ "emphasis", "label" ];
    sw._updateCommon = function(i, t, e, n) {
        var a = this.childAt(0), o = i.hostModel, r = i.getItemVisual(t, "color");
        "image" !== a.type && a.useStyle({
            strokeNoScale: !0
        });
        var s = n && n.itemStyle, l = n && n.hoverItemStyle, h = n && n.symbolRotate, u = n && n.symbolOffset, c = n && n.labelModel, d = n && n.hoverLabelModel, f = n && n.hoverAnimation, p = n && n.cursorStyle;
        if (!n || i.hasItemOption) {
            var g = n && n.itemModel ? n.itemModel : i.getItemModel(t);
            s = g.getModel(lw).getItemStyle([ "color" ]), l = g.getModel(hw).getItemStyle(), 
            h = g.getShallow("symbolRotate"), u = g.getShallow("symbolOffset"), c = g.getModel(uw), 
            d = g.getModel(cw), f = g.getShallow("hoverAnimation"), p = g.getShallow("cursor");
        } else l = P({}, l);
        var m = a.style;
        a.attr("rotation", (h || 0) * Math.PI / 180 || 0), u && a.attr("position", [ zn(u[0], e[0]), zn(u[1], e[1]) ]), 
        p && a.attr("cursor", p), a.setColor(r, n && n.symbolInnerColor), a.setStyle(s);
        var v = i.getItemVisual(t, "opacity");
        null != v && (m.opacity = v);
        var y = n && n.useNameLabel;
        mn(m, l, c, d, {
            labelFetcher: o,
            labelDataIndex: t,
            defaultText: function(t, e) {
                return y ? i.getName(t) : Fr(i, t);
            },
            isRectText: !0,
            autoColor: r
        }), a.off("mouseover").off("mouseout").off("emphasis").off("normal"), a.hoverStyle = l, 
        gn(a);
        var x = Hr(e);
        if (f && o.isAnimationEnabled()) {
            var _ = function() {
                if (!this.incremental) {
                    var t = x[1] / x[0];
                    this.animateTo({
                        scale: [ Math.max(1.1 * x[0], x[0] + 3), Math.max(1.1 * x[1], x[1] + 3 * t) ]
                    }, 400, "elasticOut");
                }
            }, w = function() {
                this.incremental || this.animateTo({
                    scale: x
                }, 400, "elasticOut");
            };
            a.on("mouseover", _).on("mouseout", w).on("emphasis", _).on("normal", w);
        }
    }, sw.fadeOut = function(t, e) {
        var i = this.childAt(0);
        this.silent = i.silent = !0, !(e && e.keepLabel) && (i.style.text = null), Mn(i, {
            style: {
                opacity: 0
            },
            scale: [ 0, 0 ]
        }, this._seriesModel, this.dataIndex, t);
    }, o(Zr, Dg);
    var dw = jr.prototype;
    dw.updateData = function(a, o) {
        o = Yr(o);
        var r = this.group, s = a.hostModel, l = this._data, h = this._symbolCtor, u = qr(a);
        l || r.removeAll(), a.diff(l).add(function(t) {
            var e = a.getItemLayout(t);
            if (Xr(a, e, t, o)) {
                var i = new h(a, t, u);
                i.attr("position", e), a.setItemGraphicEl(t, i), r.add(i);
            }
        }).update(function(t, e) {
            var i = l.getItemGraphicEl(e), n = a.getItemLayout(t);
            Xr(a, n, t, o) ? (i ? (i.updateData(a, t, u), Mn(i, {
                position: n
            }, s)) : (i = new h(a, t)).attr("position", n), r.add(i), a.setItemGraphicEl(t, i)) : r.remove(i);
        }).remove(function(t) {
            var e = l.getItemGraphicEl(t);
            e && e.fadeOut(function() {
                r.remove(e);
            });
        }).execute(), this._data = a;
    }, dw.isPersistent = function() {
        return !0;
    }, dw.updateLayout = function() {
        var n = this._data;
        n && n.eachItemGraphicEl(function(t, e) {
            var i = n.getItemLayout(e);
            t.attr("position", i);
        });
    }, dw.incrementalPrepareUpdate = function(t) {
        this._seriesScope = qr(t), this._data = null, this.group.removeAll();
    }, dw.incrementalUpdate = function(t, e, i) {
        i = Yr(i);
        for (var n = t.start; n < t.end; n++) {
            var a = e.getItemLayout(n);
            if (Xr(e, a, n, i)) {
                var o = new this._symbolCtor(e, n, this._seriesScope);
                o.traverse(function(t) {
                    t.isGroup || (t.incremental = t.useHoverLayer = !0);
                }), o.attr("position", a), this.group.add(o), e.setItemGraphicEl(n, o);
            }
        }
    }, dw.remove = function(t) {
        var e = this.group, i = this._data;
        i && t ? i.eachItemGraphicEl(function(t) {
            t.fadeOut(function() {
                e.remove(t);
            });
        }) : e.removeAll();
    };
    var fw = tt, pw = et, gw = Z, mw = T, vw = [], yw = [], xw = [], _w = Wi.extend({
        type: "ec-polyline",
        shape: {
            points: [],
            smooth: 0,
            smoothConstraint: !0,
            smoothMonotone: null,
            connectNulls: !1
        },
        style: {
            fill: null,
            stroke: "#000"
        },
        brush: Rv(Wi.prototype.brush),
        buildPath: function(t, e) {
            var i = e.points, n = 0, a = i.length, o = ns(i, e.smoothConstraint);
            if (e.connectNulls) {
                for (;0 < a && Jr(i[a - 1]); a--) ;
                for (;n < a && Jr(i[n]); n++) ;
            }
            for (;n < a; ) n += Qr(t, i, n, a, a, 1, o.min, o.max, e.smooth, e.smoothMonotone, e.connectNulls) + 1;
        }
    }), ww = Wi.extend({
        type: "ec-polygon",
        shape: {
            points: [],
            stackedOnPoints: [],
            smooth: 0,
            stackedOnSmooth: 0,
            smoothConstraint: !0,
            smoothMonotone: null,
            connectNulls: !1
        },
        brush: Rv(Wi.prototype.brush),
        buildPath: function(t, e) {
            var i = e.points, n = e.stackedOnPoints, a = 0, o = i.length, r = e.smoothMonotone, s = ns(i, e.smoothConstraint), l = ns(n, e.smoothConstraint);
            if (e.connectNulls) {
                for (;0 < o && Jr(i[o - 1]); o--) ;
                for (;a < o && Jr(i[a]); a++) ;
            }
            for (;a < o; ) {
                var h = Qr(t, i, a, o, o, 1, s.min, s.max, e.smooth, r, e.connectNulls);
                Qr(t, n, a + h - 1, h, o, -1, l.min, l.max, e.stackedOnSmooth, r, e.connectNulls), 
                a += h + 1, t.closePath();
            }
        }
    });
    to.extend({
        type: "line",
        init: function() {
            var t = new Dg(), e = new jr();
            this.group.add(e.group), this._symbolDraw = e, this._lineGroup = t;
        },
        render: function(t, e, i) {
            var n = t.coordinateSystem, a = this.group, o = t.getData(), r = t.getModel("lineStyle"), s = t.getModel("areaStyle"), l = o.mapArray(o.getItemLayout), h = "polar" === n.type, u = this._coordSys, c = this._symbolDraw, d = this._polyline, f = this._polygon, p = this._lineGroup, g = t.get("animation"), m = !s.isEmpty(), v = s.get("origin"), y = function(t, e, i) {
                if (!i.valueDim) return [];
                for (var n = [], a = 0, o = e.count(); a < o; a++) n.push($r(i, t, e, a));
                return n;
            }(n, o, Kr(n, o, v)), x = t.get("showSymbol"), _ = x && !h && !t.get("showAllSymbol") && this._getSymbolIgnoreFunc(o, n), w = this._data;
            w && w.eachItemGraphicEl(function(t, e) {
                t.__temp && (a.remove(t), w.setItemGraphicEl(e, null));
            }), x || c.remove(), a.add(p);
            var b = !h && t.get("step");
            if (d && u.type === n.type && b === this._step) {
                m && !f ? f = this._newPolygon(l, y, n, g) : f && !m && (p.remove(f), f = this._polygon = null);
                var S = ss(n, !1, t);
                p.setClipPath(S), x && c.updateData(o, {
                    isIgnore: _,
                    clipShape: S
                }), o.eachItemGraphicEl(function(t) {
                    t.stopAnimation(!0);
                }), as(this._stackedOnPoints, y) && as(this._points, l) || (g ? this._updateAnimation(o, y, n, i, b, v) : (b && (l = ls(l, n, b), 
                y = ls(y, n, b)), d.setShape({
                    points: l
                }), f && f.setShape({
                    points: l,
                    stackedOnPoints: y
                })));
            } else x && c.updateData(o, {
                isIgnore: _,
                clipShape: ss(n, !1, t)
            }), b && (l = ls(l, n, b), y = ls(y, n, b)), d = this._newPolyline(l, n, g), m && (f = this._newPolygon(l, y, n, g)), 
            p.setClipPath(ss(n, !0, t));
            var M = function(t, e) {
                var i = t.getVisual("visualMeta");
                if (i && i.length && t.count() && "cartesian2d" === e.type) {
                    for (var n, a, o = i.length - 1; 0 <= o; o--) {
                        var r = i[o].dimension, s = t.dimensions[r], l = t.getDimensionInfo(s);
                        if ("x" === (n = l && l.coordDim) || "y" === n) {
                            a = i[o];
                            break;
                        }
                    }
                    if (a) {
                        var h = e.getAxis(n), u = L(a.stops, function(t) {
                            return {
                                coord: h.toGlobalCoord(h.dataToCoord(t.value)),
                                color: t.color
                            };
                        }), c = u.length, d = a.outerColors.slice();
                        c && u[0].coord > u[c - 1].coord && (u.reverse(), d.reverse());
                        var f = u[0].coord - 10, p = u[c - 1].coord + 10, g = p - f;
                        if (g < .001) return "transparent";
                        R(u, function(t) {
                            t.offset = (t.coord - f) / g;
                        }), u.push({
                            offset: c ? u[c - 1].offset : .5,
                            color: d[1] || "transparent"
                        }), u.unshift({
                            offset: c ? u[0].offset : .5,
                            color: d[0] || "transparent"
                        });
                        var m = new Yv(0, 0, 0, 0, u, !0);
                        return m[n] = f, m[n + "2"] = p, m;
                    }
                }
            }(o, n) || o.getVisual("color");
            d.useStyle(E(r.getLineStyle(), {
                fill: "none",
                stroke: M,
                lineJoin: "bevel"
            }));
            var I = t.get("smooth");
            if (I = os(t.get("smooth")), d.setShape({
                smooth: I,
                smoothMonotone: t.get("smoothMonotone"),
                connectNulls: t.get("connectNulls")
            }), f) {
                var T = o.getCalculationInfo("stackedOnSeries"), D = 0;
                f.useStyle(E(s.getAreaStyle(), {
                    fill: M,
                    opacity: .7,
                    lineJoin: "bevel"
                })), T && (D = os(T.get("smooth"))), f.setShape({
                    smooth: I,
                    stackedOnSmooth: D,
                    smoothMonotone: t.get("smoothMonotone"),
                    connectNulls: t.get("connectNulls")
                });
            }
            this._data = o, this._coordSys = n, this._stackedOnPoints = y, this._points = l, 
            this._step = b, this._valueOrigin = v;
        },
        dispose: function() {},
        highlight: function(t, e, i, n) {
            var a = t.getData(), o = ri(a, n);
            if (!(o instanceof Array) && null != o && 0 <= o) {
                var r = a.getItemGraphicEl(o);
                if (!r) {
                    var s = a.getItemLayout(o);
                    if (!s) return;
                    (r = new Zr(a, o)).position = s, r.setZ(t.get("zlevel"), t.get("z")), r.ignore = isNaN(s[0]) || isNaN(s[1]), 
                    r.__temp = !0, a.setItemGraphicEl(o, r), r.stopSymbolAnimation(!0), this.group.add(r);
                }
                r.highlight();
            } else to.prototype.highlight.call(this, t, e, i, n);
        },
        downplay: function(t, e, i, n) {
            var a = t.getData(), o = ri(a, n);
            if (null != o && 0 <= o) {
                var r = a.getItemGraphicEl(o);
                r && (r.__temp ? (a.setItemGraphicEl(o, null), this.group.remove(r)) : r.downplay());
            } else to.prototype.downplay.call(this, t, e, i, n);
        },
        _newPolyline: function(t) {
            var e = this._polyline;
            return e && this._lineGroup.remove(e), e = new _w({
                shape: {
                    points: t
                },
                silent: !0,
                z2: 10
            }), this._lineGroup.add(e), this._polyline = e;
        },
        _newPolygon: function(t, e) {
            var i = this._polygon;
            return i && this._lineGroup.remove(i), i = new ww({
                shape: {
                    points: t,
                    stackedOnPoints: e
                },
                silent: !0
            }), this._lineGroup.add(i), this._polygon = i;
        },
        _getSymbolIgnoreFunc: function(t, e) {
            var i = e.getAxesByScale("ordinal")[0];
            if (i && i.isLabelIgnored) return _(i.isLabelIgnored, i);
        },
        _updateAnimation: function(t, e, i, n, a, o) {
            var r = this._polyline, s = this._polygon, l = t.hostModel, h = function(t, e, i, n, a, o, r, s) {
                for (var l = function(t, e) {
                    var i = [];
                    return e.diff(t).add(function(t) {
                        i.push({
                            cmd: "+",
                            idx: t
                        });
                    }).update(function(t, e) {
                        i.push({
                            cmd: "=",
                            idx: e,
                            idx1: t
                        });
                    }).remove(function(t) {
                        i.push({
                            cmd: "-",
                            idx: t
                        });
                    }).execute(), i;
                }(t, e), h = [], u = [], c = [], d = [], f = [], p = [], g = [], m = Kr(a, e, r), v = Kr(o, t, s), y = 0; y < l.length; y++) {
                    var x = l[y], _ = !0;
                    switch (x.cmd) {
                      case "=":
                        var w = t.getItemLayout(x.idx), b = e.getItemLayout(x.idx1);
                        (isNaN(w[0]) || isNaN(w[1])) && (w = b.slice()), h.push(w), u.push(b), c.push(i[x.idx]), 
                        d.push(n[x.idx1]), g.push(e.getRawIndex(x.idx1));
                        break;

                      case "+":
                        S = x.idx, h.push(a.dataToPoint([ e.get(m.dataDimsForPoint[0], S), e.get(m.dataDimsForPoint[1], S) ])), 
                        u.push(e.getItemLayout(S).slice()), c.push($r(m, a, e, S)), d.push(n[S]), g.push(e.getRawIndex(S));
                        break;

                      case "-":
                        var S = x.idx, M = t.getRawIndex(S);
                        M !== S ? (h.push(t.getItemLayout(S)), u.push(o.dataToPoint([ t.get(v.dataDimsForPoint[0], S), t.get(v.dataDimsForPoint[1], S) ])), 
                        c.push(i[S]), d.push($r(v, o, t, S)), g.push(M)) : _ = !1;
                    }
                    _ && (f.push(x), p.push(p.length));
                }
                p.sort(function(t, e) {
                    return g[t] - g[e];
                });
                var I = [], T = [], D = [], A = [], C = [];
                for (y = 0; y < p.length; y++) S = p[y], I[y] = h[S], T[y] = u[S], D[y] = c[S], 
                A[y] = d[S], C[y] = f[S];
                return {
                    current: I,
                    next: T,
                    stackedOnCurrent: D,
                    stackedOnNext: A,
                    status: C
                };
            }(this._data, t, this._stackedOnPoints, e, this._coordSys, i, this._valueOrigin, o), u = h.current, c = h.stackedOnCurrent, d = h.next, f = h.stackedOnNext;
            a && (u = ls(h.current, i, a), c = ls(h.stackedOnCurrent, i, a), d = ls(h.next, i, a), 
            f = ls(h.stackedOnNext, i, a)), r.shape.__points = h.current, r.shape.points = u, 
            Mn(r, {
                shape: {
                    points: d
                }
            }, l), s && (s.setShape({
                points: u,
                stackedOnPoints: c
            }), Mn(s, {
                shape: {
                    points: d,
                    stackedOnPoints: f
                }
            }, l));
            for (var p = [], g = h.status, m = 0; m < g.length; m++) if ("=" === g[m].cmd) {
                var v = t.getItemGraphicEl(g[m].idx1);
                v && p.push({
                    el: v,
                    ptIdx: m
                });
            }
            r.animators && r.animators.length && r.animators[0].during(function() {
                for (var t = 0; t < p.length; t++) p[t].el.attr("position", r.shape.__points[p[t].ptIdx]);
            });
        },
        remove: function(t) {
            var i = this.group, n = this._data;
            this._lineGroup.removeAll(), this._symbolDraw.remove(!0), n && n.eachItemGraphicEl(function(t, e) {
                t.__temp && (i.remove(t), n.setItemGraphicEl(e, null));
            }), this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null;
        }
    });
    var bw = function(t, r, s) {
        return {
            seriesType: t,
            performRawSeries: !0,
            reset: function(l, t, e) {
                var i = l.getData(), n = l.get("symbol") || r, h = l.get("symbolSize"), a = l.get("symbolKeepAspect");
                if (i.setVisual({
                    legendSymbol: s || n,
                    symbol: n,
                    symbolSize: h,
                    symbolKeepAspect: a
                }), !t.isSeriesFiltered(l)) {
                    var o = "function" == typeof h;
                    return {
                        dataEach: i.hasItemOption || o ? function(t, e) {
                            if ("function" == typeof h) {
                                var i = l.getRawValue(e), n = l.getDataParams(e);
                                t.setItemVisual(e, "symbolSize", h(i, n));
                            }
                            if (t.hasItemOption) {
                                var a = t.getItemModel(e), o = a.getShallow("symbol", !0), r = a.getShallow("symbolSize", !0), s = a.getShallow("symbolKeepAspect", !0);
                                null != o && t.setItemVisual(e, "symbol", o), null != r && t.setItemVisual(e, "symbolSize", r), 
                                null != s && t.setItemVisual(e, "symbolKeepAspect", s);
                            }
                        } : null
                    };
                }
            }
        };
    }, Sw = function(t) {
        return {
            seriesType: t,
            plan: vx(),
            reset: function(t) {
                var e = t.getData(), c = t.coordinateSystem, d = t.pipelineContext.large;
                if (c) {
                    var f = L(c.dimensions, function(t) {
                        return e.mapDimension(t);
                    }).slice(0, 2), p = f.length;
                    return pr(e, f[0], f[1]) && (f[0] = e.getCalculationInfo("stackResultDimension")), 
                    pr(e, f[1], f[0]) && (f[1] = e.getCalculationInfo("stackResultDimension")), p && {
                        progress: function(t, e) {
                            for (var i = t.end - t.start, n = d && new Float32Array(i * p), a = t.start, o = 0, r = [], s = []; a < t.end; a++) {
                                var l;
                                if (1 === p) h = e.get(f[0], a, !0), l = !isNaN(h) && c.dataToPoint(h, null, s); else {
                                    var h = r[0] = e.get(f[0], a, !0), u = r[1] = e.get(f[1], a, !0);
                                    l = !isNaN(h) && !isNaN(u) && c.dataToPoint(r, null, s);
                                }
                                d ? (n[o++] = l ? l[0] : NaN, n[o++] = l ? l[1] : NaN) : e.setItemLayout(a, l && l.slice() || [ NaN, NaN ]);
                            }
                            d && e.setLayout("symbolPoints", n);
                        }
                    };
                }
            }
        };
    }, Mw = {
        average: function(t) {
            for (var e = 0, i = 0, n = 0; n < t.length; n++) isNaN(t[n]) || (e += t[n], i++);
            return 0 === i ? NaN : e / i;
        },
        sum: function(t) {
            for (var e = 0, i = 0; i < t.length; i++) e += t[i] || 0;
            return e;
        },
        max: function(t) {
            for (var e = -1 / 0, i = 0; i < t.length; i++) t[i] > e && (e = t[i]);
            return e;
        },
        min: function(t) {
            for (var e = 1 / 0, i = 0; i < t.length; i++) t[i] < e && (e = t[i]);
            return e;
        },
        nearest: function(t) {
            return t[0];
        }
    }, Iw = function(t, e) {
        return Math.round(t.length / 2);
    }, Tw = function(t) {
        this._axes = {}, this._dimList = [], this.name = t || "";
    };
    Tw.prototype = {
        constructor: Tw,
        type: "cartesian",
        getAxis: function(t) {
            return this._axes[t];
        },
        getAxes: function() {
            return L(this._dimList, hs, this);
        },
        getAxesByScale: function(e) {
            return e = e.toLowerCase(), I(this.getAxes(), function(t) {
                return t.scale.type === e;
            });
        },
        addAxis: function(t) {
            var e = t.dim;
            this._axes[e] = t, this._dimList.push(e);
        },
        dataToCoord: function(t) {
            return this._dataCoordConvert(t, "dataToCoord");
        },
        coordToData: function(t) {
            return this._dataCoordConvert(t, "coordToData");
        },
        _dataCoordConvert: function(t, e) {
            for (var i = this._dimList, n = t instanceof Array ? [] : {}, a = 0; a < i.length; a++) {
                var o = i[a], r = this._axes[o];
                n[o] = r[e](t[o]);
            }
            return n;
        }
    }, us.prototype = {
        constructor: us,
        type: "cartesian2d",
        dimensions: [ "x", "y" ],
        getBaseAxis: function() {
            return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x");
        },
        containPoint: function(t) {
            var e = this.getAxis("x"), i = this.getAxis("y");
            return e.contain(e.toLocalCoord(t[0])) && i.contain(i.toLocalCoord(t[1]));
        },
        containData: function(t) {
            return this.getAxis("x").containData(t[0]) && this.getAxis("y").containData(t[1]);
        },
        dataToPoint: function(t, e, i) {
            var n = this.getAxis("x"), a = this.getAxis("y");
            return (i = i || [])[0] = n.toGlobalCoord(n.dataToCoord(t[0])), i[1] = a.toGlobalCoord(a.dataToCoord(t[1])), 
            i;
        },
        clampData: function(t, e) {
            var i = this.getAxis("x").scale, n = this.getAxis("y").scale, a = i.getExtent(), o = n.getExtent(), r = i.parse(t[0]), s = n.parse(t[1]);
            return (e = e || [])[0] = Math.min(Math.max(Math.min(a[0], a[1]), r), Math.max(a[0], a[1])), 
            e[1] = Math.min(Math.max(Math.min(o[0], o[1]), s), Math.max(o[0], o[1])), e;
        },
        pointToData: function(t, e) {
            var i = this.getAxis("x"), n = this.getAxis("y");
            return (e = e || [])[0] = i.coordToData(i.toLocalCoord(t[0])), e[1] = n.coordToData(n.toLocalCoord(t[1])), 
            e;
        },
        getOtherAxis: function(t) {
            return this.getAxis("x" === t.dim ? "y" : "x");
        }
    }, o(us, Tw);
    var Dw = function(t, e, i, n, a) {
        aw.call(this, t, e, i), this.type = n || "value", this.position = a || "bottom";
    };
    Dw.prototype = {
        constructor: Dw,
        index: 0,
        getAxesOnZeroOf: null,
        model: null,
        isHorizontal: function() {
            var t = this.position;
            return "top" === t || "bottom" === t;
        },
        getGlobalExtent: function(t) {
            var e = this.getExtent();
            return e[0] = this.toGlobalCoord(e[0]), e[1] = this.toGlobalCoord(e[1]), t && e[0] > e[1] && e.reverse(), 
            e;
        },
        getOtherAxis: function() {
            this.grid.getOtherAxis();
        },
        isLabelIgnored: function(t) {
            if ("category" === this.type) {
                var e = this.getLabelInterval();
                return "function" == typeof e && !e(t, this.scale.getLabel(t)) || t % (e + 1);
            }
        },
        pointToData: function(t, e) {
            return this.coordToData(this.toLocalCoord(t["x" === this.dim ? 0 : 1]), e);
        },
        toLocalCoord: null,
        toGlobalCoord: null
    }, o(Dw, aw);
    var Aw = {
        show: !0,
        zlevel: 0,
        z: 0,
        inverse: !1,
        name: "",
        nameLocation: "end",
        nameRotate: null,
        nameTruncate: {
            maxWidth: null,
            ellipsis: "...",
            placeholder: "."
        },
        nameTextStyle: {},
        nameGap: 15,
        silent: !1,
        triggerEvent: !1,
        tooltip: {
            show: !1
        },
        axisPointer: {},
        axisLine: {
            show: !0,
            onZero: !0,
            onZeroAxisIndex: null,
            lineStyle: {
                color: "#333",
                width: 1,
                type: "solid"
            },
            symbol: [ "none", "none" ],
            symbolSize: [ 10, 15 ]
        },
        axisTick: {
            show: !0,
            inside: !1,
            length: 5,
            lineStyle: {
                width: 1
            }
        },
        axisLabel: {
            show: !0,
            inside: !1,
            rotate: 0,
            showMinLabel: null,
            showMaxLabel: null,
            margin: 8,
            fontSize: 12
        },
        splitLine: {
            show: !0,
            lineStyle: {
                color: [ "#ccc" ],
                width: 1,
                type: "solid"
            }
        },
        splitArea: {
            show: !1,
            areaStyle: {
                color: [ "rgba(250,250,250,0.3)", "rgba(200,200,200,0.3)" ]
            }
        }
    }, Cw = {};
    Cw.categoryAxis = g({
        boundaryGap: !0,
        deduplication: null,
        splitLine: {
            show: !1
        },
        axisTick: {
            alignWithLabel: !1,
            interval: "auto"
        },
        axisLabel: {
            interval: "auto"
        }
    }, Aw), Cw.valueAxis = g({
        boundaryGap: [ 0, 0 ],
        splitNumber: 5
    }, Aw), Cw.timeAxis = E({
        scale: !0,
        min: "dataMin",
        max: "dataMax"
    }, Cw.valueAxis), Cw.logAxis = E({
        scale: !0,
        logBase: 10
    }, Cw.valueAxis);
    var Lw = [ "value", "category", "time", "log" ], kw = function(o, t, r, e) {
        R(Lw, function(a) {
            t.extend({
                type: o + "Axis." + a,
                mergeDefaultAndTheme: function(t, e) {
                    var i = this.layoutMode, n = i ? ca(t) : {};
                    g(t, e.getTheme().get(a + "Axis")), g(t, this.getDefaultOption()), t.type = r(o, t), 
                    i && ua(t, n, i);
                },
                optionUpdated: function() {
                    "category" === this.option.type && (this.__ordinalMeta = vr.createByAxisModel(this));
                },
                getCategories: function(t) {
                    var e = this.option;
                    if ("category" === e.type) return t ? e.data : this.__ordinalMeta.categories;
                },
                getOrdinalMeta: function() {
                    return this.__ordinalMeta;
                },
                defaultOption: u([ {}, Cw[a + "Axis"], e ], !0)
            });
        }), Cy.registerSubTypeDefaulter(o + "Axis", z(r, o));
    }, Pw = Cy.extend({
        type: "cartesian2dAxis",
        axis: null,
        init: function() {
            Pw.superApply(this, "init", arguments), this.resetRange();
        },
        mergeOption: function() {
            Pw.superApply(this, "mergeOption", arguments), this.resetRange();
        },
        restoreData: function() {
            Pw.superApply(this, "restoreData", arguments), this.resetRange();
        },
        getCoordSysModel: function() {
            return this.ecModel.queryComponents({
                mainType: "grid",
                index: this.option.gridIndex,
                id: this.option.gridId
            })[0];
        }
    });
    g(Pw.prototype, Z_);
    var Nw = {
        offset: 0
    };
    kw("x", Pw, cs, Nw), kw("y", Pw, cs, Nw), Cy.extend({
        type: "grid",
        dependencies: [ "xAxis", "yAxis" ],
        layoutMode: "box",
        coordinateSystem: null,
        defaultOption: {
            show: !1,
            zlevel: 0,
            z: 0,
            left: "10%",
            top: 60,
            right: "10%",
            bottom: 60,
            containLabel: !1,
            backgroundColor: "rgba(0,0,0,0)",
            borderWidth: 1,
            borderColor: "#ccc"
        }
    });
    var Ow = R, Ew = function(t) {
        var e = t.scale.getExtent(), i = e[0], n = e[1];
        return !(0 < i && 0 < n || i < 0 && n < 0);
    }, Rw = Lr, zw = fs.prototype;
    zw.type = "grid", zw.axisPointerEnabled = !0, zw.getRect = function() {
        return this._rect;
    }, zw.update = function(t, e) {
        var i = this._axesMap;
        this._updateScale(t, this.model), Ow(i.x, function(t) {
            Rw(t.scale, t.model);
        }), Ow(i.y, function(t) {
            Rw(t.scale, t.model);
        }), Ow(i.x, function(t) {
            ps(i, "y", t);
        }), Ow(i.y, function(t) {
            ps(i, "x", t);
        }), this.resize(this.model, e);
    }, zw.resize = function(t, e, i) {
        function n() {
            Ow(a, function(t) {
                var e, i, n, a, o = t.isHorizontal(), r = o ? [ 0, l.width ] : [ 0, l.height ], s = t.inverse ? 1 : 0;
                t.setExtent(r[s], r[1 - s]), e = t, i = o ? l.x : l.y, n = e.getExtent(), a = n[0] + n[1], 
                e.toGlobalCoord = "x" === e.dim ? function(t) {
                    return t + i;
                } : function(t) {
                    return a - t + i;
                }, e.toLocalCoord = "x" === e.dim ? function(t) {
                    return t - i;
                } : function(t) {
                    return a - t + i;
                };
            });
        }
        var l = la(t.getBoxLayoutParams(), {
            width: e.getWidth(),
            height: e.getHeight()
        });
        this._rect = l;
        var a = this._axesList;
        n(), !i && t.get("containLabel") && (Ow(a, function(t) {
            if (!t.model.get("axisLabel.inside")) {
                var e = function(t) {
                    var e, i, n, a, o, r, s, l, h, u = t.model, c = u.get("axisLabel.show") ? u.getFormattedLabels() : [], d = u.getModel("axisLabel"), f = 1, p = c.length;
                    40 < p && (f = Math.ceil(p / 40));
                    for (var g = 0; g < p; g += f) if (!t.isLabelIgnored(g)) {
                        var m = (i = d.getTextRect(c[g]), n = d.get("rotate") || 0, a = n * Math.PI / 180, 
                        o = i.plain(), r = o.width, s = o.height, l = r * Math.cos(a) + s * Math.sin(a), 
                        h = r * Math.sin(a) + s * Math.cos(a), new Xt(o.x, o.y, l, h));
                        e ? e.union(m) : e = m;
                    }
                    return e;
                }(t);
                if (e) {
                    var i = t.isHorizontal() ? "height" : "width", n = t.model.get("axisLabel.margin");
                    l[i] -= e[i] + n, "top" === t.position ? l.y += e.height + n : "left" === t.position && (l.x += e.width + n);
                }
            }
        }), n());
    }, zw.getAxis = function(t, e) {
        var i = this._axesMap[t];
        if (null != i) {
            if (null == e) for (var n in i) if (i.hasOwnProperty(n)) return i[n];
            return i[e];
        }
    }, zw.getAxes = function() {
        return this._axesList.slice();
    }, zw.getCartesian = function(t, e) {
        if (null != t && null != e) {
            var i = "x" + t + "y" + e;
            return this._coordsMap[i];
        }
        B(t) && (e = t.yAxisIndex, t = t.xAxisIndex);
        for (var n = 0, a = this._coordsList; n < a.length; n++) if (a[n].getAxis("x").index === t || a[n].getAxis("y").index === e) return a[n];
    }, zw.getCartesians = function() {
        return this._coordsList.slice();
    }, zw.convertToPixel = function(t, e, i) {
        var n = this._findConvertTarget(t, e);
        return n.cartesian ? n.cartesian.dataToPoint(i) : n.axis ? n.axis.toGlobalCoord(n.axis.dataToCoord(i)) : null;
    }, zw.convertFromPixel = function(t, e, i) {
        var n = this._findConvertTarget(t, e);
        return n.cartesian ? n.cartesian.pointToData(i) : n.axis ? n.axis.coordToData(n.axis.toLocalCoord(i)) : null;
    }, zw._findConvertTarget = function(t, e) {
        var i, n, a = e.seriesModel, o = e.xAxisModel || a && a.getReferringComponents("xAxis")[0], r = e.yAxisModel || a && a.getReferringComponents("yAxis")[0], s = e.gridModel, l = this._coordsList;
        return a ? C(l, i = a.coordinateSystem) < 0 && (i = null) : o && r ? i = this.getCartesian(o.componentIndex, r.componentIndex) : o ? n = this.getAxis("x", o.componentIndex) : r ? n = this.getAxis("y", r.componentIndex) : s && s.coordinateSystem === this && (i = this._coordsList[0]), 
        {
            cartesian: i,
            axis: n
        };
    }, zw.containPoint = function(t) {
        var e = this._coordsList[0];
        if (e) return e.containPoint(t);
    }, zw._initCartesian = function(r, t, e) {
        function i(o) {
            return function(t, e) {
                if (ds(t, r)) {
                    var i = t.get("position");
                    "x" === o ? "top" !== i && "bottom" !== i && s[i = "bottom"] && (i = "top" === i ? "bottom" : "top") : "left" !== i && "right" !== i && s[i = "left"] && (i = "left" === i ? "right" : "left"), 
                    s[i] = !0;
                    var n = new Dw(o, kr(t), [ 0, 0 ], t.get("type"), i), a = "category" === n.type;
                    n.onBand = a && t.get("boundaryGap"), n.inverse = t.get("inverse"), (t.axis = n).model = t, 
                    n.grid = this, n.index = e, this._axesList.push(n), l[o][e] = n, h[o]++;
                }
            };
        }
        var s = {
            left: !1,
            right: !1,
            top: !1,
            bottom: !1
        }, l = {
            x: {},
            y: {}
        }, h = {
            x: 0,
            y: 0
        };
        if (t.eachComponent("xAxis", i("x"), this), t.eachComponent("yAxis", i("y"), this), 
        !h.x || !h.y) return this._axesMap = {}, void (this._axesList = []);
        this._axesMap = l, Ow(l.x, function(a, o) {
            Ow(l.y, function(t, e) {
                var i = "x" + o + "y" + e, n = new us(i);
                n.grid = this, n.model = r, this._coordsMap[i] = n, this._coordsList.push(n), n.addAxis(a), 
                n.addAxis(t);
            }, this);
        }, this);
    }, zw._updateScale = function(t, l) {
        function h(e, i, t) {
            Ow(e.mapDimension(i.dim, !0), function(t) {
                i.scale.unionExtentFromData(e, t);
            });
        }
        R(this._axesList, function(t) {
            t.scale.setExtent(1 / 0, -1 / 0);
        }), t.eachSeries(function(t) {
            if (vs(t)) {
                var e = ms(t), i = e[0], n = e[1];
                if (!ds(i, l) || !ds(n, l)) return;
                var a = this.getCartesian(i.componentIndex, n.componentIndex), o = t.getData(), r = a.getAxis("x"), s = a.getAxis("y");
                "list" === o.type && (h(o, r), h(o, s));
            }
        }, this);
    }, zw.getTooltipAxes = function(n) {
        var a = [], o = [];
        return Ow(this.getCartesians(), function(t) {
            var e = null != n && "auto" !== n ? t.getAxis(n) : t.getBaseAxis(), i = t.getOtherAxis(e);
            C(a, e) < 0 && a.push(e), C(o, i) < 0 && o.push(i);
        }), {
            baseAxes: a,
            otherAxes: o
        };
    };
    var Bw = [ "xAxis", "yAxis" ];
    fs.create = function(n, a) {
        var o = [];
        return n.eachComponent("grid", function(t, e) {
            var i = new fs(t, n, a);
            i.name = "grid_" + e, i.resize(t, a, !0), t.coordinateSystem = i, o.push(i);
        }), n.eachSeries(function(t) {
            if (vs(t)) {
                var e = ms(t), i = e[0], n = e[1], a = i.getCoordSysModel().coordinateSystem;
                t.coordinateSystem = a.getCartesian(i.componentIndex, n.componentIndex);
            }
        }), o;
    }, fs.dimensions = fs.prototype.dimensions = us.prototype.dimensions, Ma.register("cartesian2d", fs);
    var Vw = Math.PI, Gw = function(t, e) {
        this.opt = e, this.axisModel = t, E(e, {
            labelOffset: 0,
            nameDirection: 1,
            tickDirection: 1,
            labelDirection: 1,
            silent: !0
        }), this.group = new Dg();
        var i = new Dg({
            position: e.position.slice(),
            rotation: e.rotation
        });
        i.updateTransform(), this._transform = i.transform, this._dumbGroup = i;
    };
    Gw.prototype = {
        constructor: Gw,
        hasBuilder: function(t) {
            return !!Ww[t];
        },
        add: function(t) {
            Ww[t].call(this);
        },
        getGroup: function() {
            return this.group;
        }
    };
    var Ww = {
        axisLine: function() {
            var o = this.opt, t = this.axisModel;
            if (t.get("axisLine.show")) {
                var e = this.axisModel.axis.getExtent(), i = this._transform, r = [ e[0], 0 ], n = [ e[1], 0 ];
                i && (Q(r, r, i), Q(n, n, i));
                var s = P({
                    lineCap: "round"
                }, t.getModel("axisLine.lineStyle").getLineStyle());
                this.group.add(new Fv(Qi({
                    anid: "line",
                    shape: {
                        x1: r[0],
                        y1: r[1],
                        x2: n[0],
                        y2: n[1]
                    },
                    style: s,
                    strokeContainThreshold: o.strokeContainThreshold || 5,
                    silent: !0,
                    z2: 1
                })));
                var l = t.get("axisLine.symbol"), a = t.get("axisLine.symbolSize"), h = t.get("axisLine.symbolOffset") || 0;
                if ("number" == typeof h && (h = [ h, h ]), null != l) {
                    "string" == typeof l && (l = [ l, l ]), "string" != typeof a && "number" != typeof a || (a = [ a, a ]);
                    var u = a[0], c = a[1];
                    R([ {
                        rotate: o.rotation + Math.PI / 2,
                        offset: h[0],
                        r: 0
                    }, {
                        rotate: o.rotation - Math.PI / 2,
                        offset: h[1],
                        r: Math.sqrt((r[0] - n[0]) * (r[0] - n[0]) + (r[1] - n[1]) * (r[1] - n[1]))
                    } ], function(t, e) {
                        if ("none" !== l[e] && null != l[e]) {
                            var i = Rr(l[e], -u / 2, -c / 2, u, c, s.stroke, !0), n = t.r + t.offset, a = [ r[0] + n * Math.cos(o.rotation), r[1] - n * Math.sin(o.rotation) ];
                            i.attr({
                                rotation: t.rotate,
                                position: a,
                                silent: !0
                            }), this.group.add(i);
                        }
                    }, this);
                }
            }
        },
        axisTickLabel: function() {
            var t = this.axisModel, e = this.opt, i = function(t, e, i) {
                var n = e.axis;
                if (e.get("axisTick.show") && !n.scale.isBlank()) {
                    for (var a = e.getModel("axisTick"), o = a.getModel("lineStyle"), r = a.get("length"), s = Zw(a, i.labelInterval), l = n.getTicksCoords(a.get("alignWithLabel")), h = n.scale.getTicks(), u = e.get("axisLabel.showMinLabel"), c = e.get("axisLabel.showMaxLabel"), d = [], f = [], p = t._transform, g = [], m = l.length, v = 0; v < m; v++) if (!Hw(n, v, s, m, u, c)) {
                        var y = l[v];
                        d[0] = y, f[d[1] = 0] = y, f[1] = i.tickDirection * r, p && (Q(d, d, p), Q(f, f, p));
                        var x = new Fv(Qi({
                            anid: "tick_" + h[v],
                            shape: {
                                x1: d[0],
                                y1: d[1],
                                x2: f[0],
                                y2: f[1]
                            },
                            style: E(o.getLineStyle(), {
                                stroke: e.get("axisLine.lineStyle.color")
                            }),
                            z2: 2,
                            silent: !0
                        }));
                        t.group.add(x), g.push(x);
                    }
                    return g;
                }
            }(this, t, e);
            !function(t, e, i) {
                var n = t.get("axisLabel.showMinLabel"), a = t.get("axisLabel.showMaxLabel");
                i = i || [];
                var o = (e = e || [])[0], r = e[1], s = e[e.length - 1], l = e[e.length - 2], h = i[0], u = i[1], c = i[i.length - 1], d = i[i.length - 2];
                !1 === n ? (_s(o), _s(h)) : ws(o, r) && (n ? (_s(r), _s(u)) : (_s(o), _s(h))), !1 === a ? (_s(s), 
                _s(c)) : ws(l, s) && (a ? (_s(l), _s(d)) : (_s(s), _s(c)));
            }(t, function(s, l, h) {
                var u = l.axis;
                if (V(h.axisLabelShow, l.get("axisLabel.show")) && !u.scale.isBlank()) {
                    var c = l.getModel("axisLabel"), d = c.get("margin"), f = u.scale.getTicks(), p = l.getFormattedLabels(), t = (V(h.labelRotate, c.get("rotate")) || 0) * Vw / 180, g = Fw(h.rotation, t, h.labelDirection), m = l.getCategories(!0), v = [], y = xs(l), x = l.get("triggerEvent"), _ = l.get("axisLabel.showMinLabel"), w = l.get("axisLabel.showMaxLabel");
                    return R(f, function(t, e) {
                        if (!Hw(u, e, h.labelInterval, f.length, _, w)) {
                            var i = c;
                            m && m[t] && m[t].textStyle && (i = new Pn(m[t].textStyle, c, l.ecModel));
                            var n = i.getTextColor() || l.get("axisLine.lineStyle.color"), a = [ u.dataToCoord(t), h.labelOffset + h.labelDirection * d ], o = u.scale.getLabel(t), r = new Nv({
                                anid: "label_" + t,
                                position: a,
                                rotation: g.rotation,
                                silent: y,
                                z2: 10
                            });
                            vn(r.style, i, {
                                text: p[e],
                                textAlign: i.getShallow("align", !0) || g.textAlign,
                                textVerticalAlign: i.getShallow("verticalAlign", !0) || i.getShallow("baseline", !0) || g.textVerticalAlign,
                                textFill: "function" == typeof n ? n("category" === u.type ? o : "value" === u.type ? t + "" : t, e) : n
                            }), x && (r.eventData = ys(l), r.eventData.targetType = "axisLabel", r.eventData.value = o), 
                            s._dumbGroup.add(r), r.updateTransform(), v.push(r), s.group.add(r), r.decomposeTransform();
                        }
                    }), v;
                }
            }(this, t, e), i);
        },
        axisName: function() {
            var t, e, i, n, a, o, r, s = this.opt, l = this.axisModel, h = V(s.axisName, l.get("name"));
            if (h) {
                var u, c, d = l.get("nameLocation"), f = s.nameDirection, p = l.getModel("nameTextStyle"), g = l.get("nameGap") || 0, m = this.axisModel.axis.getExtent(), v = m[0] > m[1] ? -1 : 1, y = [ "start" === d ? m[0] - v * g : "end" === d ? m[1] + v * g : (m[0] + m[1]) / 2, bs(d) ? s.labelOffset + f * g : 0 ], x = l.get("nameRotate");
                null != x && (x = x * Vw / 180), bs(d) ? u = Fw(s.rotation, null != x ? x : s.rotation, f) : (t = d, 
                e = m, a = Zn((x || 0) - s.rotation), o = e[0] > e[1], r = "start" === t && !o || "start" !== t && o, 
                Un(a - Vw / 2) ? (n = r ? "bottom" : "top", i = "center") : Un(a - 1.5 * Vw) ? (n = r ? "top" : "bottom", 
                i = "center") : (n = "middle", i = a < 1.5 * Vw && Vw / 2 < a ? r ? "left" : "right" : r ? "right" : "left"), 
                u = {
                    rotation: a,
                    textAlign: i,
                    textVerticalAlign: n
                }, null != (c = s.axisNameAvailableWidth) && (c = Math.abs(c / Math.sin(u.rotation)), 
                !isFinite(c) && (c = null)));
                var _ = p.getFont(), w = l.get("nameTruncate", !0) || {}, b = w.ellipsis, S = V(s.nameTruncateMaxWidth, w.maxWidth, c), M = null != b && null != S ? wy(h, S, _, b, {
                    minChar: 2,
                    placeholder: w.placeholder
                }) : h, I = l.get("tooltip", !0), T = l.mainType, D = {
                    componentType: T,
                    name: h,
                    $vars: [ "name" ]
                };
                D[T + "Index"] = l.componentIndex;
                var A = new Nv({
                    anid: "name",
                    __fullText: h,
                    __truncatedText: M,
                    position: y,
                    rotation: u.rotation,
                    silent: xs(l),
                    z2: 1,
                    tooltip: I && I.show ? P({
                        content: h,
                        formatter: function() {
                            return h;
                        },
                        formatterParams: D
                    }, I) : null
                });
                vn(A.style, p, {
                    text: M,
                    textFont: _,
                    textFill: p.getTextColor() || l.get("axisLine.lineStyle.color"),
                    textAlign: u.textAlign,
                    textVerticalAlign: u.textVerticalAlign
                }), l.get("triggerEvent") && (A.eventData = ys(l), A.eventData.targetType = "axisName", 
                A.eventData.name = h), this._dumbGroup.add(A), A.updateTransform(), this.group.add(A), 
                A.decomposeTransform();
            }
        }
    }, Fw = Gw.innerTextLayout = function(t, e, i) {
        var n, a, o = Zn(e - t);
        return Un(o) ? (a = 0 < i ? "top" : "bottom", n = "center") : Un(o - Vw) ? (a = 0 < i ? "bottom" : "top", 
        n = "center") : (a = "middle", n = 0 < o && o < Vw ? 0 < i ? "right" : "left" : 0 < i ? "left" : "right"), 
        {
            rotation: o,
            textAlign: n,
            textVerticalAlign: a
        };
    }, Hw = Gw.ifIgnoreOnTick = function(t, e, i, n, a, o) {
        if (0 === e && a || e === n - 1 && o) return !1;
        var r, s = t.scale;
        return "ordinal" === s.type && ("function" == typeof i ? !i(r = s.getTicks()[e], s.getLabel(r)) : e % (i + 1));
    }, Zw = Gw.getInterval = function(t, e) {
        var i = t.get("interval");
        return null != i && "auto" != i || (i = e), i;
    }, Uw = R, jw = z, Xw = qo({
        type: "axis",
        _axisPointer: null,
        axisPointerClass: null,
        render: function(t, e, i, n) {
            this.axisPointerClass && function(t) {
                var e = Is(t);
                if (e) {
                    var i = e.axisPointerModel, n = e.axis.scale, a = i.option, o = i.get("status"), r = i.get("value");
                    null != r && (r = n.parse(r));
                    var s = Ts(i);
                    null == o && (a.status = s ? "show" : "hide");
                    var l = n.getExtent().slice();
                    l[0] > l[1] && l.reverse(), (null == r || r > l[1]) && (r = l[1]), r < l[0] && (r = l[0]), 
                    a.value = r, s && (a.status = e.axis.scale.isBlank() ? "hide" : "show");
                }
            }(t), Xw.superApply(this, "render", arguments), As(this, t, 0, i, 0, !0);
        },
        updateAxisPointer: function(t, e, i, n, a) {
            As(this, t, 0, i, 0, !1);
        },
        remove: function(t, e) {
            var i = this._axisPointer;
            i && i.remove(e), Xw.superApply(this, "remove", arguments);
        },
        dispose: function(t, e) {
            Cs(this, e), Xw.superApply(this, "dispose", arguments);
        }
    }), Yw = [];
    Xw.registerAxisPointerClass = function(t, e) {
        Yw[t] = e;
    }, Xw.getAxisPointerClass = function(t) {
        return t && Yw[t];
    };
    var qw = Gw.ifIgnoreOnTick, Kw = Gw.getInterval, $w = [ "axisLine", "axisTickLabel", "axisName" ], Jw = [ "splitArea", "splitLine" ], Qw = Xw.extend({
        type: "cartesianAxis",
        axisPointerClass: "CartesianAxisPointer",
        render: function(e, t, i, n) {
            this.group.removeAll();
            var a = this._axisGroup;
            if (this._axisGroup = new Dg(), this.group.add(this._axisGroup), e.get("show")) {
                var o = e.getCoordSysModel(), r = Ls(o, e), s = new Gw(e, r);
                R($w, s.add, s), this._axisGroup.add(s.getGroup()), R(Jw, function(t) {
                    e.get(t + ".show") && this["_" + t](e, o, r.labelInterval);
                }, this), Cn(a, this._axisGroup, e), Qw.superCall(this, "render", e, t, i, n);
            }
        },
        _splitLine: function(t, e, i) {
            var n = t.axis;
            if (!n.scale.isBlank()) {
                var a = t.getModel("splitLine"), o = a.getModel("lineStyle"), r = o.get("color"), s = Kw(a, i);
                r = N(r) ? r : [ r ];
                for (var l = e.coordinateSystem.getRect(), h = n.isHorizontal(), u = 0, c = n.getTicksCoords(), d = n.scale.getTicks(), f = t.get("axisLabel.showMinLabel"), p = t.get("axisLabel.showMaxLabel"), g = [], m = [], v = o.getLineStyle(), y = 0; y < c.length; y++) if (!qw(n, y, s, c.length, f, p)) {
                    var x = n.toGlobalCoord(c[y]);
                    h ? (g[0] = x, g[1] = l.y, m[0] = x, m[1] = l.y + l.height) : (g[0] = l.x, g[1] = x, 
                    m[0] = l.x + l.width, m[1] = x);
                    var _ = u++ % r.length;
                    this._axisGroup.add(new Fv(Qi({
                        anid: "line_" + d[y],
                        shape: {
                            x1: g[0],
                            y1: g[1],
                            x2: m[0],
                            y2: m[1]
                        },
                        style: E({
                            stroke: r[_]
                        }, v),
                        silent: !0
                    })));
                }
            }
        },
        _splitArea: function(t, e, i) {
            var n = t.axis;
            if (!n.scale.isBlank()) {
                var a = t.getModel("splitArea"), o = a.getModel("areaStyle"), r = o.get("color"), s = e.coordinateSystem.getRect(), l = n.getTicksCoords(), h = n.scale.getTicks(), u = n.toGlobalCoord(l[0]), c = n.toGlobalCoord(l[0]), d = 0, f = Kw(a, i), p = o.getAreaStyle();
                r = N(r) ? r : [ r ];
                for (var g = t.get("axisLabel.showMinLabel"), m = t.get("axisLabel.showMaxLabel"), v = 1; v < l.length; v++) if (!(qw(n, v, f, l.length, g, m) && v < l.length - 1)) {
                    var y, x, _, w, b = n.toGlobalCoord(l[v]);
                    n.isHorizontal() ? (y = u, x = s.y, _ = b - y, w = s.height) : (y = s.x, x = c, 
                    _ = s.width, w = b - x);
                    var S = d++ % r.length;
                    this._axisGroup.add(new Wv({
                        anid: "area_" + h[v],
                        shape: {
                            x: y,
                            y: x,
                            width: _,
                            height: w
                        },
                        style: E({
                            fill: r[S]
                        }, p),
                        silent: !0
                    })), u = y + _, c = x + w;
                }
            }
        }
    });
    Qw.extend({
        type: "xAxis"
    }), Qw.extend({
        type: "yAxis"
    }), qo({
        type: "grid",
        render: function(t, e) {
            this.group.removeAll(), t.get("show") && this.group.add(new Wv({
                shape: t.coordinateSystem.getRect(),
                style: E({
                    fill: t.get("backgroundColor")
                }, t.getItemStyle()),
                silent: !0,
                z2: -1
            }));
        }
    }), Go(function(t) {
        t.xAxis && t.yAxis && !t.grid && (t.grid = {});
    }), Uo(bw("line", "circle", "line")), Zo(Sw("line")), Wo(Zx.PROCESSOR.STATISTIC, {
        seriesType: "line",
        reset: function(t, e, i) {
            var n = t.getData(), a = t.get("sampling"), o = t.coordinateSystem;
            if ("cartesian2d" === o.type && a) {
                var r, s = o.getBaseAxis(), l = o.getOtherAxis(s), h = s.getExtent(), u = h[1] - h[0], c = Math.round(n.count() / u);
                1 < c && ("string" == typeof a ? r = Mw[a] : "function" == typeof a && (r = a), 
                r && t.setData(n.downSample(l.dim, 1 / c, r, Iw)));
            }
        }
    });
    var tb = px.extend({
        type: "series.__base_bar__",
        getInitialData: function(t, e) {
            return gr(this.getSource(), this);
        },
        getMarkerPosition: function(t) {
            var e = this.coordinateSystem;
            if (e) {
                var i = e.dataToPoint(e.clampData(t)), n = this.getData(), a = n.getLayout("offset"), o = n.getLayout("size");
                return i[e.getBaseAxis().isHorizontal() ? 0 : 1] += a + o / 2, i;
            }
            return [ NaN, NaN ];
        },
        defaultOption: {
            zlevel: 0,
            z: 2,
            coordinateSystem: "cartesian2d",
            legendHoverLink: !0,
            barMinHeight: 0,
            barMinAngle: 0,
            itemStyle: {},
            emphasis: {}
        }
    });
    tb.extend({
        type: "series.bar",
        dependencies: [ "grid", "polar" ],
        brushSelector: "rect"
    });
    var eb = Dm([ [ "fill", "color" ], [ "stroke", "borderColor" ], [ "lineWidth", "borderWidth" ], [ "stroke", "barBorderColor" ], [ "lineWidth", "barBorderWidth" ], [ "opacity" ], [ "shadowBlur" ], [ "shadowOffsetX" ], [ "shadowOffsetY" ], [ "shadowColor" ] ]), ib = [ "itemStyle", "barBorderWidth" ];
    P(Pn.prototype, {
        getBarItemStyle: function(t) {
            var e = eb(this, t);
            if (this.getBorderLineDash) {
                var i = this.getBorderLineDash();
                i && (e.lineDash = i);
            }
            return e;
        }
    }), $o({
        type: "bar",
        render: function(t, e, i) {
            var n = t.get("coordinateSystem");
            return "cartesian2d" !== n && "polar" !== n || this._render(t, e, i), this.group;
        },
        dispose: S,
        _render: function(o, t, e) {
            var r, s = this.group, l = o.getData(), h = this._data, u = o.coordinateSystem, i = u.getBaseAxis();
            "cartesian2d" === u.type ? r = i.isHorizontal() : "polar" === u.type && (r = "angle" === i.dim);
            var c = o.isAnimationEnabled() ? o : null;
            l.diff(h).add(function(t) {
                if (l.hasValue(t)) {
                    var e = l.getItemModel(t), i = ab[u.type](l, t, e), n = nb[u.type](l, t, e, i, r, c);
                    l.setItemGraphicEl(t, n), s.add(n), Es(n, l, t, e, i, o, r, "polar" === u.type);
                }
            }).update(function(t, e) {
                var i = h.getItemGraphicEl(e);
                if (l.hasValue(t)) {
                    var n = l.getItemModel(t), a = ab[u.type](l, t, n);
                    i ? Mn(i, {
                        shape: a
                    }, c, t) : i = nb[u.type](l, t, n, a, r, c, !0), l.setItemGraphicEl(t, i), s.add(i), 
                    Es(i, l, t, n, a, o, r, "polar" === u.type);
                } else s.remove(i);
            }).remove(function(t) {
                var e = h.getItemGraphicEl(t);
                "cartesian2d" === u.type ? e && Ns(t, c, e) : e && Os(t, c, e);
            }).execute(), this._data = l;
        },
        remove: function(e, t) {
            var i = this.group, n = this._data;
            e.get("animation") ? n && n.eachItemGraphicEl(function(t) {
                "sector" === t.type ? Os(t.dataIndex, e, t) : Ns(t.dataIndex, e, t);
            }) : i.removeAll();
        }
    });
    var nb = {
        cartesian2d: function(t, e, i, n, a, o, r) {
            var s = new Wv({
                shape: P({}, n)
            });
            if (o) {
                var l = a ? "height" : "width", h = {};
                s.shape[l] = 0, h[l] = n[l], iy[r ? "updateProps" : "initProps"](s, {
                    shape: h
                }, o, e);
            }
            return s;
        },
        polar: function(t, e, i, n, a, o, r) {
            var s = n.startAngle < n.endAngle, l = new zv({
                shape: E({
                    clockwise: s
                }, n)
            });
            if (o) {
                var h = a ? "r" : "endAngle", u = {};
                l.shape[h] = a ? 0 : n.startAngle, u[h] = n[h], iy[r ? "updateProps" : "initProps"](l, {
                    shape: u
                }, o, e);
            }
            return l;
        }
    }, ab = {
        cartesian2d: function(t, e, i) {
            var n, a, o = t.getItemLayout(e), r = (n = o, a = i.get(ib) || 0, Math.min(a, Math.abs(n.width), Math.abs(n.height))), s = 0 < o.width ? 1 : -1, l = 0 < o.height ? 1 : -1;
            return {
                x: o.x + s * r / 2,
                y: o.y + l * r / 2,
                width: o.width - s * r,
                height: o.height - l * r
            };
        },
        polar: function(t, e, i) {
            var n = t.getItemLayout(e);
            return {
                cx: n.cx,
                cy: n.cy,
                r0: n.r0,
                r: n.r,
                startAngle: n.startAngle,
                endAngle: n.endAngle
            };
        }
    };
    Zo(z(Dr, "bar")), Uo(function(t) {
        t.eachSeriesByType("bar", function(t) {
            t.getData().setVisual("legendSymbol", "roundRect");
        });
    });
    var ob = function(t, e, i) {
        e = N(e) && {
            coordDimensions: e
        } || P({}, e);
        var n = t.getSource(), a = b_(n, e), o = new x_(a, t);
        return o.initData(n, i), o;
    }, rb = {
        updateSelectedMap: function(t) {
            this._targetList = N(t) ? t.slice() : [], this._selectTargetMap = p(t || [], function(t, e) {
                return t.set(e.name, e), t;
            }, W());
        },
        select: function(t, e) {
            var i = null != e ? this._targetList[e] : this._selectTargetMap.get(t);
            "single" === this.get("selectedMode") && this._selectTargetMap.each(function(t) {
                t.selected = !1;
            }), i && (i.selected = !0);
        },
        unSelect: function(t, e) {
            var i = null != e ? this._targetList[e] : this._selectTargetMap.get(t);
            i && (i.selected = !1);
        },
        toggleSelected: function(t, e) {
            var i = null != e ? this._targetList[e] : this._selectTargetMap.get(t);
            if (null != i) return this[i.selected ? "unSelect" : "select"](t, e), i.selected;
        },
        isSelected: function(t, e) {
            var i = null != e ? this._targetList[e] : this._selectTargetMap.get(t);
            return i && i.selected;
        }
    }, sb = Ko({
        type: "series.pie",
        init: function(t) {
            sb.superApply(this, "init", arguments), this.legendDataProvider = function() {
                return this.getRawData();
            }, this.updateSelectedMap(this._createSelectableList()), this._defaultLabelLine(t);
        },
        mergeOption: function(t) {
            sb.superCall(this, "mergeOption", t), this.updateSelectedMap(this._createSelectableList());
        },
        getInitialData: function(t, e) {
            return ob(this, [ "value" ]);
        },
        _createSelectableList: function() {
            for (var t = this.getRawData(), e = t.mapDimension("value"), i = [], n = 0, a = t.count(); n < a; n++) i.push({
                name: t.getName(n),
                value: t.get(e, n),
                selected: Za(t, n, "selected")
            });
            return i;
        },
        getDataParams: function(t) {
            var e = this.getData(), i = sb.superCall(this, "getDataParams", t), n = [];
            return e.each(e.mapDimension("value"), function(t) {
                n.push(t);
            }), i.percent = Hn(n, t, e.hostModel.get("percentPrecision")), i.$vars.push("percent"), 
            i;
        },
        _defaultLabelLine: function(t) {
            ti(t, "labelLine", [ "show" ]);
            var e = t.labelLine, i = t.emphasis.labelLine;
            e.show = e.show && t.label.show, i.show = i.show && t.emphasis.label.show;
        },
        defaultOption: {
            zlevel: 0,
            z: 2,
            legendHoverLink: !0,
            hoverAnimation: !0,
            center: [ "50%", "50%" ],
            radius: [ 0, "75%" ],
            clockwise: !0,
            startAngle: 90,
            minAngle: 0,
            selectedOffset: 10,
            hoverOffset: 10,
            avoidLabelOverlap: !0,
            percentPrecision: 2,
            stillShowZeroSum: !0,
            label: {
                rotate: !1,
                show: !0,
                position: "outer"
            },
            labelLine: {
                show: !0,
                length: 15,
                length2: 15,
                smooth: !1,
                lineStyle: {
                    width: 1,
                    type: "solid"
                }
            },
            itemStyle: {
                borderWidth: 1
            },
            animationType: "expansion",
            animationEasing: "cubicOut"
        }
    });
    a(sb, rb);
    var lb = Bs.prototype;
    lb.updateData = function(t, e, i) {
        function n() {
            o.stopAnimation(!0), o.animateTo({
                shape: {
                    r: l.r + r.get("hoverOffset")
                }
            }, 300, "elasticOut");
        }
        function a() {
            o.stopAnimation(!0), o.animateTo({
                shape: {
                    r: l.r
                }
            }, 300, "elasticOut");
        }
        var o = this.childAt(0), r = t.hostModel, s = t.getItemModel(e), l = t.getItemLayout(e), h = P({}, l);
        h.label = null, i ? (o.setShape(h), "scale" === r.getShallow("animationType") ? (o.shape.r = l.r0, 
        In(o, {
            shape: {
                r: l.r
            }
        }, r, e)) : (o.shape.endAngle = l.startAngle, Mn(o, {
            shape: {
                endAngle: l.endAngle
            }
        }, r, e))) : Mn(o, {
            shape: h
        }, r, e);
        var u = t.getItemVisual(e, "color");
        o.useStyle(E({
            lineJoin: "bevel",
            fill: u
        }, s.getModel("itemStyle").getItemStyle())), o.hoverStyle = s.getModel("emphasis.itemStyle").getItemStyle();
        var c = s.getShallow("cursor");
        c && o.attr("cursor", c), zs(this, t.getItemLayout(e), r.isSelected(null, e), r.get("selectedOffset"), r.get("animation")), 
        o.off("mouseover").off("mouseout").off("emphasis").off("normal"), s.get("hoverAnimation") && r.isAnimationEnabled() && o.on("mouseover", n).on("mouseout", a).on("emphasis", n).on("normal", a), 
        this._updateLabel(t, e), gn(this);
    }, lb._updateLabel = function(t, e) {
        var i = this.childAt(1), n = this.childAt(2), a = t.hostModel, o = t.getItemModel(e), r = t.getItemLayout(e).label, s = t.getItemVisual(e, "color");
        Mn(i, {
            shape: {
                points: r.linePoints || [ [ r.x, r.y ], [ r.x, r.y ], [ r.x, r.y ] ]
            }
        }, a, e), Mn(n, {
            style: {
                x: r.x,
                y: r.y
            }
        }, a, e), n.attr({
            rotation: r.rotation,
            origin: [ r.x, r.y ],
            z2: 10
        });
        var l = o.getModel("label"), h = o.getModel("emphasis.label"), u = o.getModel("labelLine"), c = o.getModel("emphasis.labelLine");
        s = t.getItemVisual(e, "color");
        mn(n.style, n.hoverStyle = {}, l, h, {
            labelFetcher: t.hostModel,
            labelDataIndex: e,
            defaultText: t.getName(e),
            autoColor: s,
            useInsideStyle: !!r.inside
        }, {
            textAlign: r.textAlign,
            textVerticalAlign: r.verticalAlign,
            opacity: t.getItemVisual(e, "opacity")
        }), n.ignore = n.normalIgnore = !l.get("show"), n.hoverIgnore = !h.get("show"), 
        i.ignore = i.normalIgnore = !u.get("show"), i.hoverIgnore = !c.get("show"), i.setStyle({
            stroke: s,
            opacity: t.getItemVisual(e, "opacity")
        }), i.setStyle(u.getModel("lineStyle").getLineStyle()), i.hoverStyle = c.getModel("lineStyle").getLineStyle();
        var d = u.get("smooth");
        d && !0 === d && (d = .4), i.setShape({
            smooth: d
        });
    }, o(Bs, Dg), to.extend({
        type: "pie",
        init: function() {
            var t = new Dg();
            this._sectorGroup = t;
        },
        render: function(t, e, i, n) {
            if (!n || n.from !== this.uid) {
                var a = t.getData(), o = this._data, r = this.group, s = e.get("animation"), l = !o, h = t.get("animationType"), u = z(Rs, this.uid, t, s, i), c = t.get("selectedMode");
                if (a.diff(o).add(function(t) {
                    var e = new Bs(a, t);
                    l && "scale" !== h && e.eachChild(function(t) {
                        t.stopAnimation(!0);
                    }), c && e.on("click", u), a.setItemGraphicEl(t, e), r.add(e);
                }).update(function(t, e) {
                    var i = o.getItemGraphicEl(e);
                    i.updateData(a, t), i.off("click"), c && i.on("click", u), r.add(i), a.setItemGraphicEl(t, i);
                }).remove(function(t) {
                    var e = o.getItemGraphicEl(t);
                    r.remove(e);
                }).execute(), s && l && 0 < a.count() && "scale" !== h) {
                    var d = a.getItemLayout(0), f = Math.max(i.getWidth(), i.getHeight()) / 2, p = _(r.removeClipPath, r);
                    r.setClipPath(this._createClipPath(d.cx, d.cy, f, d.startAngle, d.clockwise, p, t));
                }
                this._data = a;
            }
        },
        dispose: function() {},
        _createClipPath: function(t, e, i, n, a, o, r) {
            var s = new zv({
                shape: {
                    cx: t,
                    cy: e,
                    r0: 0,
                    r: i,
                    startAngle: n,
                    endAngle: n,
                    clockwise: a
                }
            });
            return In(s, {
                shape: {
                    endAngle: n + (a ? 1 : -1) * Math.PI * 2
                }
            }, r, o), s;
        },
        containPoint: function(t, e) {
            var i = e.getData().getItemLayout(0);
            if (i) {
                var n = t[0] - i.cx, a = t[1] - i.cy, o = Math.sqrt(n * n + a * a);
                return o <= i.r && o >= i.r0;
            }
        }
    });
    var hb = function(i, t) {
        R(t, function(o) {
            o.update = "updateView", Fo(o, function(t, e) {
                var a = {};
                return e.eachComponent({
                    mainType: "series",
                    subType: i,
                    query: t
                }, function(i) {
                    i[o.method] && i[o.method](t.name, t.dataIndex);
                    var n = i.getData();
                    n.each(function(t) {
                        var e = n.getName(t);
                        a[e] = i.isSelected(e) || !1;
                    });
                }), {
                    name: t.name,
                    selected: a
                };
            });
        });
    }, ub = function(n) {
        return {
            getTargetSeries: function(t) {
                var e = {}, i = W();
                return t.eachSeriesByType(n, function(t) {
                    t.__paletteScope = e, i.set(t.uid, t);
                }), i;
            },
            reset: function(a, t) {
                var o = a.getRawData(), r = {}, s = a.getData();
                s.each(function(t) {
                    var e = s.getRawIndex(t);
                    r[e] = t;
                }), o.each(function(t) {
                    var e = r[t], i = null != e && s.getItemVisual(e, "color", !0);
                    if (i) o.setItemVisual(t, "color", i); else {
                        var n = o.getItemModel(t).get("itemStyle.color") || a.getColorFromPalette(o.getName(t) || t + "", a.__paletteScope, o.count());
                        o.setItemVisual(t, "color", n), null != e && s.setItemVisual(e, "color", n);
                    }
                });
            }
        };
    }, cb = function(M, I, t, e) {
        var T, D, A = M.getData(), C = [], L = !1;
        A.each(function(t) {
            var e, i, n, a, o = A.getItemLayout(t), r = A.getItemModel(t), s = r.getModel("label"), l = s.get("position") || r.get("emphasis.label.position"), h = r.getModel("labelLine"), u = h.get("length"), c = h.get("length2"), d = (o.startAngle + o.endAngle) / 2, f = Math.cos(d), p = Math.sin(d);
            T = o.cx, D = o.cy;
            var g = "inside" === l || "inner" === l;
            if ("center" === l) e = o.cx, i = o.cy, a = "center"; else {
                var m = (g ? (o.r + o.r0) / 2 * f : o.r * f) + T, v = (g ? (o.r + o.r0) / 2 * p : o.r * p) + D;
                if (e = m + 3 * f, i = v + 3 * p, !g) {
                    var y = m + f * (u + I - o.r), x = v + p * (u + I - o.r), _ = y + (f < 0 ? -1 : 1) * c;
                    e = _ + (f < 0 ? -5 : 5), n = [ [ m, v ], [ y, x ], [ _, i = x ] ];
                }
                a = g ? "center" : 0 < f ? "left" : "right";
            }
            var w = s.getFont(), b = s.get("rotate") ? f < 0 ? -d + Math.PI : -d : 0, S = le(M.getFormattedLabel(t, "normal") || A.getName(t), w, a, "top");
            L = !!b, o.label = {
                x: e,
                y: i,
                position: l,
                height: S.height,
                len: u,
                len2: c,
                linePoints: n,
                textAlign: a,
                verticalAlign: "middle",
                rotation: b,
                inside: g
            }, g || C.push(o.label);
        }), !L && M.get("avoidLabelOverlap") && function(t, e, i, n, a, o) {
            for (var r = [], s = [], l = 0; l < t.length; l++) t[l].x < e ? r.push(t[l]) : s.push(t[l]);
            for (Vs(s, e, i, n, 1, 0, o), Vs(r, e, i, n, -1, 0, o), l = 0; l < t.length; l++) {
                var h = t[l].linePoints;
                if (h) {
                    var u = h[1][0] - h[2][0];
                    t[l].x < e ? h[2][0] = t[l].x + 3 : h[2][0] = t[l].x - 3, h[1][1] = h[2][1] = t[l].y, 
                    h[1][0] = h[2][0] + u;
                }
            }
        }(C, T, D, I, 0, e);
    }, db = 2 * Math.PI, fb = Math.PI / 180, pb = function(t) {
        return {
            seriesType: t,
            reset: function(t, e) {
                var n = e.findComponents({
                    mainType: "legend"
                });
                if (n && n.length) {
                    var a = t.getData();
                    a.filterSelf(function(t) {
                        for (var e = a.getName(t), i = 0; i < n.length; i++) if (!n[i].isSelected(e)) return !1;
                        return !0;
                    });
                }
            }
        };
    };
    hb("pie", [ {
        type: "pieToggleSelect",
        event: "pieselectchanged",
        method: "toggleSelected"
    }, {
        type: "pieSelect",
        event: "pieselected",
        method: "select"
    }, {
        type: "pieUnSelect",
        event: "pieunselected",
        method: "unSelect"
    } ]), Uo(ub("pie")), Zo(z(function(t, e, T, i) {
        e.eachSeriesByType(t, function(t) {
            var a = t.getData(), e = a.mapDimension("value"), i = t.get("center"), n = t.get("radius");
            N(n) || (n = [ 0, n ]), N(i) || (i = [ i, i ]);
            var o = T.getWidth(), r = T.getHeight(), s = Math.min(o, r), l = zn(i[0], o), h = zn(i[1], r), u = zn(n[0], s / 2), c = zn(n[1], s / 2), d = -t.get("startAngle") * fb, f = t.get("minAngle") * fb, p = 0;
            a.each(e, function(t) {
                !isNaN(t) && p++;
            });
            var g = a.getSum(e), m = Math.PI / (g || p) * 2, v = t.get("clockwise"), y = t.get("roseType"), x = t.get("stillShowZeroSum"), _ = a.getDataExtent(e);
            _[0] = 0;
            var w = db, b = 0, S = d, M = v ? 1 : -1;
            if (a.each(e, function(t, e) {
                var i;
                if (isNaN(t)) a.setItemLayout(e, {
                    angle: NaN,
                    startAngle: NaN,
                    endAngle: NaN,
                    clockwise: v,
                    cx: l,
                    cy: h,
                    r0: u,
                    r: y ? NaN : c
                }); else {
                    (i = "area" !== y ? 0 === g && x ? m : t * m : db / p) < f ? w -= i = f : b += t;
                    var n = S + M * i;
                    a.setItemLayout(e, {
                        angle: i,
                        startAngle: S,
                        endAngle: n,
                        clockwise: v,
                        cx: l,
                        cy: h,
                        r0: u,
                        r: y ? Rn(t, _, [ u, c ]) : c
                    }), S = n;
                }
            }), w < db && p) if (w <= .001) {
                var I = db / p;
                a.each(e, function(t, e) {
                    if (!isNaN(t)) {
                        var i = a.getItemLayout(e);
                        i.angle = I, i.startAngle = d + M * e * I, i.endAngle = d + M * (e + 1) * I;
                    }
                });
            } else m = w / b, S = d, a.each(e, function(t, e) {
                if (!isNaN(t)) {
                    var i = a.getItemLayout(e), n = i.angle === f ? f : t * m;
                    i.startAngle = S, i.endAngle = S + M * n, S += M * n;
                }
            });
            cb(t, c, 0, r);
        });
    }, "pie")), Wo(pb("pie")), px.extend({
        type: "series.scatter",
        dependencies: [ "grid", "polar", "geo", "singleAxis", "calendar" ],
        getInitialData: function(t, e) {
            return gr(this.getSource(), this);
        },
        brushSelector: "point",
        getProgressive: function() {
            var t = this.option.progressive;
            return null == t ? this.option.large ? 5e3 : this.get("progressive") : t;
        },
        getProgressiveThreshold: function() {
            var t = this.option.progressiveThreshold;
            return null == t ? this.option.large ? 1e4 : this.get("progressiveThreshold") : t;
        },
        defaultOption: {
            coordinateSystem: "cartesian2d",
            zlevel: 0,
            z: 2,
            legendHoverLink: !0,
            hoverAnimation: !0,
            symbolSize: 10,
            large: !1,
            largeThreshold: 2e3,
            itemStyle: {
                opacity: .8
            },
            progressive: null
        }
    });
    var gb = Yi({
        shape: {
            points: null
        },
        symbolProxy: null,
        buildPath: function(t, e) {
            var i = e.points, n = e.size, a = this.symbolProxy, o = a.shape;
            if (!((t.getContext ? t.getContext() : t) && n[0] < 4)) for (var r = 0; r < i.length; ) {
                var s = i[r++], l = i[r++];
                isNaN(s) || isNaN(l) || (o.x = s - n[0] / 2, o.y = l - n[1] / 2, o.width = n[0], 
                o.height = n[1], a.buildPath(t, o, !0));
            }
        },
        afterBrush: function(t) {
            var e = this.shape, i = e.points, n = e.size;
            if (n[0] < 4) {
                this.setTransform(t);
                for (var a = 0; a < i.length; ) {
                    var o = i[a++], r = i[a++];
                    isNaN(o) || isNaN(r) || t.fillRect(o - n[0] / 2, r - n[1] / 2, n[0], n[1]);
                }
                this.restoreTransform(t);
            }
        },
        findDataIndex: function(t, e) {
            for (var i = this.shape, n = i.points, a = i.size, o = Math.max(a[0], 4), r = Math.max(a[1], 4), s = n.length / 2 - 1; 0 <= s; s--) {
                var l = 2 * s, h = n[l] - o / 2, u = n[l + 1] - r / 2;
                if (h <= t && u <= e && t <= h + o && e <= u + r) return s;
            }
            return -1;
        }
    }), mb = Gs.prototype;
    mb.isPersistent = function() {
        return !this._incremental;
    }, mb.updateData = function(t) {
        this.group.removeAll();
        var e = new gb({
            rectHover: !0,
            cursor: "default"
        });
        e.setShape({
            points: t.getLayout("symbolPoints")
        }), this._setCommon(e, t), this.group.add(e), this._incremental = null;
    }, mb.updateLayout = function(t) {
        if (!this._incremental) {
            var n = t.getLayout("symbolPoints");
            this.group.eachChild(function(t) {
                if (null != t.startIndex) {
                    var e = 2 * (t.endIndex - t.startIndex), i = 4 * t.startIndex * 2;
                    n = new Float32Array(n.buffer, i, e);
                }
                t.setShape("points", n);
            });
        }
    }, mb.incrementalPrepareUpdate = function(t) {
        this.group.removeAll(), this._clearIncremental(), 2e6 < t.count() ? (this._incremental || (this._incremental = new Xi({
            silent: !0
        })), this.group.add(this._incremental)) : this._incremental = null;
    }, mb.incrementalUpdate = function(t, e) {
        var i;
        this._incremental ? (i = new gb(), this._incremental.addDisplayable(i, !0)) : ((i = new gb({
            rectHover: !0,
            cursor: "default",
            startIndex: t.start,
            endIndex: t.end
        })).incremental = !0, this.group.add(i)), i.setShape({
            points: e.getLayout("symbolPoints")
        }), this._setCommon(i, e, !!this._incremental);
    }, mb._setCommon = function(i, t, e) {
        var n = t.hostModel, a = t.getVisual("symbolSize");
        i.setShape("size", a instanceof Array ? a : [ a, a ]), i.symbolProxy = Rr(t.getVisual("symbol"), 0, 0, 0, 0), 
        i.setColor = i.symbolProxy.setColor;
        var o = i.shape.size[0] < 4;
        i.useStyle(n.getModel("itemStyle").getItemStyle(o ? [ "color", "shadowBlur", "shadowColor" ] : [ "color" ]));
        var r = t.getVisual("color");
        r && i.setColor(r), e || (i.seriesIndex = n.seriesIndex, i.on("mousemove", function(t) {
            i.dataIndex = null;
            var e = i.findDataIndex(t.offsetX, t.offsetY);
            0 <= e && (i.dataIndex = e + (i.startIndex || 0));
        }));
    }, mb.remove = function() {
        this._clearIncremental(), this._incremental = null, this.group.removeAll();
    }, mb._clearIncremental = function() {
        var t = this._incremental;
        t && t.clearDisplaybles();
    }, $o({
        type: "scatter",
        render: function(t, e, i) {
            var n = t.getData();
            this._updateSymbolDraw(n, t).updateData(n), this._finished = !0;
        },
        incrementalPrepareRender: function(t, e, i) {
            var n = t.getData();
            this._updateSymbolDraw(n, t).incrementalPrepareUpdate(n), this._finished = !1;
        },
        incrementalRender: function(t, e, i) {
            this._symbolDraw.incrementalUpdate(t, e.getData()), this._finished = t.end === e.getData().count();
        },
        updateTransform: function(t, e, i) {
            var n = t.getData();
            if (this.group.dirty(), !this._finished || 1e4 < n.count() || !this._symbolDraw.isPersistent()) return {
                update: !0
            };
            var a = Sw().reset(t);
            a.progress && a.progress({
                start: 0,
                end: n.count()
            }, n), this._symbolDraw.updateLayout(n);
        },
        _updateSymbolDraw: function(t, e) {
            var i = this._symbolDraw, n = e.pipelineContext.large;
            return i && n === this._isLargeDraw || (i && i.remove(), i = this._symbolDraw = n ? new Gs() : new jr(), 
            this._isLargeDraw = n, this.group.removeAll()), this.group.add(i.group), i;
        },
        remove: function(t, e) {
            this._symbolDraw && this._symbolDraw.remove(!0), this._symbolDraw = null;
        },
        dispose: function() {}
    }), Uo(bw("scatter", "circle")), Zo(Sw("scatter")), o(Ws, aw), Fs.prototype.getIndicatorAxes = function() {
        return this._indicatorAxes;
    }, Fs.prototype.dataToPoint = function(t, e) {
        var i = this._indicatorAxes[e];
        return this.coordToPoint(i.dataToCoord(t), e);
    }, Fs.prototype.coordToPoint = function(t, e) {
        var i = this._indicatorAxes[e].angle;
        return [ this.cx + t * Math.cos(i), this.cy - t * Math.sin(i) ];
    }, Fs.prototype.pointToData = function(t) {
        var e = t[0] - this.cx, i = t[1] - this.cy, n = Math.sqrt(e * e + i * i);
        e /= n, i /= n;
        for (var a, o = Math.atan2(-i, e), r = 1 / 0, s = -1, l = 0; l < this._indicatorAxes.length; l++) {
            var h = this._indicatorAxes[l], u = Math.abs(o - h.angle);
            u < r && (a = h, s = l, r = u);
        }
        return [ s, +(a && a.coodToData(n)) ];
    }, Fs.prototype.resize = function(t, e) {
        var i = t.get("center"), n = e.getWidth(), a = e.getHeight(), o = Math.min(n, a) / 2;
        this.cx = zn(i[0], n), this.cy = zn(i[1], a), this.startAngle = t.get("startAngle") * Math.PI / 180, 
        this.r = zn(t.get("radius"), o), R(this._indicatorAxes, function(t, e) {
            t.setExtent(0, this.r);
            var i = this.startAngle + e * Math.PI * 2 / this._indicatorAxes.length;
            i = Math.atan2(Math.sin(i), Math.cos(i)), t.angle = i;
        }, this);
    }, Fs.prototype.update = function(n, t) {
        function d(t) {
            var e = Math.pow(10, Math.floor(Math.log(t) / Math.LN10)), i = t / e;
            return 2 === i ? i = 5 : i *= 2, i * e;
        }
        var a = this._indicatorAxes, o = this._model;
        R(a, function(t) {
            t.scale.setExtent(1 / 0, -1 / 0);
        }), n.eachSeriesByType("radar", function(t, e) {
            if ("radar" === t.get("coordinateSystem") && n.getComponent("radar", t.get("radarIndex")) === o) {
                var i = t.getData();
                R(a, function(t) {
                    t.scale.unionExtentFromData(i, i.mapDimension(t.dim));
                });
            }
        }, this);
        var f = o.get("splitNumber");
        R(a, function(t, e) {
            var i = Cr(t.scale, t.model);
            Lr(t.scale, t.model);
            var n = t.model, a = t.scale, o = n.getMin(), r = n.getMax(), s = a.getInterval();
            if (null != o && null != r) a.setExtent(+o, +r), a.setInterval((r - o) / f); else if (null != o) for (var l; l = o + s * f, 
            a.setExtent(+o, l), a.setInterval(s), s = d(s), l < i[1] && isFinite(l) && isFinite(i[1]); ) ; else if (null != r) for (var h; h = r - s * f, 
            a.setExtent(h, +r), a.setInterval(s), s = d(s), h > i[0] && isFinite(h) && isFinite(i[0]); ) ; else {
                a.getTicks().length - 1 > f && (s = d(s));
                var u = Math.round((i[0] + i[1]) / 2 / s) * s, c = Math.round(f / 2);
                a.setExtent(Bn(u - c * s), Bn(u + (f - c) * s)), a.setInterval(s);
            }
        });
    }, Fs.dimensions = [], Fs.create = function(i, n) {
        var a = [];
        return i.eachComponent("radar", function(t) {
            var e = new Fs(t, i, n);
            a.push(e), t.coordinateSystem = e;
        }), i.eachSeriesByType("radar", function(t) {
            "radar" === t.get("coordinateSystem") && (t.coordinateSystem = a[t.get("radarIndex") || 0]);
        }), a;
    }, Ma.register("radar", Fs);
    var vb = Cw.valueAxis, yb = (Yo({
        type: "radar",
        optionUpdated: function() {
            var a = this.get("boundaryGap"), o = this.get("splitNumber"), r = this.get("scale"), s = this.get("axisLine"), l = this.get("axisTick"), h = this.get("axisLabel"), u = this.get("name"), c = this.get("name.show"), d = this.get("name.formatter"), f = this.get("nameGap"), p = this.get("triggerEvent"), t = L(this.get("indicator") || [], function(t) {
                null != t.max && 0 < t.max && !t.min ? t.min = 0 : null != t.min && t.min < 0 && !t.max && (t.max = 0);
                var e = u;
                if (null != t.color && (e = E({
                    color: t.color
                }, u)), t = g(A(t), {
                    boundaryGap: a,
                    splitNumber: o,
                    scale: r,
                    axisLine: s,
                    axisTick: l,
                    axisLabel: h,
                    name: t.text,
                    nameLocation: "end",
                    nameGap: f,
                    nameTextStyle: e,
                    triggerEvent: p
                }, !1), c || (t.name = ""), "string" == typeof d) {
                    var i = t.name;
                    t.name = d.replace("{value}", null != i ? i : "");
                } else "function" == typeof d && (t.name = d(t.name, t));
                var n = P(new Pn(t, null, this.ecModel), Z_);
                return n.mainType = "radar", n.componentIndex = this.componentIndex, n;
            }, this);
            this.getIndicatorModels = function() {
                return t;
            };
        },
        defaultOption: {
            zlevel: 0,
            z: 0,
            center: [ "50%", "50%" ],
            radius: "75%",
            startAngle: 90,
            name: {
                show: !0
            },
            boundaryGap: [ 0, 0 ],
            splitNumber: 5,
            nameGap: 15,
            scale: !1,
            shape: "polygon",
            axisLine: g({
                lineStyle: {
                    color: "#bbb"
                }
            }, vb.axisLine),
            axisLabel: Hs(vb.axisLabel, !1),
            axisTick: Hs(vb.axisTick, !1),
            splitLine: Hs(vb.splitLine, !0),
            splitArea: Hs(vb.splitArea, !0),
            indicator: []
        }
    }), [ "axisLine", "axisTickLabel", "axisName" ]);
    qo({
        type: "radar",
        render: function(t, e, i) {
            this.group.removeAll(), this._buildAxes(t), this._buildSplitLineAndArea(t);
        },
        _buildAxes: function(t) {
            var e = t.coordinateSystem;
            R(L(e.getIndicatorAxes(), function(t) {
                return new Gw(t.model, {
                    position: [ e.cx, e.cy ],
                    rotation: t.angle,
                    labelDirection: -1,
                    tickDirection: -1,
                    nameDirection: 1
                });
            }), function(t) {
                R(yb, t.add, t), this.group.add(t.getGroup());
            }, this);
        },
        _buildSplitLineAndArea: function(t) {
            function e(t, e, i) {
                var n = i % e.length;
                return t[n] = t[n] || [], n;
            }
            var n = t.coordinateSystem, i = n.getIndicatorAxes();
            if (i.length) {
                var a = t.get("shape"), o = t.getModel("splitLine"), r = t.getModel("splitArea"), s = o.getModel("lineStyle"), l = r.getModel("areaStyle"), h = o.get("show"), u = r.get("show"), c = s.get("color"), d = l.get("color");
                c = N(c) ? c : [ c ], d = N(d) ? d : [ d ];
                var f = [], p = [];
                if ("circle" === a) for (var g = i[0].getTicksCoords(), m = n.cx, v = n.cy, y = 0; y < g.length; y++) h && f[M = e(f, c, y)].push(new Ov({
                    shape: {
                        cx: m,
                        cy: v,
                        r: g[y]
                    }
                })), u && y < g.length - 1 && p[M = e(p, d, y)].push(new Bv({
                    shape: {
                        cx: m,
                        cy: v,
                        r0: g[y],
                        r: g[y + 1]
                    }
                })); else {
                    var x, _ = L(i, function(t, e) {
                        var i = t.getTicksCoords();
                        return x = null == x ? i.length - 1 : Math.min(i.length - 1, x), L(i, function(t) {
                            return n.coordToPoint(t, e);
                        });
                    }), w = [];
                    for (y = 0; y <= x; y++) {
                        for (var b = [], S = 0; S < i.length; S++) b.push(_[S][y]);
                        if (b[0] && b.push(b[0].slice()), h && f[M = e(f, c, y)].push(new Gv({
                            shape: {
                                points: b
                            }
                        })), u && w) {
                            var M = e(p, d, y - 1);
                            p[M].push(new Vv({
                                shape: {
                                    points: b.concat(w)
                                }
                            }));
                        }
                        w = b.slice().reverse();
                    }
                }
                var I = s.getLineStyle(), T = l.getAreaStyle();
                R(p, function(t, e) {
                    this.group.add(ey(t, {
                        style: E({
                            stroke: "none",
                            fill: d[e % d.length]
                        }, T),
                        silent: !0
                    }));
                }, this), R(f, function(t, e) {
                    this.group.add(ey(t, {
                        style: E({
                            fill: "none",
                            stroke: c[e % c.length]
                        }, I),
                        silent: !0
                    }));
                }, this);
            }
        }
    });
    var xb = px.extend({
        type: "series.radar",
        dependencies: [ "radar" ],
        init: function(t) {
            xb.superApply(this, "init", arguments), this.legendDataProvider = function() {
                return this.getRawData();
            };
        },
        getInitialData: function(t, e) {
            return ob(this, {
                generateCoord: "indicator_",
                generateCoordCount: 1 / 0
            });
        },
        formatTooltip: function(n) {
            var a = this.getData(), t = this.coordinateSystem.getIndicatorAxes(), e = this.getData().getName(n);
            return ta("" === e ? this.name : e) + "<br/>" + L(t, function(t, e) {
                var i = a.get(a.mapDimension(t.dim), n);
                return ta(t.name + " : " + i);
            }).join("<br />");
        },
        defaultOption: {
            zlevel: 0,
            z: 2,
            coordinateSystem: "radar",
            legendHoverLink: !0,
            radarIndex: 0,
            lineStyle: {
                width: 2,
                type: "solid"
            },
            label: {
                position: "top"
            },
            symbol: "emptyCircle",
            symbolSize: 4
        }
    });
    $o({
        type: "radar",
        render: function(l, t, e) {
            function h(t, e) {
                var i, n = t.getItemVisual(e, "symbol") || "circle", a = t.getItemVisual(e, "color");
                if ("none" !== n) {
                    var o = (N(i = t.getItemVisual(e, "symbolSize")) || (i = [ +i, +i ]), i), r = Rr(n, -1, -1, 2, 2, a);
                    return r.attr({
                        style: {
                            strokeNoScale: !0
                        },
                        z2: 100,
                        scale: [ o[0] / 2, o[1] / 2 ]
                    }), r;
                }
            }
            function s(t, e, i, n, a, o) {
                i.removeAll();
                for (var r = 0; r < e.length - 1; r++) {
                    var s = h(n, a);
                    s && (t[s.__dimIdx = r] ? (s.attr("position", t[r]), iy[o ? "initProps" : "updateProps"](s, {
                        position: e[r]
                    }, l, a)) : s.attr("position", e[r]), i.add(s));
                }
            }
            function u(t) {
                return L(t, function(t) {
                    return [ i.cx, i.cy ];
                });
            }
            var i = l.coordinateSystem, v = this.group, y = l.getData(), c = this._data;
            y.diff(c).add(function(t) {
                var e = y.getItemLayout(t);
                if (e) {
                    var i = new Vv(), n = new Gv(), a = {
                        shape: {
                            points: e
                        }
                    };
                    i.shape.points = u(e), n.shape.points = u(e), In(i, a, l, t), In(n, a, l, t);
                    var o = new Dg(), r = new Dg();
                    o.add(n), o.add(i), o.add(r), s(n.shape.points, e, r, y, t, !0), y.setItemGraphicEl(t, o);
                }
            }).update(function(t, e) {
                var i = c.getItemGraphicEl(e), n = i.childAt(0), a = i.childAt(1), o = i.childAt(2), r = {
                    shape: {
                        points: y.getItemLayout(t)
                    }
                };
                r.shape.points && (s(n.shape.points, r.shape.points, o, y, t, !1), Mn(n, r, l), 
                Mn(a, r, l), y.setItemGraphicEl(t, i));
            }).remove(function(t) {
                v.remove(c.getItemGraphicEl(t));
            }).execute(), y.eachItemGraphicEl(function(t, e) {
                function i() {
                    r.attr("ignore", d);
                }
                function n() {
                    r.attr("ignore", c);
                }
                var a = y.getItemModel(e), o = t.childAt(0), r = t.childAt(1), s = t.childAt(2), l = y.getItemVisual(e, "color");
                v.add(t), o.useStyle(E(a.getModel("lineStyle").getLineStyle(), {
                    fill: "none",
                    stroke: l
                })), o.hoverStyle = a.getModel("emphasis.lineStyle").getLineStyle();
                var h = a.getModel("areaStyle"), u = a.getModel("emphasis.areaStyle"), c = h.isEmpty() && h.parentModel.isEmpty(), d = u.isEmpty() && u.parentModel.isEmpty();
                d = d && c, r.ignore = c, r.useStyle(E(h.getAreaStyle(), {
                    fill: l,
                    opacity: .7
                })), r.hoverStyle = u.getAreaStyle();
                var f = a.getModel("itemStyle").getItemStyle([ "color" ]), p = a.getModel("emphasis.itemStyle").getItemStyle(), g = a.getModel("label"), m = a.getModel("emphasis.label");
                s.eachChild(function(t) {
                    t.setStyle(f), t.hoverStyle = A(p), mn(t.style, t.hoverStyle, g, m, {
                        labelFetcher: y.hostModel,
                        labelDataIndex: e,
                        labelDimIndex: t.__dimIdx,
                        defaultText: y.get(y.dimensions[t.__dimIdx], e),
                        autoColor: l,
                        isRectText: !0
                    });
                }), t.off("mouseover").off("mouseout").off("normal").off("emphasis"), t.on("emphasis", i).on("mouseover", i).on("normal", n).on("mouseout", n), 
                gn(t);
            }), this._data = y;
        },
        remove: function() {
            this.group.removeAll(), this._data = null;
        },
        dispose: function() {}
    }), Uo(ub("radar")), Uo(bw("radar", "circle")), Zo(function(t) {
        t.eachSeriesByType("radar", function(t) {
            var e = t.getData(), i = [], n = t.coordinateSystem;
            if (n) {
                for (var a = n.getIndicatorAxes(), o = 0; o < n.getIndicatorAxes().length; o++) e.each(e.mapDimension(a[o].dim), function(t, e) {
                    i[e] = i[e] || [], i[e][o] = n.dataToPoint(t, o);
                });
                e.each(function(t) {
                    i[t][0] && i[t].push(i[t][0].slice()), e.setItemLayout(t, i[t]);
                });
            }
        });
    }), Wo(pb("radar")), Go(function(i) {
        var t = i.polar;
        if (t) {
            N(t) || (t = [ t ]);
            var n = [];
            R(t, function(t, e) {
                t.indicator ? (t.type && !t.shape && (t.shape = t.type), i.radar = i.radar || [], 
                N(i.radar) || (i.radar = [ i.radar ]), i.radar.push(t)) : n.push(t);
            }), i.polar = n;
        }
        R(i.series, function(t) {
            t && "radar" === t.type && t.polarIndex && (t.radarIndex = t.polarIndex);
        });
    });
    var _b = Q;
    a(Zs, Jp), Us.prototype = {
        constructor: Us,
        type: "view",
        dimensions: [ "x", "y" ],
        setBoundingRect: function(t, e, i, n) {
            return this._rect = new Xt(t, e, i, n), this._rect;
        },
        getBoundingRect: function() {
            return this._rect;
        },
        setViewRect: function(t, e, i, n) {
            this.transformTo(t, e, i, n), this._viewRect = new Xt(t, e, i, n);
        },
        transformTo: function(t, e, i, n) {
            var a = this.getBoundingRect(), o = this._rawTransformable;
            o.transform = a.calculateTransform(new Xt(t, e, i, n)), o.decomposeTransform(), 
            this._updateTransform();
        },
        setCenter: function(t) {
            t && (this._center = t, this._updateCenterAndZoom());
        },
        setZoom: function(t) {
            t = t || 1;
            var e = this.zoomLimit;
            e && (null != e.max && (t = Math.min(e.max, t)), null != e.min && (t = Math.max(e.min, t))), 
            this._zoom = t, this._updateCenterAndZoom();
        },
        getDefaultCenter: function() {
            var t = this.getBoundingRect();
            return [ t.x + t.width / 2, t.y + t.height / 2 ];
        },
        getCenter: function() {
            return this._center || this.getDefaultCenter();
        },
        getZoom: function() {
            return this._zoom || 1;
        },
        getRoamTransform: function() {
            return this._roamTransformable.getLocalTransform();
        },
        _updateCenterAndZoom: function() {
            var t = this._rawTransformable.getLocalTransform(), e = this._roamTransformable, i = this.getDefaultCenter(), n = this.getCenter(), a = this.getZoom();
            n = Q([], n, t), i = Q([], i, t), e.origin = n, e.position = [ i[0] - n[0], i[1] - n[1] ], 
            e.scale = [ a, a ], this._updateTransform();
        },
        _updateTransform: function() {
            var t = this._roamTransformable, e = this._rawTransformable;
            (e.parent = t).updateTransform(), e.updateTransform(), lt(this.transform || (this.transform = []), e.transform || rt()), 
            this._rawTransform = e.getLocalTransform(), this.invTransform = this.invTransform || [], 
            ft(this.invTransform, this.transform), this.decomposeTransform();
        },
        getViewRect: function() {
            return this._viewRect;
        },
        getViewRectAfterRoam: function() {
            var t = this.getBoundingRect().clone();
            return t.applyTransform(this.transform), t;
        },
        dataToPoint: function(t, e, i) {
            var n = e ? this._rawTransform : this.transform;
            return i = i || [], n ? _b(i, t, n) : T(i, t);
        },
        pointToData: function(t) {
            var e = this.invTransform;
            return e ? _b([], t, e) : [ t[0], t[1] ];
        },
        convertToPixel: z(js, "dataToPoint"),
        convertFromPixel: z(js, "pointToData"),
        containPoint: function(t) {
            return this.getViewRectAfterRoam().contain(t[0], t[1]);
        }
    }, a(Us, Jp);
    for (var wb = [ 126, 25 ], bb = [ [ [ 0, 3.5 ], [ 7, 11.2 ], [ 15, 11.9 ], [ 30, 7 ], [ 42, .7 ], [ 52, .7 ], [ 56, 7.7 ], [ 59, .7 ], [ 64, .7 ], [ 64, 0 ], [ 5, 0 ], [ 0, 3.5 ] ], [ [ 13, 16.1 ], [ 19, 14.7 ], [ 16, 21.7 ], [ 11, 23.1 ], [ 13, 16.1 ] ], [ [ 12, 32.2 ], [ 14, 38.5 ], [ 15, 38.5 ], [ 13, 32.2 ], [ 12, 32.2 ] ], [ [ 16, 47.6 ], [ 12, 53.2 ], [ 13, 53.2 ], [ 18, 47.6 ], [ 16, 47.6 ] ], [ [ 6, 64.4 ], [ 8, 70 ], [ 9, 70 ], [ 8, 64.4 ], [ 6, 64.4 ] ], [ [ 23, 82.6 ], [ 29, 79.8 ], [ 30, 79.8 ], [ 25, 82.6 ], [ 23, 82.6 ] ], [ [ 37, 70.7 ], [ 43, 62.3 ], [ 44, 62.3 ], [ 39, 70.7 ], [ 37, 70.7 ] ], [ [ 48, 51.1 ], [ 51, 45.5 ], [ 53, 45.5 ], [ 50, 51.1 ], [ 48, 51.1 ] ], [ [ 51, 35 ], [ 51, 28.7 ], [ 53, 28.7 ], [ 53, 35 ], [ 51, 35 ] ], [ [ 52, 22.4 ], [ 55, 17.5 ], [ 56, 17.5 ], [ 53, 22.4 ], [ 52, 22.4 ] ], [ [ 58, 12.6 ], [ 62, 7 ], [ 63, 7 ], [ 60, 12.6 ], [ 58, 12.6 ] ], [ [ 0, 3.5 ], [ 0, 93.1 ], [ 64, 93.1 ], [ 64, 0 ], [ 63, 0 ], [ 63, 92.4 ], [ 1, 92.4 ], [ 1, 3.5 ], [ 0, 3.5 ] ] ], Sb = 0; Sb < bb.length; Sb++) for (var Mb = 0; Mb < bb[Sb].length; Mb++) bb[Sb][Mb][0] /= 10.5, 
    bb[Sb][Mb][1] /= -14, bb[Sb][Mb][0] += wb[0], bb[Sb][Mb][1] += wb[1];
    var Ib = {
        "南海诸岛": [ 32, 80 ],
        "广东": [ 0, -10 ],
        "香港": [ 10, 5 ],
        "澳门": [ -10, 10 ],
        "天津": [ 5, 5 ]
    }, Tb = {
        Russia: [ 100, 60 ],
        "United States": [ -99, 38 ],
        "United States of America": [ -99, 38 ]
    }, Db = [ [ [ 123.45165252685547, 25.73527164402261 ], [ 123.49731445312499, 25.73527164402261 ], [ 123.49731445312499, 25.750734064600884 ], [ 123.45165252685547, 25.750734064600884 ], [ 123.45165252685547, 25.73527164402261 ] ] ], Ab = [ function(t) {
        "china" === t.map && t.regions.push(new Vr("南海诸岛", L(bb, function(t) {
            return {
                type: "polygon",
                exterior: t
            };
        }), wb));
    }, function(t) {
        R(t.regions, function(t) {
            var e = Ib[t.name];
            if (e) {
                var i = t.center;
                i[0] += e[0] / 10.5, i[1] += -e[1] / 14;
            }
        });
    }, function(t) {
        R(t.regions, function(t) {
            var e = Tb[t.name];
            if (e) {
                var i = t.center;
                i[0] = e[0], i[1] = e[1];
            }
        });
    }, function(t) {
        if ("china" === t.map) for (var e = 0, i = t.regions.length; e < i; ++e) "台湾" === t.regions[e].name && t.regions[e].geometries.push({
            type: "polygon",
            exterior: Db[0]
        });
    } ];
    Xs.prototype = {
        constructor: Xs,
        type: "geo",
        dimensions: [ "lng", "lat" ],
        containCoord: function(t) {
            for (var e = this.regions, i = 0; i < e.length; i++) if (e[i].contain(t)) return !0;
            return !1;
        },
        loadGeoJson: function(t, e, i) {
            try {
                this.regions = t ? ew(t) : [];
            } catch (t) {
                throw "Invalid geoJson format\n" + t.message;
            }
            e = e || {}, i = i || {};
            for (var n = this.regions, a = W(), o = 0; o < n.length; o++) {
                var r = n[o].name;
                r = i.hasOwnProperty(r) ? i[r] : r, n[o].name = r, a.set(r, n[o]), this.addGeoCoord(r, n[o].center);
                var s = e[r];
                s && n[o].transformTo(s.left, s.top, s.width, s.height);
            }
            this._regionsMap = a, this._rect = null, R(Ab, function(t) {
                t(this);
            }, this);
        },
        transformTo: function(t, e, i, n) {
            var a = this.getBoundingRect();
            (a = a.clone()).y = -a.y - a.height;
            var o = this._rawTransformable;
            o.transform = a.calculateTransform(new Xt(t, e, i, n)), o.decomposeTransform();
            var r = o.scale;
            r[1] = -r[1], o.updateTransform(), this._updateTransform();
        },
        getRegion: function(t) {
            return this._regionsMap.get(t);
        },
        getRegionByCoord: function(t) {
            for (var e = this.regions, i = 0; i < e.length; i++) if (e[i].contain(t)) return e[i];
        },
        addGeoCoord: function(t, e) {
            this._nameCoordMap.set(t, e);
        },
        getGeoCoord: function(t) {
            return this._nameCoordMap.get(t);
        },
        getBoundingRect: function() {
            if (this._rect) return this._rect;
            for (var t, e = this.regions, i = 0; i < e.length; i++) {
                var n = e[i].getBoundingRect();
                (t = t || n.clone()).union(n);
            }
            return this._rect = t || new Xt(0, 0, 0, 0);
        },
        dataToPoint: function(t, e, i) {
            if ("string" == typeof t && (t = this.getGeoCoord(t)), t) return Us.prototype.dataToPoint.call(this, t, e, i);
        },
        convertToPixel: z(Ys, "dataToPoint"),
        convertFromPixel: z(Ys, "pointToData")
    }, a(Xs, Us);
    var Cb = {
        dimensions: Xs.prototype.dimensions,
        create: function(t, o) {
            var r = [];
            t.eachComponent("geo", function(t, e) {
                var i = t.get("map"), n = Jo(i), a = new Xs(i + e, i, n && n.geoJson, n && n.specialAreas, t.get("nameMap"));
                a.zoomLimit = t.get("scaleLimit"), r.push(a), Ks(a, t), (t.coordinateSystem = a).model = t, 
                a.resize = qs, a.resize(t, o);
            }), t.eachSeries(function(t) {
                if ("geo" === t.get("coordinateSystem")) {
                    var e = t.get("geoIndex") || 0;
                    t.coordinateSystem = r[e];
                }
            });
            var i = {};
            return t.eachSeriesByType("map", function(t) {
                if (!t.getHostGeoModel()) {
                    var e = t.getMapType();
                    i[e] = i[e] || [], i[e].push(t);
                }
            }), R(i, function(t, e) {
                var i = Jo(e), n = L(t, function(t) {
                    return t.get("nameMap");
                }), a = new Xs(e, e, i && i.geoJson, i && i.specialAreas, u(n));
                a.zoomLimit = V.apply(null, L(t, function(t) {
                    return t.get("scaleLimit");
                })), r.push(a), a.resize = qs, a.resize(t[0], o), R(t, function(t) {
                    Ks(t.coordinateSystem = a, t);
                });
            }), r;
        },
        getFilledRegions: function(t, e, i) {
            var n = (t || []).slice();
            i = i || {};
            var a = Jo(e), o = a && a.geoJson;
            if (!o) return t;
            for (var r = W(), s = o.features, l = 0; l < n.length; l++) r.set(n[l].name, n[l]);
            for (l = 0; l < s.length; l++) {
                var h = s[l].properties.name;
                r.get(h) || (i.hasOwnProperty(h) && (h = i[h]), n.push({
                    name: h
                }));
            }
            return n;
        }
    };
    Ho("geo", Cb);
    var Lb = px.extend({
        type: "series.map",
        dependencies: [ "geo" ],
        layoutMode: "box",
        needsDrawMap: !1,
        seriesGroup: [],
        init: function(t) {
            Lb.superApply(this, "init", arguments), this.updateSelectedMap(this._createSelectableList());
        },
        getInitialData: function(t) {
            return ob(this, [ "value" ]);
        },
        mergeOption: function(t) {
            Lb.superApply(this, "mergeOption", arguments), this.updateSelectedMap(this._createSelectableList());
        },
        _createSelectableList: function() {
            for (var t = this.getRawData(), e = t.mapDimension("value"), i = [], n = 0, a = t.count(); n < a; n++) i.push({
                name: t.getName(n),
                value: t.get(e, n),
                selected: Za(t, n, "selected")
            });
            return Cb.getFilledRegions(i, this.getMapType(), this.option.nameMap);
        },
        getHostGeoModel: function() {
            var t = this.option.geoIndex;
            return null != t ? this.dependentModels.geo[t] : null;
        },
        getMapType: function() {
            return (this.getHostGeoModel() || this).option.map;
        },
        _fillOption: function(t, e) {},
        getRawValue: function(t) {
            var e = this.getData();
            return e.get(e.mapDimension("value"), t);
        },
        getRegionModel: function(t) {
            var e = this.getData();
            return e.getItemModel(e.indexOfName(t));
        },
        formatTooltip: function(t) {
            for (var e = this.getData(), i = Jn(this.getRawValue(t)), n = e.getName(t), a = this.seriesGroup, o = [], r = 0; r < a.length; r++) {
                var s = a[r].originalData.indexOfName(n), l = e.mapDimension("value");
                isNaN(a[r].originalData.get(l, s)) || o.push(ta(a[r].name));
            }
            return o.join(", ") + "<br />" + ta(n + " : " + i);
        },
        getTooltipPosition: function(t) {
            if (null != t) {
                var e = this.getData().getName(t), i = this.coordinateSystem, n = i.getRegion(e);
                return n && i.dataToPoint(n.center);
            }
        },
        setZoom: function(t) {
            this.option.zoom = t;
        },
        setCenter: function(t) {
            this.option.center = t;
        },
        defaultOption: {
            zlevel: 0,
            z: 2,
            coordinateSystem: "geo",
            map: "",
            left: "center",
            top: "center",
            aspectScale: .75,
            showLegendSymbol: !0,
            dataRangeHoverLink: !0,
            boundingCoords: null,
            center: null,
            zoom: 1,
            scaleLimit: null,
            label: {
                show: !1,
                color: "#000"
            },
            itemStyle: {
                borderWidth: .5,
                borderColor: "#444",
                areaColor: "#eee"
            },
            emphasis: {
                label: {
                    show: !0,
                    color: "rgb(100,0,0)"
                },
                itemStyle: {
                    areaColor: "rgba(255,215,0,0.8)"
                }
            }
        }
    });
    a(Lb, rb);
    var kb = "\0_ec_interaction_mutex";
    Fo({
        type: "takeGlobalCursor",
        event: "globalCursorTaken",
        update: "update"
    }, function() {}), a(Qs, Up);
    var Pb = {
        axisPointer: 1,
        tooltip: 1,
        brush: 1
    };
    dl.prototype = {
        constructor: dl,
        draw: function(x, t, e, i, n) {
            var _ = "geo" === x.mainType, w = x.getData && x.getData();
            _ && t.eachComponent({
                mainType: "series",
                subType: "map"
            }, function(t) {
                w || t.getHostGeoModel() !== x || (w = t.getData());
            });
            var a = x.coordinateSystem, b = this.group, S = a.scale, o = {
                position: a.position,
                scale: S
            };
            !b.childAt(0) || n ? b.attr(o) : Mn(b, o, x), b.removeAll();
            var r, s, l, h, u, M = [ "itemStyle" ], I = [ "emphasis", "itemStyle" ], T = [ "label" ], D = [ "emphasis", "label" ], A = W();
            R(a.regions, function(t) {
                var e = A.get(t.name) || A.set(t.name, new Dg()), i = new jv({
                    shape: {
                        paths: []
                    }
                });
                e.add(i);
                var n, a = (y = x.getRegionModel(t.name) || x).getModel(M), o = y.getModel(I), r = ul(a), s = ul(o), l = y.getModel(T), h = y.getModel(D);
                if (w) {
                    n = w.indexOfName(t.name);
                    var u = w.getItemVisual(n, "color", !0);
                    u && (r.fill = u);
                }
                R(t.geometries, function(t) {
                    if ("polygon" === t.type) {
                        i.shape.paths.push(new Vv({
                            shape: {
                                points: t.exterior
                            }
                        }));
                        for (var e = 0; e < (t.interiors ? t.interiors.length : 0); e++) i.shape.paths.push(new Vv({
                            shape: {
                                points: t.interiors[e]
                            }
                        }));
                    }
                }), i.setStyle(r), i.style.strokeNoScale = !0, i.culling = !0;
                var c = l.get("show"), d = h.get("show"), f = w && isNaN(w.get(w.mapDimension("value"), n)), p = w && w.getItemLayout(n);
                if (_ || f && (c || d) || p && p.showLabel) {
                    var g, m = _ ? t.name : n;
                    (!w || 0 <= n) && (g = x);
                    var v = new Nv({
                        position: t.center.slice(),
                        scale: [ 1 / S[0], 1 / S[1] ],
                        z2: 10,
                        silent: !0
                    });
                    mn(v.style, v.hoverStyle = {}, l, h, {
                        labelFetcher: g,
                        labelDataIndex: m,
                        defaultText: t.name,
                        useInsideStyle: !1
                    }, {
                        textAlign: "center",
                        textVerticalAlign: "middle"
                    }), e.add(v);
                }
                if (w) w.setItemGraphicEl(n, e); else {
                    var y = x.getRegionModel(t.name);
                    i.eventData = {
                        componentType: "geo",
                        geoIndex: x.componentIndex,
                        name: t.name,
                        region: y && y.option || {}
                    };
                }
                (e.__regions || (e.__regions = [])).push(t), gn(e, s, {
                    hoverSilentOnTouch: !!x.get("selectedMode")
                }), b.add(e);
            }), this._updateController(x, t, e), r = this, s = x, h = e, u = i, (l = b).off("click"), 
            l.off("mousedown"), s.get("selectedMode") && (l.on("mousedown", function() {
                r._mouseDownFlag = !0;
            }), l.on("click", function(t) {
                if (r._mouseDownFlag) {
                    r._mouseDownFlag = !1;
                    for (var e = t.target; !e.__regions; ) e = e.parent;
                    if (e) {
                        var i = {
                            type: ("geo" === s.mainType ? "geo" : "map") + "ToggleSelect",
                            batch: L(e.__regions, function(t) {
                                return {
                                    name: t.name,
                                    from: u.uid
                                };
                            })
                        };
                        i[s.mainType + "Id"] = s.id, h.dispatchAction(i), cl(s, l);
                    }
                }
            })), cl(x, b);
        },
        remove: function() {
            this.group.removeAll(), this._controller.dispose(), this._controllerHost = {};
        },
        _updateController: function(n, t, o) {
            function r() {
                var t = {
                    type: "geoRoam",
                    componentType: i
                };
                return t[i + "Id"] = n.id, t;
            }
            var a = n.coordinateSystem, e = this._controller, s = this._controllerHost;
            s.zoomLimit = n.get("scaleLimit"), s.zoom = a.getZoom(), e.enable(n.get("roam") || !1);
            var i = n.mainType;
            e.off("pan").on("pan", function(t, e) {
                this._mouseDownFlag = !1, sl(s, t, e), o.dispatchAction(P(r(), {
                    dx: t,
                    dy: e
                }));
            }, this), e.off("zoom").on("zoom", function(t, e, i) {
                if (this._mouseDownFlag = !1, ll(s, t, e, i), o.dispatchAction(P(r(), {
                    zoom: t,
                    originX: e,
                    originY: i
                })), this._updateGroup) {
                    var n = this.group, a = n.scale;
                    n.traverse(function(t) {
                        "text" === t.type && t.attr("scale", [ 1 / a[0], 1 / a[1] ]);
                    });
                }
            }, this), e.setPointerChecker(function(t, e, i) {
                return a.getViewRectAfterRoam().contain(e, i) && !hl(t, o, n);
            });
        }
    }, $o({
        type: "map",
        render: function(t, e, i, n) {
            if (!n || "mapToggleSelect" !== n.type || n.from !== this.uid) {
                var a = this.group;
                if (a.removeAll(), !t.getHostGeoModel()) {
                    if (n && "geoRoam" === n.type && "series" === n.componentType && n.seriesId === t.id) (o = this._mapDraw) && a.add(o.group); else if (t.needsDrawMap) {
                        var o = this._mapDraw || new dl(i, !0);
                        a.add(o.group), o.draw(t, e, i, this, n), this._mapDraw = o;
                    } else this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
                    t.get("showLegendSymbol") && e.getComponent("legend") && this._renderSymbols(t, e, i);
                }
            }
        },
        remove: function() {
            this._mapDraw && this._mapDraw.remove(), this._mapDraw = null, this.group.removeAll();
        },
        dispose: function() {
            this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
        },
        _renderSymbols: function(v, t, e) {
            var y = v.originalData, x = this.group;
            y.each(y.mapDimension("value"), function(t, e) {
                if (!isNaN(t)) {
                    var i = y.getItemLayout(e);
                    if (i && i.point) {
                        var n = i.point, a = i.offset, o = new Ov({
                            style: {
                                fill: v.getData().getVisual("color")
                            },
                            shape: {
                                cx: n[0] + 9 * a,
                                cy: n[1],
                                r: 3
                            },
                            silent: !0,
                            z2: a ? 8 : 10
                        });
                        if (!a) {
                            var r = v.mainSeries.getData(), s = y.getName(e), l = r.indexOfName(s), h = y.getItemModel(e), u = h.getModel("label"), c = h.getModel("emphasis.label"), d = r.getItemGraphicEl(l), f = k(v.getFormattedLabel(e, "normal"), s), p = k(v.getFormattedLabel(e, "emphasis"), f), g = function() {
                                var t = vn({}, c, {
                                    text: c.get("show") ? p : null
                                }, {
                                    isRectText: !0,
                                    useInsideStyle: !1
                                }, !0);
                                o.style.extendFrom(t), o.__mapOriginalZ2 = o.z2, o.z2 += 1;
                            }, m = function() {
                                vn(o.style, u, {
                                    text: u.get("show") ? f : null,
                                    textPosition: u.getShallow("position") || "bottom"
                                }, {
                                    isRectText: !0,
                                    useInsideStyle: !1
                                }), null != o.__mapOriginalZ2 && (o.z2 = o.__mapOriginalZ2, o.__mapOriginalZ2 = null);
                            };
                            d.on("mouseover", g).on("mouseout", m).on("emphasis", g).on("normal", m), m();
                        }
                        x.add(o);
                    }
                }
            });
        }
    }), Fo({
        type: "geoRoam",
        event: "geoRoam",
        update: "updateTransform"
    }, function(n, t) {
        var a = n.componentType || "series";
        t.eachComponent({
            mainType: a,
            query: n
        }, function(t) {
            var e = t.coordinateSystem;
            if ("geo" === e.type) {
                var i = fl(e, n, t.get("scaleLimit"));
                t.setCenter && t.setCenter(i.center), t.setZoom && t.setZoom(i.zoom), "series" === a && R(t.seriesGroup, function(t) {
                    t.setCenter(i.center), t.setZoom(i.zoom);
                });
            }
        });
    }), Zo(function(i) {
        var a = {};
        i.eachSeriesByType("map", function(t) {
            var e = t.getMapType();
            if (!t.getHostGeoModel() && !a[e]) {
                var l = {};
                R(t.seriesGroup, function(t) {
                    var r = t.coordinateSystem, s = t.originalData;
                    t.get("showLegendSymbol") && i.getComponent("legend") && s.each(s.mapDimension("value"), function(t, e) {
                        var i = s.getName(e), n = r.getRegion(i);
                        if (n && !isNaN(t)) {
                            var a = l[i] || 0, o = r.dataToPoint(n.center);
                            l[i] = a + 1, s.setItemLayout(e, {
                                point: o,
                                offset: a
                            });
                        }
                    });
                });
                var n = t.getData();
                n.each(function(t) {
                    var e = n.getName(t), i = n.getItemLayout(t) || {};
                    i.showLabel = !l[e], n.setItemLayout(t, i);
                }), a[e] = !0;
            }
        });
    }), Uo(function(t) {
        t.eachSeriesByType("map", function(t) {
            var e = t.get("color"), i = t.getModel("itemStyle"), n = i.get("areaColor"), a = i.get("color") || e[t.seriesIndex % e.length];
            t.getData().setVisual({
                areaColor: n,
                color: a
            });
        });
    }), Wo(Zx.PROCESSOR.STATISTIC, function(t) {
        var n = {};
        t.eachSeriesByType("map", function(t) {
            var e = t.getHostGeoModel(), i = e ? "o" + e.id : "i" + t.getMapType();
            (n[i] = n[i] || []).push(t);
        }), R(n, function(t, e) {
            for (var i = function(l, h) {
                var u = {};
                return R(l, function(n) {
                    n.each(n.mapDimension("value"), function(t, e) {
                        var i = "ec-" + n.getName(e);
                        u[i] = u[i] || [], isNaN(t) || u[i].push(t);
                    });
                }), l[0].map(l[0].mapDimension("value"), function(t, e) {
                    for (var i = "ec-" + l[0].getName(e), n = 0, a = 1 / 0, o = -1 / 0, r = u[i].length, s = 0; s < r; s++) a = Math.min(a, u[i][s]), 
                    o = Math.max(o, u[i][s]), n += u[i][s];
                    return 0 === r ? NaN : "min" === h ? a : "max" === h ? o : "average" === h ? n / r : n;
                });
            }(L(t, function(t) {
                return t.getData();
            }), t[0].get("mapValueCalculation")), n = 0; n < t.length; n++) t[n].originalData = t[n].getData();
            for (n = 0; n < t.length; n++) (t[n].seriesGroup = t)[n].needsDrawMap = 0 === n && !t[n].getHostGeoModel(), 
            t[n].setData(i.cloneShallow()), t[n].mainSeries = t[0];
        });
    }), Go(function(t) {
        var e = [];
        R(t.series, function(t) {
            t && "map" === t.type && (e.push(t), t.map = t.map || t.mapType, E(t, t.mapLocation));
        });
    }), hb("map", [ {
        type: "mapToggleSelect",
        event: "mapselectchanged",
        method: "toggleSelected"
    }, {
        type: "mapSelect",
        event: "mapselected",
        method: "select"
    }, {
        type: "mapUnSelect",
        event: "mapunselected",
        method: "unSelect"
    } ]);
    var Nb = R, Ob = "\0__link_datas", Eb = "\0__link_mainData", Rb = function(t, e) {
        this.name = t || "", this.depth = 0, this.height = 0, this.parentNode = null, this.dataIndex = -1, 
        this.children = [], this.viewChildren = [], this.hostTree = e;
    };
    Rb.prototype = {
        constructor: Rb,
        isRemoved: function() {
            return this.dataIndex < 0;
        },
        eachNode: function(t, e, i) {
            "function" == typeof t && (i = e, e = t, t = null), b(t = t || {}) && (t = {
                order: t
            });
            var n, a = t.order || "preorder", o = this[t.attr || "children"];
            "preorder" === a && (n = e.call(i, this));
            for (var r = 0; !n && r < o.length; r++) o[r].eachNode(t, e, i);
            "postorder" === a && e.call(i, this);
        },
        updateDepthAndHeight: function(t) {
            var e = 0;
            this.depth = t;
            for (var i = 0; i < this.children.length; i++) {
                var n = this.children[i];
                n.updateDepthAndHeight(t + 1), n.height > e && (e = n.height);
            }
            this.height = e + 1;
        },
        getNodeById: function(t) {
            if (this.getId() === t) return this;
            for (var e = 0, i = this.children, n = i.length; e < n; e++) {
                var a = i[e].getNodeById(t);
                if (a) return a;
            }
        },
        contains: function(t) {
            if (t === this) return !0;
            for (var e = 0, i = this.children, n = i.length; e < n; e++) {
                var a = i[e].contains(t);
                if (a) return a;
            }
        },
        getAncestors: function(t) {
            for (var e = [], i = t ? this : this.parentNode; i; ) e.push(i), i = i.parentNode;
            return e.reverse(), e;
        },
        getValue: function(t) {
            var e = this.hostTree.data;
            return e.get(e.getDimension(t || "value"), this.dataIndex);
        },
        setLayout: function(t, e) {
            0 <= this.dataIndex && this.hostTree.data.setItemLayout(this.dataIndex, t, e);
        },
        getLayout: function() {
            return this.hostTree.data.getItemLayout(this.dataIndex);
        },
        getModel: function(t) {
            if (!(this.dataIndex < 0)) {
                var e, i = this.hostTree, n = i.data.getItemModel(this.dataIndex), a = this.getLevelModel();
                return a || 0 !== this.children.length && (0 === this.children.length || !1 !== this.isExpand) || (e = this.getLeavesModel()), 
                n.getModel(t, (a || e || i.hostModel).getModel(t));
            }
        },
        getLevelModel: function() {
            return (this.hostTree.levelModels || [])[this.depth];
        },
        getLeavesModel: function() {
            return this.hostTree.leavesModel;
        },
        setVisual: function(t, e) {
            0 <= this.dataIndex && this.hostTree.data.setItemVisual(this.dataIndex, t, e);
        },
        getVisual: function(t, e) {
            return this.hostTree.data.getItemVisual(this.dataIndex, t, e);
        },
        getRawIndex: function() {
            return this.hostTree.data.getRawIndex(this.dataIndex);
        },
        getId: function() {
            return this.hostTree.data.getId(this.dataIndex);
        },
        isAncestorOf: function(t) {
            for (var e = t.parentNode; e; ) {
                if (e === this) return !0;
                e = e.parentNode;
            }
            return !1;
        },
        isDescendantOf: function(t) {
            return t !== this && t.isAncestorOf(this);
        }
    }, wl.prototype = {
        constructor: wl,
        type: "tree",
        eachNode: function(t, e, i) {
            this.root.eachNode(t, e, i);
        },
        getNodeByDataIndex: function(t) {
            var e = this.data.getRawIndex(t);
            return this._nodes[e];
        },
        getNodeByName: function(t) {
            return this.root.getNodeByName(t);
        },
        update: function() {
            for (var t = this.data, e = this._nodes, i = 0, n = e.length; i < n; i++) e[i].dataIndex = -1;
            for (i = 0, n = t.count(); i < n; i++) e[t.getRawIndex(i)].dataIndex = i;
        },
        clearLayouts: function() {
            this.data.clearItemLayouts();
        }
    }, wl.createTree = function(t, e, i) {
        var u = new wl(e, i.levels, i.leaves), c = [], d = 1;
        (function t(e, i) {
            var n = e.value;
            d = Math.max(d, N(n) ? n.length : 1), c.push(e);
            var a, o, r, s = new Rb(e.name, u);
            i ? (a = s, r = (o = i).children, a.parentNode !== o && (r.push(a), a.parentNode = o)) : u.root = s, 
            u._nodes.push(s);
            var l = e.children;
            if (l) for (var h = 0; h < l.length; h++) t(l[h], s);
        })(t), u.root.updateDepthAndHeight(0);
        var n = b_(c, {
            coordDimensions: [ "value" ],
            dimensionsCount: d
        }), a = new x_(n, e);
        return a.initData(c), pl({
            mainData: a,
            struct: u,
            structAttr: "tree"
        }), u.update(), u;
    }, px.extend({
        type: "series.tree",
        layoutInfo: null,
        layoutMode: "box",
        getInitialData: function(t) {
            var e = {
                name: t.name,
                children: t.data
            }, i = t.leaves || {}, n = {};
            n.leaves = i;
            var a = wl.createTree(e, this, n), o = 0;
            a.eachNode("preorder", function(t) {
                t.depth > o && (o = t.depth);
            });
            var r = t.expandAndCollapse && 0 <= t.initialTreeDepth ? t.initialTreeDepth : o;
            return a.root.eachNode("preorder", function(t) {
                var e = t.hostTree.data.getRawDataItem(t.dataIndex);
                t.isExpand = e && null != e.collapsed ? !e.collapsed : t.depth <= r;
            }), a.data;
        },
        getOrient: function() {
            var t = this.get("orient");
            return "horizontal" === t ? t = "LR" : "vertical" === t && (t = "TB"), t;
        },
        formatTooltip: function(t) {
            for (var e = this.getData().tree, i = e.root.children[0], n = e.getNodeByDataIndex(t), a = n.getValue(), o = n.name; n && n !== i; ) o = n.parentNode.name + "." + o, 
            n = n.parentNode;
            return ta(o + (isNaN(a) || null == a ? "" : " : " + a));
        },
        defaultOption: {
            zlevel: 0,
            z: 2,
            left: "12%",
            top: "12%",
            right: "12%",
            bottom: "12%",
            layout: "orthogonal",
            orient: "LR",
            symbol: "emptyCircle",
            symbolSize: 7,
            expandAndCollapse: !0,
            initialTreeDepth: 2,
            lineStyle: {
                color: "#ccc",
                width: 1.5,
                curveness: .5
            },
            itemStyle: {
                color: "lightsteelblue",
                borderColor: "#c23531",
                borderWidth: 1.5
            },
            label: {
                show: !0,
                color: "#555"
            },
            leaves: {
                label: {
                    show: !0
                }
            },
            animationEasing: "linear",
            animationDuration: 700,
            animationDurationUpdate: 1e3
        }
    }), $o({
        type: "tree",
        init: function(t, e) {
            this._oldTree, this._mainGroup = new Dg(), this.group.add(this._mainGroup);
        },
        render: function(n, t, i, e) {
            var a = n.getData(), o = n.layoutInfo, r = this._mainGroup, s = n.get("layout");
            "radial" === s ? r.attr("position", [ o.x + o.width / 2, o.y + o.height / 2 ]) : r.attr("position", [ o.x, o.y ]);
            var l = this._data, h = {
                expandAndCollapse: n.get("expandAndCollapse"),
                layout: s,
                orient: n.getOrient(),
                curvature: n.get("lineStyle.curveness"),
                symbolRotate: n.get("symbolRotate"),
                symbolOffset: n.get("symbolOffset"),
                hoverAnimation: n.get("hoverAnimation"),
                useNameLabel: !0,
                fadeIn: !0
            };
            a.diff(l).add(function(t) {
                Cl(a, t) && kl(a, t, null, r, n, h);
            }).update(function(t, e) {
                var i = l.getItemGraphicEl(e);
                Cl(a, t) ? kl(a, t, i, r, n, h) : i && Pl(a, t, i, r, n, h);
            }).remove(function(t) {
                var e = l.getItemGraphicEl(t);
                Pl(a, t, e, r, n, h);
            }).execute(), !0 === h.expandAndCollapse && a.eachItemGraphicEl(function(t, e) {
                t.off("click").on("click", function() {
                    i.dispatchAction({
                        type: "treeExpandAndCollapse",
                        seriesId: n.id,
                        dataIndex: e
                    });
                });
            }), this._data = a;
        },
        dispose: function() {},
        remove: function() {
            this._mainGroup.removeAll(), this._data = null;
        }
    }), Fo({
        type: "treeExpandAndCollapse",
        event: "treeExpandAndCollapse",
        update: "update"
    }, function(n, t) {
        t.eachComponent({
            mainType: "series",
            subType: "tree",
            query: n
        }, function(t) {
            var e = n.dataIndex, i = t.getData().tree.getNodeByDataIndex(e);
            i.isExpand = !i.isExpand;
        });
    });
    var zb = function(t, e) {
        var i, n = (i = e, la(t.getBoxLayoutParams(), {
            width: i.getWidth(),
            height: i.getHeight()
        }));
        t.layoutInfo = n;
        var a = t.get("layout"), o = 0, r = 0, s = null;
        "radial" === a ? (o = 2 * Math.PI, r = Math.min(n.height, n.width) / 2, s = Ml(function(t, e) {
            return (t.parentNode === e.parentNode ? 1 : 2) / t.depth;
        })) : (o = n.width, r = n.height, s = Ml());
        var l = t.getData().tree.root, h = l.children[0];
        (function(t) {
            t.hierNode = {
                defaultAncestor: null,
                ancestor: t,
                prelim: 0,
                modifier: 0,
                change: 0,
                shift: 0,
                i: 0,
                thread: null
            };
            for (var e, i, n = [ t ]; e = n.pop(); ) if (i = e.children, e.isExpand && i.length) for (var a = i.length - 1; 0 <= a; a--) {
                var o = i[a];
                o.hierNode = {
                    defaultAncestor: null,
                    ancestor: o,
                    prelim: 0,
                    modifier: 0,
                    change: 0,
                    shift: 0,
                    i: a,
                    thread: null
                }, n.push(o);
            }
        })(l), function(t, e, i) {
            for (var n, a = [ t ], o = []; n = a.pop(); ) if (o.push(n), n.isExpand) {
                var r = n.children;
                if (r.length) for (var s = 0; s < r.length; s++) a.push(r[s]);
            }
            for (;n = o.pop(); ) e(n, i);
        }(h, bl, s), l.hierNode.modifier = -h.hierNode.prelim, Ol(h, Sl);
        var u = h, c = h, d = h;
        Ol(h, function(t) {
            var e = t.getLayout().x;
            e < u.getLayout().x && (u = t), e > c.getLayout().x && (c = t), t.depth > d.depth && (d = t);
        });
        var f = u === c ? 1 : s(u, c) / 2, p = f - u.getLayout().x, g = 0, m = 0, v = 0, y = 0;
        if ("radial" === a) g = o / (c.getLayout().x + f + p), m = r / (d.depth - 1 || 1), 
        Ol(h, function(t) {
            v = (t.getLayout().x + p) * g, y = (t.depth - 1) * m;
            var e = Il(v, y);
            t.setLayout({
                x: e.x,
                y: e.y,
                rawX: v,
                rawY: y
            }, !0);
        }); else {
            var x = t.getOrient();
            "RL" === x || "LR" === x ? (m = r / (c.getLayout().x + f + p), g = o / (d.depth - 1 || 1), 
            Ol(h, function(t) {
                y = (t.getLayout().x + p) * m, v = "LR" === x ? (t.depth - 1) * g : o - (t.depth - 1) * g, 
                t.setLayout({
                    x: v,
                    y: y
                }, !0);
            })) : "TB" !== x && "BT" !== x || (g = o / (c.getLayout().x + f + p), m = r / (d.depth - 1 || 1), 
            Ol(h, function(t) {
                v = (t.getLayout().x + p) * g, y = "TB" === x ? (t.depth - 1) * m : r - (t.depth - 1) * m, 
                t.setLayout({
                    x: v,
                    y: y
                }, !0);
            }));
        }
    };
    Uo(bw("tree", "circle")), Zo(function(t, e) {
        t.eachSeriesByType("tree", function(t) {
            zb(t, e);
        });
    }), Zo(function(t, e) {
        t.eachSeriesByType("tree", function(t) {
            zb(t, e);
        });
    }), px.extend({
        type: "series.treemap",
        layoutMode: "box",
        dependencies: [ "grid", "polar" ],
        _viewRoot: null,
        defaultOption: {
            progressive: 0,
            hoverLayerThreshold: 1 / 0,
            left: "center",
            top: "middle",
            right: null,
            bottom: null,
            width: "80%",
            height: "80%",
            sort: !0,
            clipWindow: "origin",
            squareRatio: .5 * (1 + Math.sqrt(5)),
            leafDepth: null,
            drillDownIcon: "▶",
            zoomToNodeRatio: .1024,
            roam: !0,
            nodeClick: "zoomToNode",
            animation: !0,
            animationDurationUpdate: 900,
            animationEasing: "quinticInOut",
            breadcrumb: {
                show: !0,
                height: 22,
                left: "center",
                top: "bottom",
                emptyItemWidth: 25,
                itemStyle: {
                    color: "rgba(0,0,0,0.7)",
                    borderColor: "rgba(255,255,255,0.7)",
                    borderWidth: 1,
                    shadowColor: "rgba(150,150,150,1)",
                    shadowBlur: 3,
                    shadowOffsetX: 0,
                    shadowOffsetY: 0,
                    textStyle: {
                        color: "#fff"
                    }
                },
                emphasis: {
                    textStyle: {}
                }
            },
            label: {
                show: !0,
                distance: 0,
                padding: 5,
                position: "inside",
                color: "#fff",
                ellipsis: !0
            },
            upperLabel: {
                show: !1,
                position: [ 0, "50%" ],
                height: 20,
                color: "#fff",
                ellipsis: !0,
                verticalAlign: "middle"
            },
            itemStyle: {
                color: null,
                colorAlpha: null,
                colorSaturation: null,
                borderWidth: 0,
                gapWidth: 0,
                borderColor: "#fff",
                borderColorSaturation: null
            },
            emphasis: {
                upperLabel: {
                    show: !0,
                    position: [ 0, "50%" ],
                    color: "#fff",
                    ellipsis: !0,
                    verticalAlign: "middle"
                }
            },
            visualDimension: 0,
            visualMin: null,
            visualMax: null,
            color: [],
            colorAlpha: null,
            colorSaturation: null,
            colorMappingBy: "index",
            visibleMin: 10,
            childrenVisibleMin: null,
            levels: []
        },
        getInitialData: function(t, e) {
            var i = {
                name: t.name,
                children: t.data
            };
            !function i(t) {
                var n = 0;
                R(t.children, function(t) {
                    i(t);
                    var e = t.value;
                    N(e) && (e = e[0]), n += e;
                });
                var e = t.value;
                N(e) && (e = e[0]), (null == e || isNaN(e)) && (e = n), e < 0 && (e = 0), N(t.value) ? t.value[0] = e : t.value = e;
            }(i);
            var n = t.levels || [];
            n = t.levels = function(t, e) {
                var n, i = e.get("color");
                if (i) return R(t = t || [], function(t) {
                    var e = new Pn(t), i = e.get("color");
                    (e.get("itemStyle.color") || i && "none" !== i) && (n = !0);
                }), n || ((t[0] || (t[0] = {})).color = i.slice()), t;
            }(n, e);
            var a = {};
            return a.levels = n, wl.createTree(i, this, a).data;
        },
        optionUpdated: function() {
            this.resetViewRoot();
        },
        formatTooltip: function(t) {
            var e = this.getData(), i = this.getRawValue(t), n = Jn(N(i) ? i[0] : i);
            return ta(e.getName(t) + ": " + n);
        },
        getDataParams: function(t) {
            var e = px.prototype.getDataParams.apply(this, arguments), i = this.getData().tree.getNodeByDataIndex(t);
            return e.treePathInfo = Bl(i, this), e;
        },
        setLayoutInfo: function(t) {
            this.layoutInfo = this.layoutInfo || {}, P(this.layoutInfo, t);
        },
        mapIdToIndex: function(t) {
            var e = this._idIndexMap;
            e || (e = this._idIndexMap = W(), this._idIndexMapCount = 0);
            var i = e.get(t);
            return null == i && e.set(t, i = this._idIndexMapCount++), i;
        },
        getViewRoot: function() {
            return this._viewRoot;
        },
        resetViewRoot: function(t) {
            t ? this._viewRoot = t : t = this._viewRoot;
            var e = this.getRawData().tree.root;
            t && (t === e || e.contains(t)) || (this._viewRoot = e);
        }
    });
    var Bb = 5;
    Vl.prototype = {
        constructor: Vl,
        render: function(t, e, i, n) {
            var a = t.getModel("breadcrumb"), o = this.group;
            if (o.removeAll(), a.get("show") && i) {
                var r = a.getModel("itemStyle"), s = r.getModel("textStyle"), l = {
                    pos: {
                        left: a.get("left"),
                        right: a.get("right"),
                        top: a.get("top"),
                        bottom: a.get("bottom")
                    },
                    box: {
                        width: e.getWidth(),
                        height: e.getHeight()
                    },
                    emptyItemWidth: a.get("emptyItemWidth"),
                    totalWidth: 0,
                    renderList: []
                };
                this._prepare(i, l, s), this._renderContent(t, l, r, s, n), ha(o, l.pos, l.box);
            }
        },
        _prepare: function(t, e, i) {
            for (var n = t; n; n = n.parentNode) {
                var a = n.getModel().get("name"), o = i.getTextRect(a), r = Math.max(o.width + 16, e.emptyItemWidth);
                e.totalWidth += r + 8, e.renderList.push({
                    node: n,
                    text: a,
                    width: r
                });
            }
        },
        _renderContent: function(t, e, i, n, a) {
            for (var o = 0, r = e.emptyItemWidth, s = t.get("breadcrumb.height"), l = (T = e.pos, 
            D = e.box, O = N = P = k = L = C = A = void 0, C = D.width, L = D.height, k = zn(T.x, C), 
            P = zn(T.y, L), N = zn(T.x2, C), O = zn(T.y2, L), (isNaN(k) || isNaN(parseFloat(T.x))) && (k = 0), 
            (isNaN(N) || isNaN(parseFloat(T.x2))) && (N = C), (isNaN(P) || isNaN(parseFloat(T.y))) && (P = 0), 
            (isNaN(O) || isNaN(parseFloat(T.y2))) && (O = L), A = my(A || 0), {
                width: Math.max(N - k - A[1] - A[3], 0),
                height: Math.max(O - P - A[0] - A[2], 0)
            }), h = e.totalWidth, u = e.renderList, c = u.length - 1; 0 <= c; c--) {
                var d = u[c], f = d.node, p = d.width, g = d.text;
                l.width < h && (h -= p - r, p = r, g = null);
                var m = new Vv({
                    shape: {
                        points: (x = o, _ = 0, w = p, b = s, S = c === u.length - 1, M = 0 === c, I = void 0, 
                        I = [ [ S ? x : x - Bb, _ ], [ x + w, _ ], [ x + w, _ + b ], [ S ? x : x - Bb, _ + b ] ], 
                        !M && I.splice(2, 0, [ x + w + Bb, _ + b / 2 ]), !S && I.push([ x, _ + b / 2 ]), 
                        I)
                    },
                    style: E(i.getItemStyle(), {
                        lineJoin: "bevel",
                        text: g,
                        textFill: n.getTextColor(),
                        textFont: n.getFont()
                    }),
                    z: 10,
                    onclick: z(a, f)
                });
                this.group.add(m), v = t, y = f, m.eventData = {
                    componentType: "series",
                    componentSubType: "treemap",
                    seriesIndex: v.componentIndex,
                    seriesName: v.name,
                    seriesType: "treemap",
                    selfType: "breadcrumb",
                    nodeData: {
                        dataIndex: y && y.dataIndex,
                        name: y && y.name
                    },
                    treePathInfo: y && Bl(y, v)
                }, o += p + 8;
            }
            var v, y, x, _, w, b, S, M, I, T, D, A, C, L, k, P, N, O;
        },
        remove: function() {
            this.group.removeAll();
        }
    };
    var Vb = _, Gb = Dg, Wb = Wv, Fb = R, Hb = [ "label" ], Zb = [ "emphasis", "label" ], Ub = [ "upperLabel" ], jb = [ "emphasis", "upperLabel" ], Xb = 10, Yb = Dm([ [ "fill", "color" ], [ "stroke", "strokeColor" ], [ "lineWidth", "strokeWidth" ], [ "shadowBlur" ], [ "shadowOffsetX" ], [ "shadowOffsetY" ], [ "shadowColor" ] ]), qb = function(t) {
        var e = Yb(t);
        return e.stroke = e.fill = e.lineWidth = null, e;
    };
    $o({
        type: "treemap",
        init: function(t, e) {
            this._containerGroup, this._storage = {
                nodeGroup: [],
                background: [],
                content: []
            }, this._oldTree, this._breadcrumb, this._controller, this._state = "ready";
        },
        render: function(t, e, i, n) {
            if (!(C(e.findComponents({
                mainType: "series",
                subType: "treemap",
                query: n
            }), t) < 0)) {
                this.seriesModel = t, this.api = i, this.ecModel = e;
                var a = El(n, [ "treemapZoomToNode", "treemapRootToNode" ], t), o = n && n.type, r = t.layoutInfo, s = !this._oldTree, l = this._storage, h = "treemapRootToNode" === o && a && l ? {
                    rootNodeGroup: l.nodeGroup[a.node.getRawIndex()],
                    direction: n.direction
                } : null, u = this._giveContainerGroup(r), c = this._doRender(u, t, h);
                s || o && "treemapZoomToNode" !== o && "treemapRootToNode" !== o ? c.renderFinally() : this._doAnimation(u, c, t, h), 
                this._resetController(i), this._renderBreadcrumb(t, i, a);
            }
        },
        _giveContainerGroup: function(t) {
            var e = this._containerGroup;
            return e || (e = this._containerGroup = new Gb(), this._initEvents(e), this.group.add(e)), 
            e.attr("position", [ t.x, t.y ]), e;
        },
        _doRender: function(t, e, i) {
            var n = e.getData().tree, a = this._oldTree, o = {
                nodeGroup: [],
                background: [],
                content: []
            }, r = {
                nodeGroup: [],
                background: [],
                content: []
            }, s = this._storage, l = [], c = z(Gl, e, r, s, i, o, l);
            !function o(r, s, l, h, u) {
                function t(t) {
                    return t.getId();
                }
                function i(t, e) {
                    var i = null != t ? r[t] : null, n = null != e ? s[e] : null, a = c(i, n, l, u);
                    a && o(i && i.viewChildren || [], n && n.viewChildren || [], a, h, u + 1);
                }
                h ? Fb(s = r, function(t, e) {
                    !t.isRemoved() && i(e, e);
                }) : new tr(s, r, t, t).add(i).update(i).remove(z(i, null)).execute();
            }(n.root ? [ n.root ] : [], a && a.root ? [ a.root ] : [], t, n === a || !a, 0);
            var h, u = (h = {
                nodeGroup: [],
                background: [],
                content: []
            }, s && Fb(s, function(t, e) {
                var i = h[e];
                Fb(t, function(t) {
                    t && (i.push(t), t.__tmWillDelete = 1);
                });
            }), h);
            return this._oldTree = n, this._storage = r, {
                lastsForAnimation: o,
                willDeleteEls: u,
                renderFinally: function() {
                    Fb(u, function(t) {
                        Fb(t, function(t) {
                            t.parent && t.parent.remove(t);
                        });
                    }), Fb(l, function(t) {
                        t.invisible = !0, t.dirty();
                    });
                }
            };
        },
        _doAnimation: function(t, o, e, s) {
            if (e.get("animation")) {
                var l = e.get("animationDurationUpdate"), h = e.get("animationEasing"), u = (r = [], 
                c = {}, {
                    add: function(t, e, i, n, a) {
                        return b(n) && (a = n, n = 0), !c[t.id] && (c[t.id] = 1, r.push({
                            el: t,
                            target: e,
                            time: i,
                            delay: n,
                            easing: a
                        }), !0);
                    },
                    done: function(t) {
                        return a = t, this;
                    },
                    start: function() {
                        for (var t = r.length, e = 0, i = r.length; e < i; e++) {
                            var n = r[e];
                            n.el.animateTo(n.target, n.time, n.delay, n.easing, function() {
                                --t || (r.length = 0, c = {}, a && a());
                            });
                        }
                        return this;
                    }
                });
                Fb(o.willDeleteEls, function(t, r) {
                    Fb(t, function(t, e) {
                        if (!t.invisible) {
                            var i, n = t.parent;
                            if (s && "drillDown" === s.direction) i = n === s.rootNodeGroup ? {
                                shape: {
                                    x: 0,
                                    y: 0,
                                    width: n.__tmNodeWidth,
                                    height: n.__tmNodeHeight
                                },
                                style: {
                                    opacity: 0
                                }
                            } : {
                                style: {
                                    opacity: 0
                                }
                            }; else {
                                var a = 0, o = 0;
                                n.__tmWillDelete || (a = n.__tmNodeWidth / 2, o = n.__tmNodeHeight / 2), i = "nodeGroup" === r ? {
                                    position: [ a, o ],
                                    style: {
                                        opacity: 0
                                    }
                                } : {
                                    shape: {
                                        x: a,
                                        y: o,
                                        width: 0,
                                        height: 0
                                    },
                                    style: {
                                        opacity: 0
                                    }
                                };
                            }
                            i && u.add(t, i, l, h);
                        }
                    });
                }), Fb(this._storage, function(t, a) {
                    Fb(t, function(t, e) {
                        var i = o.lastsForAnimation[a][e], n = {};
                        i && ("nodeGroup" === a ? i.old && (n.position = t.position.slice(), t.attr("position", i.old)) : (i.old && (n.shape = P({}, t.shape), 
                        t.setShape(i.old)), i.fadein ? (t.setStyle("opacity", 0), n.style = {
                            opacity: 1
                        }) : 1 !== t.style.opacity && (n.style = {
                            opacity: 1
                        })), u.add(t, n, l, h));
                    });
                }, this), this._state = "animating", u.done(Vb(function() {
                    this._state = "ready", o.renderFinally();
                }, this)).start();
            }
            var a, r, c;
        },
        _resetController: function(t) {
            var e = this._controller;
            e || ((e = this._controller = new Qs(t.getZr())).enable(this.seriesModel.get("roam")), 
            e.on("pan", Vb(this._onPan, this)), e.on("zoom", Vb(this._onZoom, this)));
            var n = new Xt(0, 0, t.getWidth(), t.getHeight());
            e.setPointerChecker(function(t, e, i) {
                return n.contain(e, i);
            });
        },
        _clearController: function() {
            var t = this._controller;
            t && (t.dispose(), t = null);
        },
        _onPan: function(t, e) {
            if ("animating" !== this._state && (3 < Math.abs(t) || 3 < Math.abs(e))) {
                var i = this.seriesModel.getData().tree.root;
                if (!i) return;
                var n = i.getLayout();
                if (!n) return;
                this.api.dispatchAction({
                    type: "treemapMove",
                    from: this.uid,
                    seriesId: this.seriesModel.id,
                    rootRect: {
                        x: n.x + t,
                        y: n.y + e,
                        width: n.width,
                        height: n.height
                    }
                });
            }
        },
        _onZoom: function(t, e, i) {
            if ("animating" !== this._state) {
                var n = this.seriesModel.getData().tree.root;
                if (!n) return;
                var a = n.getLayout();
                if (!a) return;
                var o = new Xt(a.x, a.y, a.width, a.height), r = this.seriesModel.layoutInfo;
                e -= r.x, i -= r.y;
                var s = rt();
                ut(s, s, [ -e, -i ]), dt(s, s, [ t, t ]), ut(s, s, [ e, i ]), o.applyTransform(s), 
                this.api.dispatchAction({
                    type: "treemapRender",
                    from: this.uid,
                    seriesId: this.seriesModel.id,
                    rootRect: {
                        x: o.x,
                        y: o.y,
                        width: o.width,
                        height: o.height
                    }
                });
            }
        },
        _initEvents: function(t) {
            t.on("click", function(t) {
                if ("ready" === this._state) {
                    var e = this.seriesModel.get("nodeClick", !0);
                    if (e) {
                        var i = this.findTarget(t.offsetX, t.offsetY);
                        if (i) {
                            var n = i.node;
                            if (n.getLayout().isLeafRoot) this._rootToNode(i); else if ("zoomToNode" === e) this._zoomToNode(i); else if ("link" === e) {
                                var a = n.hostTree.data.getItemModel(n.dataIndex), o = a.get("link", !0), r = a.get("target", !0) || "blank";
                                o && window.open(o, r);
                            }
                        }
                    }
                }
            }, this);
        },
        _renderBreadcrumb: function(e, t, i) {
            i || (i = null != e.get("leafDepth", !0) ? {
                node: e.getViewRoot()
            } : this.findTarget(t.getWidth() / 2, t.getHeight() / 2)) || (i = {
                node: e.getData().tree.root
            }), (this._breadcrumb || (this._breadcrumb = new Vl(this.group))).render(e, t, i.node, Vb(function(t) {
                "animating" !== this._state && (zl(e.getViewRoot(), t) ? this._rootToNode({
                    node: t
                }) : this._zoomToNode({
                    node: t
                }));
            }, this));
        },
        remove: function() {
            this._clearController(), this._containerGroup && this._containerGroup.removeAll(), 
            this._storage = {
                nodeGroup: [],
                background: [],
                content: []
            }, this._state = "ready", this._breadcrumb && this._breadcrumb.remove();
        },
        dispose: function() {
            this._clearController();
        },
        _zoomToNode: function(t) {
            this.api.dispatchAction({
                type: "treemapZoomToNode",
                from: this.uid,
                seriesId: this.seriesModel.id,
                targetNode: t.node
            });
        },
        _rootToNode: function(t) {
            this.api.dispatchAction({
                type: "treemapRootToNode",
                from: this.uid,
                seriesId: this.seriesModel.id,
                targetNode: t.node
            });
        },
        findTarget: function(a, o) {
            var r;
            return this.seriesModel.getViewRoot().eachNode({
                attr: "viewChildren",
                order: "preorder"
            }, function(t) {
                var e = this._storage.background[t.getRawIndex()];
                if (e) {
                    var i = e.transformCoordToLocal(a, o), n = e.shape;
                    if (!(n.x <= i[0] && i[0] <= n.x + n.width && n.y <= i[1] && i[1] <= n.y + n.height)) return !1;
                    r = {
                        node: t,
                        offsetX: i[0],
                        offsetY: i[1]
                    };
                }
            }, this), r;
        }
    });
    for (var Kb = [ "treemapZoomToNode", "treemapRender", "treemapMove" ], $b = 0; $b < Kb.length; $b++) Fo({
        type: Kb[$b],
        update: "updateView"
    }, function() {});
    Fo({
        type: "treemapRootToNode",
        update: "updateView"
    }, function(a, t) {
        t.eachComponent({
            mainType: "series",
            subType: "treemap",
            query: a
        }, function(t, e) {
            var i = El(a, [ "treemapZoomToNode", "treemapRootToNode" ], t);
            if (i) {
                var n = t.getViewRoot();
                n && (a.direction = zl(n, i.node) ? "rollUp" : "drillDown"), t.resetViewRoot(i.node);
            }
        });
    });
    var Jb = R, Qb = B, tS = -1, eS = function(t) {
        var e = t.mappingMethod, i = t.type, n = this.option = A(t);
        this.type = i, this.mappingMethod = e, this._normalizeData = nS[e];
        var a, o, r = iS[i];
        this.applyVisual = r.applyVisual, this.getColorMapper = r.getColorMapper, this._doMap = r._doMap[e], 
        "piecewise" === e ? (Wl(n), o = (a = n).pieceList, a.hasSpecialVisual = !1, R(o, function(t, e) {
            t.originIndex = e, null != t.visual && (a.hasSpecialVisual = !0);
        })) : "category" === e ? n.categories ? function(t) {
            var e = t.categories, i = t.visual, n = t.categoryMap = {};
            if (Jb(e, function(t, e) {
                n[t] = e;
            }), !N(i)) {
                var a = [];
                B(i) ? Jb(i, function(t, e) {
                    var i = n[e];
                    a[null != i ? i : tS] = t;
                }) : a[tS] = i, i = ql(t, a);
            }
            for (var o = e.length - 1; 0 <= o; o--) null == i[o] && (delete n[e[o]], e.pop());
        }(n) : Wl(n, !0) : (c("linear" !== e || n.dataExtent), Wl(n));
    };
    eS.prototype = {
        constructor: eS,
        mapValueToVisual: function(t) {
            var e = this._normalizeData(t);
            return this._doMap(e, t);
        },
        getNormalizer: function() {
            return _(this._normalizeData, this);
        }
    };
    var iS = eS.visualHandlers = {
        color: {
            applyVisual: Zl("color"),
            getColorMapper: function() {
                var a = this.option;
                return _("category" === a.mappingMethod ? function(t, e) {
                    return !e && (t = this._normalizeData(t)), Ul.call(this, t);
                } : function(t, e, i) {
                    var n = !!i;
                    return !e && (t = this._normalizeData(t)), i = Lt(t, a.parsedVisual, i), n ? i : Ot(i, "rgba");
                }, this);
            },
            _doMap: {
                linear: function(t) {
                    return Ot(Lt(t, this.option.parsedVisual), "rgba");
                },
                category: Ul,
                piecewise: function(t, e) {
                    var i = Yl.call(this, e);
                    return null == i && (i = Ot(Lt(t, this.option.parsedVisual), "rgba")), i;
                },
                fixed: jl
            }
        },
        colorHue: Fl(function(t, e) {
            return Pt(t, e);
        }),
        colorSaturation: Fl(function(t, e) {
            return Pt(t, null, e);
        }),
        colorLightness: Fl(function(t, e) {
            return Pt(t, null, null, e);
        }),
        colorAlpha: Fl(function(t, e) {
            return Nt(t, e);
        }),
        opacity: {
            applyVisual: Zl("opacity"),
            _doMap: Xl([ 0, 1 ])
        },
        symbol: {
            applyVisual: function(t, e, i) {
                var n = this.mapValueToVisual(t);
                if (b(n)) i("symbol", n); else if (Qb(n)) for (var a in n) n.hasOwnProperty(a) && i(a, n[a]);
            },
            _doMap: {
                linear: Hl,
                category: Ul,
                piecewise: function(t, e) {
                    var i = Yl.call(this, e);
                    return null == i && (i = Hl.call(this, t)), i;
                },
                fixed: jl
            }
        },
        symbolSize: {
            applyVisual: Zl("symbolSize"),
            _doMap: Xl([ 0, 1 ])
        }
    }, nS = {
        linear: function(t) {
            return Rn(t, this.option.dataExtent, [ 0, 1 ], !0);
        },
        piecewise: function(t) {
            var e = this.option.pieceList, i = eS.findPieceIndex(t, e, !0);
            if (null != i) return Rn(i, [ 0, e.length - 1 ], [ 0, 1 ], !0);
        },
        category: function(t) {
            var e = this.option.categories ? this.option.categoryMap[t] : t;
            return null == e ? tS : e;
        },
        fixed: S
    };
    eS.listVisualTypes = function() {
        var i = [];
        return R(iS, function(t, e) {
            i.push(e);
        }), i;
    }, eS.addVisualHandler = function(t, e) {
        iS[t] = e;
    }, eS.isValidType = function(t) {
        return iS.hasOwnProperty(t);
    }, eS.eachVisual = function(t, e, i) {
        B(t) ? R(t, e, i) : e.call(i, t);
    }, eS.mapVisual = function(t, n, a) {
        var o, r = N(t) ? [] : B(t) ? {} : (o = !0, null);
        return eS.eachVisual(t, function(t, e) {
            var i = n.call(a, t, e);
            o ? r = i : r[e] = i;
        }), r;
    }, eS.retrieveVisuals = function(i) {
        var n, a = {};
        return i && Jb(iS, function(t, e) {
            i.hasOwnProperty(e) && (a[e] = i[e], n = !0);
        }), n ? a : null;
    }, eS.prepareVisualTypes = function(t) {
        if (Qb(t)) {
            var i = [];
            Jb(t, function(t, e) {
                i.push(e);
            }), t = i;
        } else {
            if (!N(t)) return [];
            t = t.slice();
        }
        return t.sort(function(t, e) {
            return "color" === e && "color" !== t && 0 === t.indexOf("color") ? 1 : -1;
        }), t;
    }, eS.dependsOn = function(t, e) {
        return "color" === e ? !(!t || 0 !== t.indexOf(e)) : t === e;
    }, eS.findPieceIndex = function(n, t, e) {
        function i(t, e) {
            var i = Math.abs(t - n);
            i < o && (o = i, a = e);
        }
        for (var a, o = 1 / 0, r = 0, s = t.length; r < s; r++) {
            var l = t[r].value;
            if (null != l) {
                if (l === n || "string" == typeof l && l === n + "") return r;
                e && i(l, r);
            }
        }
        for (r = 0, s = t.length; r < s; r++) {
            var h = t[r], u = h.interval, c = h.close;
            if (u) {
                if (u[0] === -1 / 0) {
                    if (Kl(c[1], n, u[1])) return r;
                } else if (u[1] === 1 / 0) {
                    if (Kl(c[0], u[0], n)) return r;
                } else if (Kl(c[0], u[0], n) && Kl(c[1], n, u[1])) return r;
                e && i(u[0], r), e && i(u[1], r);
            }
        }
        if (e) return n === 1 / 0 ? t.length - 1 : n === -1 / 0 ? 0 : a;
    };
    var aS = N, oS = "itemStyle", rS = {
        seriesType: "treemap",
        reset: function(t, e, i, n) {
            var a = t.getData().tree, o = a.root, r = t.getModel(oS);
            o.isRemoved() || $l(o, {}, L(a.levelModels, function(t) {
                return t ? t.get(oS) : null;
            }), r, t.getViewRoot().getAncestors(), t);
        }
    }, sS = Math.max, lS = Math.min, hS = V, uS = R, cS = [ "itemStyle", "borderWidth" ], dS = [ "itemStyle", "gapWidth" ], fS = [ "upperLabel", "show" ], pS = [ "upperLabel", "height" ], gS = {
        seriesType: "treemap",
        reset: function(t, e, i, n) {
            var a = i.getWidth(), o = i.getHeight(), r = t.option, s = la(t.getBoxLayoutParams(), {
                width: i.getWidth(),
                height: i.getHeight()
            }), l = r.size || [], h = zn(hS(s.width, l[0]), a), u = zn(hS(s.height, l[1]), o), c = n && n.type, d = El(n, [ "treemapZoomToNode", "treemapRootToNode" ], t), f = "treemapRender" === c || "treemapMove" === c ? n.rootRect : null, p = t.getViewRoot(), g = Rl(p);
            if ("treemapMove" !== c) {
                var m = "treemapZoomToNode" === c ? function(t, e, i, n, a) {
                    var o = (e || {}).node, r = [ n, a ];
                    if (!o || o === i) return r;
                    for (var s, l = n * a, h = l * t.option.zoomToNodeRatio; s = o.parentNode; ) {
                        for (var u = 0, c = s.children, d = 0, f = c.length; d < f; d++) u += c[d].getValue();
                        var p = o.getValue();
                        if (0 === p) return r;
                        h *= u / p;
                        var g = s.getModel(), m = g.get(cS);
                        (h += 4 * m * m + (3 * m + Math.max(m, ah(g))) * Math.pow(h, .5)) > fy && (h = fy), 
                        o = s;
                    }
                    h < l && (h = l);
                    var v = Math.pow(h / l, .5);
                    return [ n * v, a * v ];
                }(t, d, p, h, u) : f ? [ f.width, f.height ] : [ h, u ], v = r.sort;
                v && "asc" !== v && "desc" !== v && (v = "desc");
                var y = {
                    squareRatio: r.squareRatio,
                    sort: v,
                    leafDepth: r.leafDepth
                };
                p.hostTree.clearLayouts(), x = {
                    x: 0,
                    y: 0,
                    width: m[0],
                    height: m[1],
                    area: m[0] * m[1]
                }, p.setLayout(x), eh(p, y, !1, 0);
                var x = p.getLayout();
                uS(g, function(t, e) {
                    var i = (g[e + 1] || p).getValue();
                    t.setLayout(P({
                        dataExtent: [ i, i ],
                        borderWidth: 0,
                        upperHeight: 0
                    }, x));
                });
            }
            var _ = t.getData().tree.root;
            _.setLayout(function(t, e, i) {
                if (e) return {
                    x: e.x,
                    y: e.y
                };
                var n = {
                    x: 0,
                    y: 0
                };
                if (!i) return n;
                var a = i.node, o = a.getLayout();
                if (!o) return n;
                for (var r = [ o.width / 2, o.height / 2 ], s = a; s; ) {
                    var l = s.getLayout();
                    r[0] += l.x, r[1] += l.y, s = s.parentNode;
                }
                return {
                    x: t.width / 2 - r[0],
                    y: t.height / 2 - r[1]
                };
            }(s, f, d), !0), t.setLayoutInfo(s), function e(t, i, n, a, o) {
                var r = t.getLayout(), s = n[o], l = s && s === t;
                if (!(s && !l || o === n.length && t !== a)) {
                    t.setLayout({
                        isInView: !0,
                        invisible: !l && !i.intersect(r),
                        isAboveViewRoot: l
                    }, !0);
                    var h = new Xt(i.x - r.x, i.y - r.y, i.width, i.height);
                    uS(t.viewChildren || [], function(t) {
                        e(t, h, n, a, o + 1);
                    });
                }
            }(_, new Xt(-s.x, -s.y, a, o), g, p, 0);
        }
    };
    Uo(rS), Zo(gS);
    var mS = function(t) {
        this._directed = t || !1, this.nodes = [], this.edges = [], this._nodesMap = {}, 
        this._edgesMap = {}, this.data, this.edgeData;
    }, vS = mS.prototype;
    vS.type = "graph", vS.isDirected = function() {
        return this._directed;
    }, vS.addNode = function(t, e) {
        t = t || "" + e;
        var i = this._nodesMap;
        if (!i[oh(t)]) {
            var n = new rh(t, e);
            return (n.hostGraph = this).nodes.push(n), i[oh(t)] = n;
        }
    }, vS.getNodeByIndex = function(t) {
        var e = this.data.getRawIndex(t);
        return this.nodes[e];
    }, vS.getNodeById = function(t) {
        return this._nodesMap[oh(t)];
    }, vS.addEdge = function(t, e, i) {
        var n = this._nodesMap, a = this._edgesMap;
        if ("number" == typeof t && (t = this.nodes[t]), "number" == typeof e && (e = this.nodes[e]), 
        rh.isInstance(t) || (t = n[oh(t)]), rh.isInstance(e) || (e = n[oh(e)]), t && e) {
            var o = t.id + "-" + e.id;
            if (!a[o]) {
                var r = new sh(t, e, i);
                return (r.hostGraph = this)._directed && (t.outEdges.push(r), e.inEdges.push(r)), 
                t.edges.push(r), t !== e && e.edges.push(r), this.edges.push(r), a[o] = r;
            }
        }
    }, vS.getEdgeByIndex = function(t) {
        var e = this.edgeData.getRawIndex(t);
        return this.edges[e];
    }, vS.getEdge = function(t, e) {
        rh.isInstance(t) && (t = t.id), rh.isInstance(e) && (e = e.id);
        var i = this._edgesMap;
        return this._directed ? i[t + "-" + e] : i[t + "-" + e] || i[e + "-" + t];
    }, vS.eachNode = function(t, e) {
        for (var i = this.nodes, n = i.length, a = 0; a < n; a++) 0 <= i[a].dataIndex && t.call(e, i[a], a);
    }, vS.eachEdge = function(t, e) {
        for (var i = this.edges, n = i.length, a = 0; a < n; a++) 0 <= i[a].dataIndex && 0 <= i[a].node1.dataIndex && 0 <= i[a].node2.dataIndex && t.call(e, i[a], a);
    }, vS.breadthFirstTraverse = function(t, e, i, n) {
        if (rh.isInstance(e) || (e = this._nodesMap[oh(e)]), e) {
            for (var a = "out" === i ? "outEdges" : "in" === i ? "inEdges" : "edges", o = 0; o < this.nodes.length; o++) this.nodes[o].__visited = !1;
            if (!t.call(n, e, null)) for (var r = [ e ]; r.length; ) {
                var s = r.shift(), l = s[a];
                for (o = 0; o < l.length; o++) {
                    var h = l[o], u = h.node1 === s ? h.node2 : h.node1;
                    if (!u.__visited) {
                        if (t.call(n, u, s)) return;
                        r.push(u), u.__visited = !0;
                    }
                }
            }
        }
    }, vS.update = function() {
        for (var t = this.data, i = this.edgeData, e = this.nodes, n = this.edges, a = 0, o = e.length; a < o; a++) e[a].dataIndex = -1;
        for (a = 0, o = t.count(); a < o; a++) e[t.getRawIndex(a)].dataIndex = a;
        i.filterSelf(function(t) {
            var e = n[i.getRawIndex(t)];
            return 0 <= e.node1.dataIndex && 0 <= e.node2.dataIndex;
        });
        for (a = 0, o = n.length; a < o; a++) n[a].dataIndex = -1;
        for (a = 0, o = i.count(); a < o; a++) n[i.getRawIndex(a)].dataIndex = a;
    }, vS.clone = function() {
        for (var t = new mS(this._directed), e = this.nodes, i = this.edges, n = 0; n < e.length; n++) t.addNode(e[n].id, e[n].dataIndex);
        for (n = 0; n < i.length; n++) {
            var a = i[n];
            t.addEdge(a.node1.id, a.node2.id, a.dataIndex);
        }
        return t;
    }, rh.prototype = {
        constructor: rh,
        degree: function() {
            return this.edges.length;
        },
        inDegree: function() {
            return this.inEdges.length;
        },
        outDegree: function() {
            return this.outEdges.length;
        },
        getModel: function(t) {
            if (!(this.dataIndex < 0)) return this.hostGraph.data.getItemModel(this.dataIndex).getModel(t);
        }
    }, sh.prototype.getModel = function(t) {
        if (!(this.dataIndex < 0)) return this.hostGraph.edgeData.getItemModel(this.dataIndex).getModel(t);
    };
    var yS = function(i, n) {
        return {
            getValue: function(t) {
                var e = this[i][n];
                return e.get(e.getDimension(t || "value"), this.dataIndex);
            },
            setVisual: function(t, e) {
                0 <= this.dataIndex && this[i][n].setItemVisual(this.dataIndex, t, e);
            },
            getVisual: function(t, e) {
                return this[i][n].getItemVisual(this.dataIndex, t, e);
            },
            setLayout: function(t, e) {
                0 <= this.dataIndex && this[i][n].setItemLayout(this.dataIndex, t, e);
            },
            getLayout: function() {
                return this[i][n].getItemLayout(this.dataIndex);
            },
            getGraphicEl: function() {
                return this[i][n].getItemGraphicEl(this.dataIndex);
            },
            getRawIndex: function() {
                return this[i][n].getRawIndex(this.dataIndex);
            }
        };
    };
    a(rh, yS("hostGraph", "data")), a(sh, yS("hostGraph", "edgeData")), mS.Node = rh, 
    mS.Edge = sh, fi(rh), fi(sh);
    var xS = function(t, e, i, n, a) {
        for (var o = new mS(n), r = 0; r < t.length; r++) o.addNode(V(t[r].id, t[r].name, r), r);
        var s = [], l = [], h = 0;
        for (r = 0; r < e.length; r++) {
            var u = e[r], c = u.source, d = u.target;
            o.addEdge(c, d, h) && (l.push(u), s.push(V(u.id, c + " > " + d)), h++);
        }
        var f, p = i.get("coordinateSystem");
        if ("cartesian2d" === p || "polar" === p) f = gr(t, i); else {
            var g = Ma.get(p), m = b_(t, {
                coordDimensions: (g && "view" !== g.type && g.dimensions || []).concat([ "value" ])
            });
            (f = new x_(m, i)).initData(t);
        }
        var v = new x_([ "value" ], i);
        return v.initData(l, s), a && a(f, v), pl({
            mainData: f,
            struct: o,
            structAttr: "graph",
            datas: {
                node: f,
                edge: v
            },
            datasAttr: {
                node: "data",
                edge: "edgeData"
            }
        }), o.update(), o;
    }, _S = Ko({
        type: "series.graph",
        init: function(t) {
            _S.superApply(this, "init", arguments), this.legendDataProvider = function() {
                return this._categoriesData;
            }, this.fillDataTextStyle(t.edges || t.links), this._updateCategoriesData();
        },
        mergeOption: function(t) {
            _S.superApply(this, "mergeOption", arguments), this.fillDataTextStyle(t.edges || t.links), 
            this._updateCategoriesData();
        },
        mergeDefaultAndTheme: function(t) {
            _S.superApply(this, "mergeDefaultAndTheme", arguments), ti(t, [ "edgeLabel" ], [ "show" ]);
        },
        getInitialData: function(t, o) {
            var e = t.edges || t.links || [], i = t.data || t.nodes || [], r = this;
            if (i && e) return xS(i, e, this, !0, function(t, e) {
                function i(t) {
                    return (t = this.parsePath(t)) && "label" === t[0] ? a : this.parentModel;
                }
                t.wrapMethod("getItemModel", function(t) {
                    var e = r._categoriesModels[t.getShallow("category")];
                    return e && (e.parentModel = t.parentModel, t.parentModel = e), t;
                });
                var n = r.getModel("edgeLabel"), a = new Pn({
                    label: n.option
                }, n.parentModel, o);
                e.wrapMethod("getItemModel", function(t) {
                    return t.customizeGetParent(i), t;
                });
            }).data;
        },
        getGraph: function() {
            return this.getData().graph;
        },
        getEdgeData: function() {
            return this.getGraph().edgeData;
        },
        getCategoriesData: function() {
            return this._categoriesData;
        },
        formatTooltip: function(t, e, i) {
            if ("edge" === i) {
                var n = this.getData(), a = this.getDataParams(t, i), o = n.graph.getEdgeByIndex(t), r = n.getName(o.node1.dataIndex), s = n.getName(o.node2.dataIndex), l = [];
                return null != r && l.push(r), null != s && l.push(s), l = ta(l.join(" > ")), a.value && (l += " : " + ta(a.value)), 
                l;
            }
            return _S.superApply(this, "formatTooltip", arguments);
        },
        _updateCategoriesData: function() {
            var t = L(this.option.categories || [], function(t) {
                return null != t.value ? t : P({
                    value: 0
                }, t);
            }), e = new x_([ "value" ], this);
            e.initData(t), this._categoriesData = e, this._categoriesModels = e.mapArray(function(t) {
                return e.getItemModel(t, !0);
            });
        },
        setZoom: function(t) {
            this.option.zoom = t;
        },
        setCenter: function(t) {
            this.option.center = t;
        },
        isAnimationEnabled: function() {
            return _S.superCall(this, "isAnimationEnabled") && !("force" === this.get("layout") && this.get("force.layoutAnimation"));
        },
        defaultOption: {
            zlevel: 0,
            z: 2,
            coordinateSystem: "view",
            legendHoverLink: !0,
            hoverAnimation: !0,
            layout: null,
            focusNodeAdjacency: !1,
            circular: {
                rotateLabel: !1
            },
            force: {
                initLayout: null,
                repulsion: [ 0, 50 ],
                gravity: .1,
                edgeLength: 30,
                layoutAnimation: !0
            },
            left: "center",
            top: "center",
            symbol: "circle",
            symbolSize: 10,
            edgeSymbol: [ "none", "none" ],
            edgeSymbolSize: 10,
            edgeLabel: {
                position: "middle"
            },
            draggable: !1,
            roam: !1,
            center: null,
            zoom: 1,
            nodeScaleRatio: .6,
            label: {
                show: !1,
                formatter: "{b}"
            },
            itemStyle: {},
            lineStyle: {
                color: "#aaa",
                width: 1,
                curveness: 0,
                opacity: .5
            },
            emphasis: {
                label: {
                    show: !0
                }
            }
        }
    }), wS = Fv.prototype, bS = Zv.prototype, SS = Yi({
        type: "ec-line",
        style: {
            stroke: "#000",
            fill: null
        },
        shape: {
            x1: 0,
            y1: 0,
            x2: 0,
            y2: 0,
            percent: 1,
            cpx1: null,
            cpy1: null
        },
        buildPath: function(t, e) {
            (lh(e) ? wS : bS).buildPath(t, e);
        },
        pointAt: function(t) {
            return lh(this.shape) ? wS.pointAt.call(this, t) : bS.pointAt.call(this, t);
        },
        tangentAt: function(t) {
            var e = this.shape, i = lh(e) ? [ e.x2 - e.x1, e.y2 - e.y1 ] : bS.tangentAt.call(this, t);
            return q(i, i);
        }
    }), MS = [ "fromSymbol", "toSymbol" ], IS = dh.prototype;
    IS.beforeUpdate = function() {
        var t = this.childOfName("fromSymbol"), e = this.childOfName("toSymbol"), i = this.childOfName("label");
        if (t || e || !i.ignore) {
            for (var n = 1, a = this.parent; a; ) a.scale && (n /= a.scale[0]), a = a.parent;
            var o = this.childOfName("line");
            if (this.__dirty || o.__dirty) {
                var r = o.shape.percent, s = o.pointAt(0), l = o.pointAt(r), h = U([], l, s);
                if (q(h, h), t && (t.attr("position", s), u = o.tangentAt(0), t.attr("rotation", Math.PI / 2 - Math.atan2(u[1], u[0])), 
                t.attr("scale", [ n * r, n * r ])), e) {
                    e.attr("position", l);
                    var u = o.tangentAt(1);
                    e.attr("rotation", -Math.PI / 2 - Math.atan2(u[1], u[0])), e.attr("scale", [ n * r, n * r ]);
                }
                if (!i.ignore) {
                    i.attr("position", l);
                    var c, d, f, p = 5 * n;
                    if ("end" === i.__position) c = [ h[0] * p + l[0], h[1] * p + l[1] ], d = .8 < h[0] ? "left" : h[0] < -.8 ? "right" : "center", 
                    f = .8 < h[1] ? "top" : h[1] < -.8 ? "bottom" : "middle"; else if ("middle" === i.__position) {
                        var g = r / 2, m = [ (u = o.tangentAt(g))[1], -u[0] ], v = o.pointAt(g);
                        0 < m[1] && (m[0] = -m[0], m[1] = -m[1]), c = [ v[0] + m[0] * p, v[1] + m[1] * p ], 
                        d = "center", f = "bottom";
                        var y = -Math.atan2(u[1], u[0]);
                        l[0] < s[0] && (y = Math.PI + y), i.attr("rotation", y);
                    } else c = [ -h[0] * p + s[0], -h[1] * p + s[1] ], d = .8 < h[0] ? "right" : h[0] < -.8 ? "left" : "center", 
                    f = .8 < h[1] ? "bottom" : h[1] < -.8 ? "top" : "middle";
                    i.attr({
                        style: {
                            textVerticalAlign: i.__verticalAlign || f,
                            textAlign: i.__textAlign || d
                        },
                        position: c,
                        scale: [ n, n ]
                    });
                }
            }
        }
    }, IS._createLine = function(i, n, t) {
        var e, a, o = i.hostModel, r = (e = i.getItemLayout(n), ch((a = new SS({
            name: "line"
        })).shape, e), a);
        r.shape.percent = 0, In(r, {
            shape: {
                percent: 1
            }
        }, o, n), this.add(r);
        var s = new Nv({
            name: "label"
        });
        this.add(s), R(MS, function(t) {
            var e = uh(t, i, n);
            this.add(e), this[hh(t)] = i.getItemVisual(n, t);
        }, this), this._updateCommonStl(i, n, t);
    }, IS.updateData = function(a, o, t) {
        var e = a.hostModel, i = this.childOfName("line"), n = a.getItemLayout(o), r = {
            shape: {}
        };
        ch(r.shape, n), Mn(i, r, e, o), R(MS, function(t) {
            var e = a.getItemVisual(o, t), i = hh(t);
            if (this[i] !== e) {
                this.remove(this.childOfName(t));
                var n = uh(t, a, o);
                this.add(n);
            }
            this[i] = e;
        }, this), this._updateCommonStl(a, o, t);
    }, IS._updateCommonStl = function(t, e, i) {
        var n = t.hostModel, a = this.childOfName("line"), o = i && i.lineStyle, r = i && i.hoverLineStyle, s = i && i.labelModel, l = i && i.hoverLabelModel;
        if (!i || t.hasItemOption) {
            var h = t.getItemModel(e);
            o = h.getModel("lineStyle").getLineStyle(), r = h.getModel("emphasis.lineStyle").getLineStyle(), 
            s = h.getModel("label"), l = h.getModel("emphasis.label");
        }
        var u = t.getItemVisual(e, "color"), c = G(t.getItemVisual(e, "opacity"), o.opacity, 1);
        a.useStyle(E({
            strokeNoScale: !0,
            fill: "none",
            stroke: u,
            opacity: c
        }, o)), a.hoverStyle = r, R(MS, function(t) {
            var e = this.childOfName(t);
            e && (e.setColor(u), e.setStyle({
                opacity: c
            }));
        }, this);
        var d, f, p, g = s.getShallow("show"), m = l.getShallow("show"), v = this.childOfName("label");
        if (g || m) {
            if (d = u || "#000", null == (f = n.getFormattedLabel(e, "normal", t.dataType))) {
                var y = n.getRawValue(e);
                f = null == y ? t.getName(e) : isFinite(y) ? Bn(y) : y;
            }
            p = k(n.getFormattedLabel(e, "emphasis", t.dataType), f);
        }
        if (g) {
            var x = vn(v.style, s, {
                text: f
            }, {
                autoColor: d
            });
            v.__textAlign = x.textAlign, v.__verticalAlign = x.textVerticalAlign, v.__position = s.get("position") || "middle";
        } else v.setStyle("text", null);
        v.hoverStyle = m ? {
            text: p,
            textFill: l.getTextColor(!0),
            fontStyle: l.getShallow("fontStyle"),
            fontWeight: l.getShallow("fontWeight"),
            fontSize: l.getShallow("fontSize"),
            fontFamily: l.getShallow("fontFamily")
        } : {
            text: null
        }, v.ignore = !g && !m, gn(this);
    }, IS.highlight = function() {
        this.trigger("emphasis");
    }, IS.downplay = function() {
        this.trigger("normal");
    }, IS.updateLayout = function(t, e) {
        this.setLinePoints(t.getItemLayout(e));
    }, IS.setLinePoints = function(t) {
        var e = this.childOfName("line");
        ch(e.shape, t), e.dirty();
    }, o(dh, Dg);
    var TS = fh.prototype;
    TS.isPersistent = function() {
        return !0;
    }, TS.updateData = function(l) {
        var h = this, e = h.group, u = h._lineData;
        h._lineData = l, u || e.removeAll();
        var c = ph(l);
        l.diff(u).add(function(t) {
            !function(t, e, i, n) {
                if (mh(e.getItemLayout(i))) {
                    var a = new t._ctor(e, i, n);
                    e.setItemGraphicEl(i, a), t.group.add(a);
                }
            }(h, l, t, c);
        }).update(function(t, e) {
            var i, n, a, o, r, s;
            i = h, n = l, a = e, o = t, r = c, s = u.getItemGraphicEl(a), mh(n.getItemLayout(o)) ? (s ? s.updateData(n, o, r) : s = new i._ctor(n, o, r), 
            n.setItemGraphicEl(o, s), i.group.add(s)) : i.group.remove(s);
        }).remove(function(t) {
            e.remove(u.getItemGraphicEl(t));
        }).execute();
    }, TS.updateLayout = function() {
        var i = this._lineData;
        i.eachItemGraphicEl(function(t, e) {
            t.updateLayout(i, e);
        }, this);
    }, TS.incrementalPrepareUpdate = function(t) {
        this._seriesScope = ph(t), this._lineData = null, this.group.removeAll();
    }, TS.incrementalUpdate = function(t, e) {
        for (var i = t.start; i < t.end; i++) if (mh(e.getItemLayout(i))) {
            var n = new this._ctor(e, i, this._seriesScope);
            n.traverse(function(t) {
                t.isGroup || (t.incremental = t.useHoverLayer = !0);
            }), this.group.add(n);
        }
    }, TS.remove = function() {
        this._clearIncremental(), this._incremental = null, this.group.removeAll();
    }, TS._clearIncremental = function() {
        var t = this._incremental;
        t && t.clearDisplaybles();
    };
    var DS = [], AS = [], CS = [], LS = Si, kS = Fp, PS = Math.abs, NS = function(t, l) {
        function h(t) {
            var e = t.getVisual("symbolSize");
            return e instanceof Array && (e = (e[0] + e[1]) / 2), e;
        }
        var u = [], c = Ti, d = [ [], [], [] ], f = [ [], [] ], p = [];
        l /= 2, t.eachEdge(function(t, e) {
            var i = t.getLayout(), n = t.getVisual("fromSymbol"), a = t.getVisual("toSymbol");
            i.__original || (i.__original = [ D(i[0]), D(i[1]) ], i[2] && i.__original.push(D(i[2])));
            var o = i.__original;
            if (null != i[2]) {
                if (T(d[0], o[0]), T(d[1], o[2]), T(d[2], o[1]), n && "none" != n) {
                    var r = h(t.node1), s = vh(d, o[0], r * l);
                    c(d[0][0], d[1][0], d[2][0], s, u), d[0][0] = u[3], d[1][0] = u[4], c(d[0][1], d[1][1], d[2][1], s, u), 
                    d[0][1] = u[3], d[1][1] = u[4];
                }
                if (a && "none" != a) {
                    r = h(t.node2), s = vh(d, o[1], r * l);
                    c(d[0][0], d[1][0], d[2][0], s, u), d[1][0] = u[1], d[2][0] = u[2], c(d[0][1], d[1][1], d[2][1], s, u), 
                    d[1][1] = u[1], d[2][1] = u[2];
                }
                T(i[0], d[0]), T(i[1], d[2]), T(i[2], d[1]);
            } else T(f[0], o[0]), T(f[1], o[1]), U(p, f[1], f[0]), q(p, p), n && "none" != n && (r = h(t.node1), 
            Z(f[0], f[0], p, r * l)), a && "none" != a && (r = h(t.node2), Z(f[1], f[1], p, -r * l)), 
            T(i[0], f[0]), T(i[1], f[1]);
        });
    }, OS = [ "itemStyle", "opacity" ], ES = [ "lineStyle", "opacity" ];
    $o({
        type: "graph",
        init: function(t, e) {
            var i = new jr(), n = new fh(), a = this.group;
            this._controller = new Qs(e.getZr()), this._controllerHost = {
                target: a
            }, a.add(i.group), a.add(n.group), this._symbolDraw = i, this._lineDraw = n, this._firstRender = !0;
        },
        render: function(a, t, o) {
            var e = a.coordinateSystem;
            this._model = a, this._nodeScaleRatio = a.get("nodeScaleRatio");
            var i = this._symbolDraw, n = this._lineDraw, r = this.group;
            if ("view" === e.type) {
                var s = {
                    position: e.position,
                    scale: e.scale
                };
                this._firstRender ? r.attr(s) : Mn(r, s, a);
            }
            NS(a.getGraph(), this._getNodeGlobalScale(a));
            var l = a.getData();
            i.updateData(l);
            var h = a.getEdgeData();
            n.updateData(h), this._updateNodeAndLinkScale(), this._updateController(a, t, o), 
            clearTimeout(this._layoutTimeout);
            var u = a.forceLayout, c = a.get("force.layoutAnimation");
            u && this._startForceLayoutIteration(u, c), l.eachItemGraphicEl(function(t, e) {
                var i = l.getItemModel(e);
                t.off("drag").off("dragend");
                var n = l.getItemModel(e).get("draggable");
                n && t.on("drag", function() {
                    u && (u.warmUp(), !this._layouting && this._startForceLayoutIteration(u, c), u.setFixed(e), 
                    l.setItemLayout(e, t.position));
                }, this).on("dragend", function() {
                    u && u.setUnfixed(e);
                }, this), t.setDraggable(n && u), t.off("mouseover", t.__focusNodeAdjacency), t.off("mouseout", t.__unfocusNodeAdjacency), 
                i.get("focusNodeAdjacency") && (t.on("mouseover", t.__focusNodeAdjacency = function() {
                    o.dispatchAction({
                        type: "focusNodeAdjacency",
                        seriesId: a.id,
                        dataIndex: t.dataIndex
                    });
                }), t.on("mouseout", t.__unfocusNodeAdjacency = function() {
                    o.dispatchAction({
                        type: "unfocusNodeAdjacency",
                        seriesId: a.id
                    });
                }));
            }, this), l.graph.eachEdge(function(t) {
                var e = t.getGraphicEl();
                e.off("mouseover", e.__focusNodeAdjacency), e.off("mouseout", e.__unfocusNodeAdjacency), 
                t.getModel().get("focusNodeAdjacency") && (e.on("mouseover", e.__focusNodeAdjacency = function() {
                    o.dispatchAction({
                        type: "focusNodeAdjacency",
                        seriesId: a.id,
                        edgeDataIndex: t.dataIndex
                    });
                }), e.on("mouseout", e.__unfocusNodeAdjacency = function() {
                    o.dispatchAction({
                        type: "unfocusNodeAdjacency",
                        seriesId: a.id
                    });
                }));
            });
            var d = "circular" === a.get("layout") && a.get("circular.rotateLabel"), f = l.getLayout("cx"), p = l.getLayout("cy");
            l.eachItemGraphicEl(function(t, e) {
                var i = t.getSymbolPath();
                if (d) {
                    var n = l.getItemLayout(e), a = Math.atan2(n[1] - p, n[0] - f);
                    a < 0 && (a = 2 * Math.PI + a);
                    var o = n[0] < f;
                    o && (a -= Math.PI);
                    var r = o ? "left" : "right";
                    i.setStyle({
                        textRotation: -a,
                        textPosition: r,
                        textOrigin: "center"
                    }), i.hoverStyle && (i.hoverStyle.textPosition = r);
                } else i.setStyle({
                    textRotation: 0
                });
            }), this._firstRender = !1;
        },
        dispose: function() {
            this._controller && this._controller.dispose(), this._controllerHost = {};
        },
        focusNodeAdjacency: function(t, e, i, n) {
            var a = this._model.getData().graph, o = n.dataIndex, r = n.edgeDataIndex, s = a.getNodeByIndex(o), l = a.getEdgeByIndex(r);
            (s || l) && (a.eachNode(function(t) {
                xh(t, OS, .1);
            }), a.eachEdge(function(t) {
                xh(t, ES, .1);
            }), s && (_h(s, OS), R(s.edges, function(t) {
                t.dataIndex < 0 || (_h(t, ES), _h(t.node1, OS), _h(t.node2, OS));
            })), l && (_h(l, ES), _h(l.node1, OS), _h(l.node2, OS)));
        },
        unfocusNodeAdjacency: function(t, e, i, n) {
            var a = this._model.getData().graph;
            a.eachNode(function(t) {
                xh(t, OS);
            }), a.eachEdge(function(t) {
                xh(t, ES);
            });
        },
        _startForceLayoutIteration: function(t, i) {
            var n = this;
            !function e() {
                t.step(function(t) {
                    n.updateLayout(n._model), (n._layouting = !t) && (i ? n._layoutTimeout = setTimeout(e, 16) : e());
                });
            }();
        },
        _updateController: function(a, t, o) {
            var e = this._controller, n = this._controllerHost, r = this.group;
            e.setPointerChecker(function(t, e, i) {
                var n = r.getBoundingRect();
                return n.applyTransform(r.transform), n.contain(e, i) && !hl(t, o, a);
            }), "view" === a.coordinateSystem.type ? (e.enable(a.get("roam")), n.zoomLimit = a.get("scaleLimit"), 
            n.zoom = a.coordinateSystem.getZoom(), e.off("pan").off("zoom").on("pan", function(t, e) {
                sl(n, t, e), o.dispatchAction({
                    seriesId: a.id,
                    type: "graphRoam",
                    dx: t,
                    dy: e
                });
            }).on("zoom", function(t, e, i) {
                ll(n, t, e, i), o.dispatchAction({
                    seriesId: a.id,
                    type: "graphRoam",
                    zoom: t,
                    originX: e,
                    originY: i
                }), this._updateNodeAndLinkScale(), NS(a.getGraph(), this._getNodeGlobalScale(a)), 
                this._lineDraw.updateLayout();
            }, this)) : e.disable();
        },
        _updateNodeAndLinkScale: function() {
            var t = this._model, e = t.getData(), i = this._getNodeGlobalScale(t), n = [ i, i ];
            e.eachItemGraphicEl(function(t, e) {
                t.attr("scale", n);
            });
        },
        _getNodeGlobalScale: function(t) {
            var e = t.coordinateSystem;
            if ("view" !== e.type) return 1;
            var i = this._nodeScaleRatio, n = e.scale, a = n && n[0] || 1;
            return ((e.getZoom() - 1) * i + 1) / a;
        },
        updateLayout: function(t) {
            NS(t.getGraph(), this._getNodeGlobalScale(t)), this._symbolDraw.updateLayout(), 
            this._lineDraw.updateLayout();
        },
        remove: function(t, e) {
            this._symbolDraw && this._symbolDraw.remove(), this._lineDraw && this._lineDraw.remove();
        }
    }), Fo({
        type: "graphRoam",
        event: "graphRoam",
        update: "none"
    }, function(i, t) {
        t.eachComponent({
            mainType: "series",
            query: i
        }, function(t) {
            var e = fl(t.coordinateSystem, i);
            t.setCenter && t.setCenter(e.center), t.setZoom && t.setZoom(e.zoom);
        });
    }), Fo({
        type: "focusNodeAdjacency",
        event: "focusNodeAdjacency",
        update: "series.graph:focusNodeAdjacency"
    }, function() {}), Fo({
        type: "unfocusNodeAdjacency",
        event: "unfocusNodeAdjacency",
        update: "series.graph:unfocusNodeAdjacency"
    }, function() {});
    var RS = Z;
    Wo(function(t) {
        var o = t.findComponents({
            mainType: "legend"
        });
        o && o.length && t.eachSeriesByType("graph", function(t) {
            var e = t.getCategoriesData(), n = t.getGraph().data, a = e.mapArray(e.getName);
            n.filterSelf(function(t) {
                var e = n.getItemModel(t).getShallow("category");
                if (null != e) {
                    "number" == typeof e && (e = a[e]);
                    for (var i = 0; i < o.length; i++) if (!o[i].isSelected(e)) return !1;
                }
                return !0;
            });
        }, this);
    }), Uo(bw("graph", "circle", null)), Uo(function(t) {
        var r = {};
        t.eachSeriesByType("graph", function(n) {
            var a = n.getCategoriesData(), i = n.getData(), o = {};
            a.each(function(t) {
                var e = a.getName(t);
                o["ec-" + e] = t;
                var i = a.getItemModel(t).get("itemStyle.color") || n.getColorFromPalette(e, r);
                a.setItemVisual(t, "color", i);
            }), a.count() && i.each(function(t) {
                var e = i.getItemModel(t).getShallow("category");
                null != e && ("string" == typeof e && (e = o["ec-" + e]), i.getItemVisual(t, "color", !0) || i.setItemVisual(t, "color", a.getItemVisual(e, "color")));
            });
        });
    }), Uo(function(t) {
        t.eachSeriesByType("graph", function(t) {
            var s = t.getGraph(), l = t.getEdgeData(), e = wh(t.get("edgeSymbol")), i = wh(t.get("edgeSymbolSize")), h = "lineStyle.color".split("."), u = "lineStyle.opacity".split(".");
            l.setVisual("fromSymbol", e && e[0]), l.setVisual("toSymbol", e && e[1]), l.setVisual("fromSymbolSize", i && i[0]), 
            l.setVisual("toSymbolSize", i && i[1]), l.setVisual("color", t.get(h)), l.setVisual("opacity", t.get(u)), 
            l.each(function(t) {
                var e = l.getItemModel(t), i = s.getEdgeByIndex(t), n = wh(e.getShallow("symbol", !0)), a = wh(e.getShallow("symbolSize", !0)), o = e.get(h), r = e.get(u);
                switch (o) {
                  case "source":
                    o = i.node1.getVisual("color");
                    break;

                  case "target":
                    o = i.node2.getVisual("color");
                }
                n[0] && i.setVisual("fromSymbol", n[0]), n[1] && i.setVisual("toSymbol", n[1]), 
                a[0] && i.setVisual("fromSymbolSize", a[0]), a[1] && i.setVisual("toSymbolSize", a[1]), 
                i.setVisual("color", o), i.setVisual("opacity", r);
            });
        });
    }), Zo(function(t, e) {
        t.eachSeriesByType("graph", function(t) {
            var e = t.get("layout"), i = t.coordinateSystem;
            if (i && "view" !== i.type) {
                var n = t.getData(), a = [];
                R(i.dimensions, function(t) {
                    a = a.concat(n.mapDimension(t, !0));
                });
                for (var o = 0; o < n.count(); o++) {
                    for (var r = [], s = !1, l = 0; l < a.length; l++) {
                        var h = n.get(a[l], o);
                        isNaN(h) || (s = !0), r.push(h);
                    }
                    s ? n.setItemLayout(o, i.dataToPoint(r)) : n.setItemLayout(o, [ NaN, NaN ]);
                }
                Sh(n.graph);
            } else e && "none" !== e || bh(t);
        });
    }), Zo(function(t) {
        t.eachSeriesByType("graph", function(t) {
            "circular" === t.get("layout") && Mh(t);
        });
    }), Zo(function(t) {
        t.eachSeriesByType("graph", function(t) {
            var e = t.coordinateSystem;
            if (!e || "view" === e.type) if ("force" === t.get("layout")) {
                var c = t.preservedPoints || {}, d = t.getGraph(), f = d.data, i = d.edgeData, n = t.getModel("force"), a = n.get("initLayout");
                t.preservedPoints ? f.each(function(t) {
                    var e = f.getId(t);
                    f.setItemLayout(t, c[e] || [ NaN, NaN ]);
                }) : a && "none" !== a ? "circular" === a && Mh(t) : bh(t);
                var o = f.getDataExtent("value"), r = i.getDataExtent("value"), s = n.get("repulsion"), l = n.get("edgeLength");
                N(s) || (s = [ s, s ]), N(l) || (l = [ l, l ]), l = [ l[1], l[0] ];
                var h = f.mapArray("value", function(t, e) {
                    var i = f.getItemLayout(e), n = Rn(t, o, s);
                    return isNaN(n) && (n = (s[0] + s[1]) / 2), {
                        w: n,
                        rep: n,
                        fixed: f.getItemModel(e).get("fixed"),
                        p: !i || isNaN(i[0]) || isNaN(i[1]) ? null : i
                    };
                }), u = i.mapArray("value", function(t, e) {
                    var i = d.getEdgeByIndex(e), n = Rn(t, r, l);
                    return isNaN(n) && (n = (l[0] + l[1]) / 2), {
                        n1: h[i.node1.dataIndex],
                        n2: h[i.node2.dataIndex],
                        d: n,
                        curveness: i.getModel().get("lineStyle.curveness") || 0
                    };
                }), p = (e = t.coordinateSystem).getBoundingRect(), g = function(f, p, t) {
                    for (var e = t.rect, i = e.width, n = e.height, g = [ e.x + i / 2, e.y + n / 2 ], m = null == t.gravity ? .1 : t.gravity, a = 0; a < f.length; a++) {
                        var o = f[a];
                        o.p || (o.p = M(i * (Math.random() - .5) + g[0], n * (Math.random() - .5) + g[1])), 
                        o.pp = D(o.p), o.edges = null;
                    }
                    var v = .6;
                    return {
                        warmUp: function() {
                            v = .5;
                        },
                        setFixed: function(t) {
                            f[t].fixed = !0;
                        },
                        setUnfixed: function(t) {
                            f[t].fixed = !1;
                        },
                        step: function(t) {
                            for (var e = [], i = f.length, n = 0; n < p.length; n++) {
                                var a = p[n], o = a.n1;
                                U(e, (h = a.n2).p, o.p);
                                var r = j(e) - a.d, s = h.w / (o.w + h.w);
                                isNaN(s) && (s = 0), q(e, e), !o.fixed && RS(o.p, o.p, e, s * r * v), !h.fixed && RS(h.p, h.p, e, -(1 - s) * r * v);
                            }
                            for (n = 0; n < i; n++) (d = f[n]).fixed || (U(e, g, d.p), RS(d.p, d.p, e, m * v));
                            for (n = 0; n < i; n++) {
                                o = f[n];
                                for (var l = n + 1; l < i; l++) {
                                    var h = f[l];
                                    U(e, h.p, o.p), 0 === (r = j(e)) && (F(e, Math.random() - .5, Math.random() - .5), 
                                    r = 1);
                                    var u = (o.rep + h.rep) / r / r;
                                    !o.fixed && RS(o.pp, o.pp, e, u), !h.fixed && RS(h.pp, h.pp, e, -u);
                                }
                            }
                            var c = [];
                            for (n = 0; n < i; n++) {
                                var d = f[n];
                                d.fixed || (U(c, d.p, d.pp), RS(d.p, d.p, c, v), T(d.pp, d.p));
                            }
                            v *= .992, t && t(f, p, v < .01);
                        }
                    };
                }(h, u, {
                    rect: p,
                    gravity: n.get("gravity")
                }), m = g.step;
                g.step = function(u) {
                    for (var t = 0, e = h.length; t < e; t++) h[t].fixed && T(h[t].p, d.getNodeByIndex(t).getLayout());
                    m(function(t, e, i) {
                        for (var n = 0, a = t.length; n < a; n++) t[n].fixed || d.getNodeByIndex(n).setLayout(t[n].p), 
                        c[f.getId(n)] = t[n].p;
                        for (n = 0, a = e.length; n < a; n++) {
                            var o = e[n], r = d.getEdgeByIndex(n), s = o.n1.p, l = o.n2.p, h = r.getLayout();
                            (h = h ? h.slice() : [])[0] = h[0] || [], h[1] = h[1] || [], T(h[0], s), T(h[1], l), 
                            +o.curveness && (h[2] = [ (s[0] + l[0]) / 2 - (s[1] - l[1]) * o.curveness, (s[1] + l[1]) / 2 - (l[0] - s[0]) * o.curveness ]), 
                            r.setLayout(h);
                        }
                        u && u(i);
                    });
                }, t.forceLayout = g, t.preservedPoints = c, g.step();
            } else t.forceLayout = null;
        });
    }), Ho("graphView", {
        create: function(t, g) {
            var m = [];
            return t.eachSeriesByType("graph", function(t) {
                var e, i, n, a = t.get("coordinateSystem");
                if (!a || "view" === a) {
                    var o = t.getData(), r = [], s = [];
                    Di(o.mapArray(function(t) {
                        var e = o.getItemModel(t);
                        return [ +e.get("x"), +e.get("y") ];
                    }), r, s), s[0] - r[0] == 0 && (s[0] += 1, r[0] -= 1), s[1] - r[1] == 0 && (s[1] += 1, 
                    r[1] -= 1);
                    var l = (s[0] - r[0]) / (s[1] - r[1]), h = (e = g, i = l, (n = t.getBoxLayoutParams()).aspect = i, 
                    la(n, {
                        width: e.getWidth(),
                        height: e.getHeight()
                    }));
                    isNaN(l) && (r = [ h.x, h.y ], s = [ h.x + h.width, h.y + h.height ]);
                    var u = s[0] - r[0], c = s[1] - r[1], d = h.width, f = h.height, p = t.coordinateSystem = new Us();
                    p.zoomLimit = t.get("scaleLimit"), p.setBoundingRect(r[0], r[1], u, c), p.setViewRect(h.x, h.y, d, f), 
                    p.setCenter(t.get("center")), p.setZoom(t.get("zoom")), m.push(p);
                }
            }), m;
        }
    }), px.extend({
        type: "series.gauge",
        getInitialData: function(t, e) {
            var i = t.data || [];
            return N(i) || (i = [ i ]), t.data = i, ob(this, [ "value" ]);
        },
        defaultOption: {
            zlevel: 0,
            z: 2,
            center: [ "50%", "50%" ],
            legendHoverLink: !0,
            radius: "75%",
            startAngle: 225,
            endAngle: -45,
            clockwise: !0,
            min: 0,
            max: 100,
            splitNumber: 10,
            axisLine: {
                show: !0,
                lineStyle: {
                    color: [ [ .2, "#91c7ae" ], [ .8, "#63869e" ], [ 1, "#c23531" ] ],
                    width: 30
                }
            },
            splitLine: {
                show: !0,
                length: 30,
                lineStyle: {
                    color: "#eee",
                    width: 2,
                    type: "solid"
                }
            },
            axisTick: {
                show: !0,
                splitNumber: 5,
                length: 8,
                lineStyle: {
                    color: "#eee",
                    width: 1,
                    type: "solid"
                }
            },
            axisLabel: {
                show: !0,
                distance: 5,
                color: "auto"
            },
            pointer: {
                show: !0,
                length: "80%",
                width: 8
            },
            itemStyle: {
                color: "auto"
            },
            title: {
                show: !0,
                offsetCenter: [ 0, "-40%" ],
                color: "#333",
                fontSize: 15
            },
            detail: {
                show: !0,
                backgroundColor: "rgba(0,0,0,0)",
                borderWidth: 0,
                borderColor: "#ccc",
                width: 100,
                height: null,
                padding: [ 5, 10 ],
                offsetCenter: [ 0, "40%" ],
                color: "auto",
                fontSize: 30
            }
        }
    });
    var zS = Wi.extend({
        type: "echartsGaugePointer",
        shape: {
            angle: 0,
            width: 10,
            r: 10,
            x: 0,
            y: 0
        },
        buildPath: function(t, e) {
            var i = Math.cos, n = Math.sin, a = e.r, o = e.width, r = e.angle, s = e.x - i(r) * o * (a / 3 <= o ? 1 : 2), l = e.y - n(r) * o * (a / 3 <= o ? 1 : 2);
            r = e.angle - Math.PI / 2, t.moveTo(s, l), t.lineTo(e.x + i(r) * o, e.y + n(r) * o), 
            t.lineTo(e.x + i(e.angle) * a, e.y + n(e.angle) * a), t.lineTo(e.x - i(r) * o, e.y - n(r) * o), 
            t.lineTo(s, l);
        }
    }), BS = 2 * Math.PI, VS = (to.extend({
        type: "gauge",
        render: function(t, e, i) {
            this.group.removeAll();
            var n, a, o, r, s, l, h = t.get("axisLine.lineStyle.color"), u = (a = i, o = (n = t).get("center"), 
            r = a.getWidth(), s = a.getHeight(), l = Math.min(r, s), {
                cx: zn(o[0], a.getWidth()),
                cy: zn(o[1], a.getHeight()),
                r: zn(n.get("radius"), l / 2)
            });
            this._renderMain(t, e, i, h, u);
        },
        dispose: function() {},
        _renderMain: function(t, e, i, n, a) {
            for (var o = this.group, r = t.getModel("axisLine").getModel("lineStyle"), s = t.get("clockwise"), l = -t.get("startAngle") / 180 * Math.PI, h = -t.get("endAngle") / 180 * Math.PI, u = (h - l) % BS, c = l, d = r.get("width"), f = 0; f < n.length; f++) {
                var p = Math.min(Math.max(n[f][0], 0), 1), g = new zv({
                    shape: {
                        startAngle: c,
                        endAngle: h = l + u * p,
                        cx: a.cx,
                        cy: a.cy,
                        clockwise: s,
                        r0: a.r - d,
                        r: a.r
                    },
                    silent: !0
                });
                g.setStyle({
                    fill: n[f][1]
                }), g.setStyle(r.getLineStyle([ "color", "borderWidth", "borderColor" ])), o.add(g), 
                c = h;
            }
            var m = function(t) {
                if (t <= 0) return n[0][1];
                for (var e = 0; e < n.length; e++) if (n[e][0] >= t && (0 === e ? 0 : n[e - 1][0]) < t) return n[e][1];
                return n[e - 1][1];
            };
            if (!s) {
                var v = l;
                l = h, h = v;
            }
            this._renderTicks(t, e, i, m, a, l, h, s), this._renderPointer(t, e, i, m, a, l, h, s), 
            this._renderTitle(t, e, i, m, a), this._renderDetail(t, e, i, m, a);
        },
        _renderTicks: function(t, e, i, n, a, o, r, s) {
            for (var l = this.group, h = a.cx, u = a.cy, c = a.r, d = +t.get("min"), f = +t.get("max"), p = t.getModel("splitLine"), g = t.getModel("axisTick"), m = t.getModel("axisLabel"), v = t.get("splitNumber"), y = g.get("splitNumber"), x = zn(p.get("length"), c), _ = zn(g.get("length"), c), w = o, b = (r - o) / v, S = b / y, M = p.getModel("lineStyle").getLineStyle(), I = g.getModel("lineStyle").getLineStyle(), T = 0; T <= v; T++) {
                var D = Math.cos(w), A = Math.sin(w);
                if (p.get("show")) {
                    var C = new Fv({
                        shape: {
                            x1: D * c + h,
                            y1: A * c + u,
                            x2: D * (c - x) + h,
                            y2: A * (c - x) + u
                        },
                        style: M,
                        silent: !0
                    });
                    "auto" === M.stroke && C.setStyle({
                        stroke: n(T / v)
                    }), l.add(C);
                }
                if (m.get("show")) {
                    var L = Ih(Bn(T / v * (f - d) + d), m.get("formatter")), k = m.get("distance"), P = n(T / v);
                    l.add(new Nv({
                        style: vn({}, m, {
                            text: L,
                            x: D * (c - x - k) + h,
                            y: A * (c - x - k) + u,
                            textVerticalAlign: A < -.4 ? "top" : .4 < A ? "bottom" : "middle",
                            textAlign: D < -.4 ? "left" : .4 < D ? "right" : "center"
                        }, {
                            autoColor: P
                        }),
                        silent: !0
                    }));
                }
                if (g.get("show") && T !== v) {
                    for (var N = 0; N <= y; N++) {
                        D = Math.cos(w), A = Math.sin(w);
                        var O = new Fv({
                            shape: {
                                x1: D * c + h,
                                y1: A * c + u,
                                x2: D * (c - _) + h,
                                y2: A * (c - _) + u
                            },
                            silent: !0,
                            style: I
                        });
                        "auto" === I.stroke && O.setStyle({
                            stroke: n((T + N / y) / v)
                        }), l.add(O), w += S;
                    }
                    w -= S;
                } else w += b;
            }
        },
        _renderPointer: function(n, t, e, a, o, i, r, s) {
            var l = this.group, h = this._data;
            if (n.get("pointer.show")) {
                var u = [ +n.get("min"), +n.get("max") ], c = [ i, r ], d = n.getData(), f = d.mapDimension("value");
                d.diff(h).add(function(t) {
                    var e = new zS({
                        shape: {
                            angle: i
                        }
                    });
                    In(e, {
                        shape: {
                            angle: Rn(d.get(f, t), u, c, !0)
                        }
                    }, n), l.add(e), d.setItemGraphicEl(t, e);
                }).update(function(t, e) {
                    var i = h.getItemGraphicEl(e);
                    Mn(i, {
                        shape: {
                            angle: Rn(d.get(f, t), u, c, !0)
                        }
                    }, n), l.add(i), d.setItemGraphicEl(t, i);
                }).remove(function(t) {
                    var e = h.getItemGraphicEl(t);
                    l.remove(e);
                }).execute(), d.eachItemGraphicEl(function(t, e) {
                    var i = d.getItemModel(e), n = i.getModel("pointer");
                    t.setShape({
                        x: o.cx,
                        y: o.cy,
                        width: zn(n.get("width"), o.r),
                        r: zn(n.get("length"), o.r)
                    }), t.useStyle(i.getModel("itemStyle").getItemStyle()), "auto" === t.style.fill && t.setStyle("fill", a(Rn(d.get(f, e), u, [ 0, 1 ], !0))), 
                    gn(t, i.getModel("emphasis.itemStyle").getItemStyle());
                }), this._data = d;
            } else h && h.eachItemGraphicEl(function(t) {
                l.remove(t);
            });
        },
        _renderTitle: function(t, e, i, n, a) {
            var o = t.getData(), r = o.mapDimension("value"), s = t.getModel("title");
            if (s.get("show")) {
                var l = s.get("offsetCenter"), h = a.cx + zn(l[0], a.r), u = a.cy + zn(l[1], a.r), c = +t.get("min"), d = +t.get("max"), f = n(Rn(t.getData().get(r, 0), [ c, d ], [ 0, 1 ], !0));
                this.group.add(new Nv({
                    silent: !0,
                    style: vn({}, s, {
                        x: h,
                        y: u,
                        text: o.getName(0),
                        textAlign: "center",
                        textVerticalAlign: "middle"
                    }, {
                        autoColor: f,
                        forceRich: !0
                    })
                }));
            }
        },
        _renderDetail: function(t, e, i, n, a) {
            var o = t.getModel("detail"), r = +t.get("min"), s = +t.get("max");
            if (o.get("show")) {
                var l = o.get("offsetCenter"), h = a.cx + zn(l[0], a.r), u = a.cy + zn(l[1], a.r), c = zn(o.get("width"), a.r), d = zn(o.get("height"), a.r), f = t.getData(), p = f.get(f.mapDimension("value"), 0), g = n(Rn(p, [ r, s ], [ 0, 1 ], !0));
                this.group.add(new Nv({
                    silent: !0,
                    style: vn({}, o, {
                        x: h,
                        y: u,
                        text: Ih(p, o.get("formatter")),
                        textWidth: isNaN(c) ? null : c,
                        textHeight: isNaN(d) ? null : d,
                        textAlign: "center",
                        textVerticalAlign: "middle"
                    }, {
                        autoColor: g,
                        forceRich: !0
                    })
                }));
            }
        }
    }), Ko({
        type: "series.funnel",
        init: function(t) {
            VS.superApply(this, "init", arguments), this.legendDataProvider = function() {
                return this.getRawData();
            }, this._defaultLabelLine(t);
        },
        getInitialData: function(t, e) {
            return ob(this, [ "value" ]);
        },
        _defaultLabelLine: function(t) {
            ti(t, "labelLine", [ "show" ]);
            var e = t.labelLine, i = t.emphasis.labelLine;
            e.show = e.show && t.label.show, i.show = i.show && t.emphasis.label.show;
        },
        getDataParams: function(t) {
            var e = this.getData(), i = VS.superCall(this, "getDataParams", t), n = e.mapDimension("value"), a = e.getSum(n);
            return i.percent = a ? +(e.get(n, t) / a * 100).toFixed(2) : 0, i.$vars.push("percent"), 
            i;
        },
        defaultOption: {
            zlevel: 0,
            z: 2,
            legendHoverLink: !0,
            left: 80,
            top: 60,
            right: 80,
            bottom: 60,
            minSize: "0%",
            maxSize: "100%",
            sort: "descending",
            gap: 0,
            funnelAlign: "center",
            label: {
                show: !0,
                position: "outer"
            },
            labelLine: {
                show: !0,
                length: 20,
                lineStyle: {
                    width: 1,
                    type: "solid"
                }
            },
            itemStyle: {
                borderColor: "#fff",
                borderWidth: 1
            },
            emphasis: {
                label: {
                    show: !0
                }
            }
        }
    })), GS = Th.prototype, WS = [ "itemStyle", "opacity" ];
    GS.updateData = function(t, e, i) {
        var n = this.childAt(0), a = t.hostModel, o = t.getItemModel(e), r = t.getItemLayout(e), s = t.getItemModel(e).get(WS);
        s = null == s ? 1 : s, n.useStyle({}), i ? (n.setShape({
            points: r.points
        }), n.setStyle({
            opacity: 0
        }), In(n, {
            style: {
                opacity: s
            }
        }, a, e)) : Mn(n, {
            style: {
                opacity: s
            },
            shape: {
                points: r.points
            }
        }, a, e);
        var l = o.getModel("itemStyle"), h = t.getItemVisual(e, "color");
        n.setStyle(E({
            lineJoin: "round",
            fill: h
        }, l.getItemStyle([ "opacity" ]))), n.hoverStyle = l.getModel("emphasis").getItemStyle(), 
        this._updateLabel(t, e), gn(this);
    }, GS._updateLabel = function(t, e) {
        var i = this.childAt(1), n = this.childAt(2), a = t.hostModel, o = t.getItemModel(e), r = t.getItemLayout(e).label, s = t.getItemVisual(e, "color");
        Mn(i, {
            shape: {
                points: r.linePoints || r.linePoints
            }
        }, a, e), Mn(n, {
            style: {
                x: r.x,
                y: r.y
            }
        }, a, e), n.attr({
            rotation: r.rotation,
            origin: [ r.x, r.y ],
            z2: 10
        });
        var l = o.getModel("label"), h = o.getModel("emphasis.label"), u = o.getModel("labelLine"), c = o.getModel("emphasis.labelLine");
        s = t.getItemVisual(e, "color");
        mn(n.style, n.hoverStyle = {}, l, h, {
            labelFetcher: t.hostModel,
            labelDataIndex: e,
            defaultText: t.getName(e),
            autoColor: s,
            useInsideStyle: !!r.inside
        }, {
            textAlign: r.textAlign,
            textVerticalAlign: r.verticalAlign
        }), n.ignore = n.normalIgnore = !l.get("show"), n.hoverIgnore = !h.get("show"), 
        i.ignore = i.normalIgnore = !u.get("show"), i.hoverIgnore = !c.get("show"), i.setStyle({
            stroke: s
        }), i.setStyle(u.getModel("lineStyle").getLineStyle()), i.hoverStyle = c.getModel("lineStyle").getLineStyle();
    }, o(Th, Dg), to.extend({
        type: "funnel",
        render: function(t, e, i) {
            var n = t.getData(), a = this._data, o = this.group;
            n.diff(a).add(function(t) {
                var e = new Th(n, t);
                n.setItemGraphicEl(t, e), o.add(e);
            }).update(function(t, e) {
                var i = a.getItemGraphicEl(e);
                i.updateData(n, t), o.add(i), n.setItemGraphicEl(t, i);
            }).remove(function(t) {
                var e = a.getItemGraphicEl(t);
                o.remove(e);
            }).execute(), this._data = n;
        },
        remove: function() {
            this.group.removeAll(), this._data = null;
        },
        dispose: function() {}
    }), Uo(ub("funnel")), Zo(function(t, S, e) {
        t.eachSeriesByType("funnel", function(t) {
            var e, a = t.getData(), o = a.mapDimension("value"), i = t.get("sort"), r = (e = S, 
            la(t.getBoxLayoutParams(), {
                width: e.getWidth(),
                height: e.getHeight()
            })), n = function(t, e) {
                for (var i = t.mapDimension("value"), n = t.mapArray(i, function(t) {
                    return t;
                }), a = [], o = "ascending" === e, r = 0, s = t.count(); r < s; r++) a[r] = r;
                return "function" == typeof e ? a.sort(e) : "none" !== e && a.sort(function(t, e) {
                    return o ? n[t] - n[e] : n[e] - n[t];
                }), a;
            }(a, i), s = [ zn(t.get("minSize"), r.width), zn(t.get("maxSize"), r.width) ], l = a.getDataExtent(o), h = t.get("min"), u = t.get("max");
            null == h && (h = Math.min(l[0], 0)), null == u && (u = l[1]);
            var g, c = t.get("funnelAlign"), d = t.get("gap"), f = (r.height - d * (a.count() - 1)) / a.count(), p = r.y, m = function(t, e) {
                var i, n = Rn(a.get(o, t) || 0, [ h, u ], s, !0);
                switch (c) {
                  case "left":
                    i = r.x;
                    break;

                  case "center":
                    i = r.x + (r.width - n) / 2;
                    break;

                  case "right":
                    i = r.x + r.width - n;
                }
                return [ [ i, e ], [ i + n, e ] ];
            };
            "ascending" === i && (f = -f, d = -d, p += r.height, n = n.reverse());
            for (var v = 0; v < n.length; v++) {
                var y = n[v], x = n[v + 1], _ = a.getItemModel(y).get("itemStyle.height");
                null == _ ? _ = f : (_ = zn(_, r.height), "ascending" === i && (_ = -_));
                var w = m(y, p), b = m(x, p + _);
                p += _ + d, a.setItemLayout(y, {
                    points: w.concat(b.slice().reverse())
                });
            }
            (g = a).each(function(t) {
                var e, i, n, a, o = g.getItemModel(t), r = o.getModel("label").get("position"), s = o.getModel("labelLine"), l = g.getItemLayout(t), h = l.points, u = "inner" === r || "inside" === r || "center" === r;
                if (u) e = "center", a = [ [ i = (h[0][0] + h[1][0] + h[2][0] + h[3][0]) / 4, n = (h[0][1] + h[1][1] + h[2][1] + h[3][1]) / 4 ], [ i, n ] ]; else {
                    var c, d, f, p = s.get("length");
                    "left" === r ? (c = (h[3][0] + h[0][0]) / 2, d = (h[3][1] + h[0][1]) / 2, i = (f = c - p) - 5, 
                    e = "right") : (c = (h[1][0] + h[2][0]) / 2, d = (h[1][1] + h[2][1]) / 2, i = (f = c + p) + 5, 
                    e = "left"), a = [ [ c, d ], [ f, d ] ], n = d;
                }
                l.label = {
                    linePoints: a,
                    x: i,
                    y: n,
                    verticalAlign: "middle",
                    textAlign: e,
                    inside: u
                };
            });
        });
    }), Wo(pb("funnel"));
    var FS = function(t, e, i, n, a) {
        aw.call(this, t, e, i), this.type = n || "value", this.axisIndex = a;
    };
    FS.prototype = {
        constructor: FS,
        model: null,
        isHorizontal: function() {
            return "horizontal" !== this.coordinateSystem.getModel().get("layout");
        }
    }, o(FS, aw);
    var HS = function(t, e, i, n, a, o) {
        e[0] = Ah(e[0], i), e[1] = Ah(e[1], i), t = t || 0;
        var r = i[1] - i[0];
        null != a && (a = Ah(a, [ 0, r ])), null != o && (o = Math.max(o, null != a ? a : 0)), 
        "all" === n && (a = o = Math.abs(e[1] - e[0]), n = 0);
        var s = Dh(e, n);
        e[n] += t;
        var l = a || 0, h = i.slice();
        s.sign < 0 ? h[0] += l : h[1] -= l, e[n] = Ah(e[n], h), u = Dh(e, n), null != a && (u.sign !== s.sign || u.span < a) && (e[1 - n] = e[n] + s.sign * a);
        var u = Dh(e, n);
        return null != o && u.span > o && (e[1 - n] = e[n] + u.sign * o), e;
    }, ZS = R, US = Math.min, jS = Math.max, XS = Math.floor, YS = Math.ceil, qS = Bn, KS = Math.PI;
    Ch.prototype = {
        type: "parallel",
        constructor: Ch,
        _init: function(t, r, e) {
            var i = t.dimensions, s = t.parallelAxisIndex;
            ZS(i, function(t, e) {
                var i = s[e], n = r.getComponent("parallelAxis", i), a = this._axesMap.set(t, new FS(t, kr(n), [ 0, 0 ], n.get("type"), i)), o = "category" === a.type;
                a.onBand = o && n.get("boundaryGap"), a.inverse = n.get("inverse"), (n.axis = a).model = n, 
                a.coordinateSystem = n.coordinateSystem = this;
            }, this);
        },
        update: function(t, e) {
            this._updateAxesFromSeries(this._model, t);
        },
        containPoint: function(t) {
            var e = this._makeLayoutInfo(), i = e.axisBase, n = e.layoutBase, a = e.pixelDimIndex, o = t[1 - a], r = t[a];
            return i <= o && o <= i + e.axisLength && n <= r && r <= n + e.layoutLength;
        },
        getModel: function() {
            return this._model;
        },
        _updateAxesFromSeries: function(e, n) {
            n.eachSeries(function(t) {
                if (e.contains(t, n)) {
                    var i = t.getData();
                    ZS(this.dimensions, function(t) {
                        var e = this._axesMap.get(t);
                        e.scale.unionExtentFromData(i, i.mapDimension(t)), Lr(e.scale, e.model);
                    }, this);
                }
            }, this);
        },
        resize: function(t, e) {
            this._rect = la(t.getBoxLayoutParams(), {
                width: e.getWidth(),
                height: e.getHeight()
            }), this._layoutAxes();
        },
        getRect: function() {
            return this._rect;
        },
        _makeLayoutInfo: function() {
            var t, e = this._model, i = this._rect, n = [ "x", "y" ], a = [ "width", "height" ], o = e.get("layout"), r = "horizontal" === o ? 0 : 1, s = i[a[r]], l = [ 0, s ], h = this.dimensions.length, u = Lh(e.get("axisExpandWidth"), l), c = Lh(e.get("axisExpandCount") || 0, [ 0, h ]), d = e.get("axisExpandable") && 3 < h && c < h && 1 < c && 0 < u && 0 < s, f = e.get("axisExpandWindow");
            f ? (t = Lh(f[1] - f[0], l), f[1] = f[0] + t) : (t = Lh(u * (c - 1), l), (f = [ u * (e.get("axisExpandCenter") || XS(h / 2)) - t / 2 ])[1] = f[0] + t);
            var p = (s - t) / (h - c);
            p < 3 && (p = 0);
            var g = [ XS(qS(f[0] / u, 1)) + 1, YS(qS(f[1] / u, 1)) - 1 ], m = p / u * f[0];
            return {
                layout: o,
                pixelDimIndex: r,
                layoutBase: i[n[r]],
                layoutLength: s,
                axisBase: i[n[1 - r]],
                axisLength: i[a[1 - r]],
                axisExpandable: d,
                axisExpandWidth: u,
                axisCollapseWidth: p,
                axisExpandWindow: f,
                axisCount: h,
                winInnerIndices: g,
                axisExpandWindow0Pos: m
            };
        },
        _layoutAxes: function() {
            var l = this._rect, h = this._axesMap, t = this.dimensions, u = this._makeLayoutInfo(), c = u.layout;
            h.each(function(t) {
                var e = [ 0, u.axisLength ], i = t.inverse ? 1 : 0;
                t.setExtent(e[i], e[1 - i]);
            }), ZS(t, function(t, e) {
                var i = (u.axisExpandable ? function(t, e) {
                    var i, n, a = e.layoutLength, o = e.axisExpandWidth, r = e.axisCount, s = e.axisCollapseWidth, l = e.winInnerIndices, h = s, u = !1;
                    return t < l[0] ? (i = t * s, n = s) : t <= l[1] ? (i = e.axisExpandWindow0Pos + t * o - e.axisExpandWindow[0], 
                    h = o, u = !0) : (i = a - (r - 1 - t) * s, n = s), {
                        position: i,
                        axisNameAvailableWidth: h,
                        axisLabelShow: u,
                        nameTruncateMaxWidth: n
                    };
                } : function(t, e) {
                    var i = e.layoutLength / (e.axisCount - 1);
                    return {
                        position: i * t,
                        axisNameAvailableWidth: i,
                        axisLabelShow: !0
                    };
                })(e, u), n = {
                    horizontal: {
                        x: i.position,
                        y: u.axisLength
                    },
                    vertical: {
                        x: 0,
                        y: i.position
                    }
                }, a = {
                    horizontal: KS / 2,
                    vertical: 0
                }, o = [ n[c].x + l.x, n[c].y + l.y ], r = a[c], s = rt();
                ct(s, s, r), ut(s, s, o), this._axesLayout[t] = {
                    position: o,
                    rotation: r,
                    transform: s,
                    axisNameAvailableWidth: i.axisNameAvailableWidth,
                    axisLabelShow: i.axisLabelShow,
                    nameTruncateMaxWidth: i.nameTruncateMaxWidth,
                    tickDirection: 1,
                    labelDirection: 1,
                    labelInterval: h.get(t).getLabelInterval()
                };
            }, this);
        },
        getAxis: function(t) {
            return this._axesMap.get(t);
        },
        dataToPoint: function(t, e) {
            return this.axisCoordToPoint(this._axesMap.get(e).dataToCoord(t), e);
        },
        eachActiveState: function(e, t, i) {
            for (var n = this.dimensions, a = L(n, function(t) {
                return e.mapDimension(t);
            }), o = this._axesMap, r = this.hasAxisBrushed(), s = 0, l = e.count(); s < l; s++) {
                var h, u = e.getValues(a, s);
                if (r) {
                    h = "active";
                    for (var c = 0, d = n.length; c < d; c++) {
                        var f = n[c];
                        if ("inactive" === o.get(f).model.getActiveState(u[c], c)) {
                            h = "inactive";
                            break;
                        }
                    }
                } else h = "normal";
                t.call(i, h, s);
            }
        },
        hasAxisBrushed: function() {
            for (var t = this.dimensions, e = this._axesMap, i = !1, n = 0, a = t.length; n < a; n++) "normal" !== e.get(t[n]).model.getActiveState() && (i = !0);
            return i;
        },
        axisCoordToPoint: function(t, e) {
            return Dn([ t, 0 ], this._axesLayout[e].transform);
        },
        getAxisLayout: function(t) {
            return A(this._axesLayout[t]);
        },
        getSlidedAxisExpandWindow: function(t) {
            var e = this._makeLayoutInfo(), i = e.pixelDimIndex, n = e.axisExpandWindow.slice(), a = n[1] - n[0], o = [ 0, e.axisExpandWidth * (e.axisCount - 1) ];
            if (!this.containPoint(t)) return {
                behavior: "none",
                axisExpandWindow: n
            };
            var r, s = t[i] - e.layoutBase - e.axisExpandWindow0Pos, l = "slide", h = e.axisCollapseWidth, u = this._model.get("axisExpandSlideTriggerArea"), c = null != u[0];
            return h ? (c && h && s < a * u[0] ? (l = "jump", r = s - a * u[2]) : c && h && s > a * (1 - u[0]) ? (l = "jump", 
            r = s - a * (1 - u[2])) : 0 <= (r = s - a * u[1]) && (r = s - a * (1 - u[1])) <= 0 && (r = 0), 
            (r *= e.axisExpandWidth / h) ? HS(r, n, o, "all") : l = "none") : (a = n[1] - n[0], 
            (n = [ jS(0, o[1] * s / a - a / 2) ])[1] = US(o[1], n[0] + a), n[0] = n[1] - a), 
            {
                axisExpandWindow: n,
                behavior: l
            };
        }
    }, Ma.register("parallel", {
        create: function(n, a) {
            var o = [];
            return n.eachComponent("parallel", function(t, e) {
                var i = new Ch(t, n, a);
                i.name = "parallel_" + e, i.resize(t, a), (t.coordinateSystem = i).model = t, o.push(i);
            }), n.eachSeries(function(t) {
                if ("parallel" === t.get("coordinateSystem")) {
                    var e = n.queryComponents({
                        mainType: "parallel",
                        index: t.get("parallelIndex"),
                        id: t.get("parallelId")
                    })[0];
                    t.coordinateSystem = e.coordinateSystem;
                }
            }), o;
        }
    });
    var $S = Cy.extend({
        type: "baseParallelAxis",
        axis: null,
        activeIntervals: [],
        getAreaSelectStyle: function() {
            return Dm([ [ "fill", "color" ], [ "lineWidth", "borderWidth" ], [ "stroke", "borderColor" ], [ "width", "width" ], [ "opacity", "opacity" ] ])(this.getModel("areaSelectStyle"));
        },
        setActiveIntervals: function(t) {
            var e = this.activeIntervals = A(t);
            if (e) for (var i = e.length - 1; 0 <= i; i--) Vn(e[i]);
        },
        getActiveState: function(t) {
            var e = this.activeIntervals;
            if (!e.length) return "normal";
            if (null == t) return "inactive";
            for (var i = 0, n = e.length; i < n; i++) if (e[i][0] <= t && t <= e[i][1]) return "active";
            return "inactive";
        }
    });
    g($S.prototype, Z_), kw("parallel", $S, function(t, e) {
        return e.type || (e.data ? "category" : "value");
    }, {
        type: "value",
        dim: null,
        areaSelectStyle: {
            width: 20,
            borderWidth: 1,
            borderColor: "rgba(160,197,232)",
            color: "rgba(160,197,232)",
            opacity: .3
        },
        realtime: !0,
        z: 10
    }), Cy.extend({
        type: "parallel",
        dependencies: [ "parallelAxis" ],
        coordinateSystem: null,
        dimensions: null,
        parallelAxisIndex: null,
        layoutMode: "box",
        defaultOption: {
            zlevel: 0,
            z: 0,
            left: 80,
            top: 60,
            right: 80,
            bottom: 60,
            layout: "horizontal",
            axisExpandable: !1,
            axisExpandCenter: null,
            axisExpandCount: 0,
            axisExpandWidth: 50,
            axisExpandRate: 17,
            axisExpandDebounce: 50,
            axisExpandSlideTriggerArea: [ -.15, .05, .4 ],
            axisExpandTriggerOn: "click",
            parallelAxisDefault: null
        },
        init: function() {
            Cy.prototype.init.apply(this, arguments), this.mergeOption({});
        },
        mergeOption: function(t) {
            var e = this.option;
            t && g(e, t, !0), this._initDimensions();
        },
        contains: function(t, e) {
            var i = t.get("parallelIndex");
            return null != i && e.getComponent("parallel", i) === this;
        },
        setAxisExpand: function(e) {
            R([ "axisExpandable", "axisExpandCenter", "axisExpandCount", "axisExpandWidth", "axisExpandWindow" ], function(t) {
                e.hasOwnProperty(t) && (this.option[t] = e[t]);
            }, this);
        },
        _initDimensions: function() {
            var e = this.dimensions = [], i = this.parallelAxisIndex = [];
            R(I(this.dependentModels.parallelAxis, function(t) {
                return (t.get("parallelIndex") || 0) === this.componentIndex;
            }, this), function(t) {
                e.push("dim" + t.get("dim")), i.push(t.componentIndex);
            });
        }
    }), Fo({
        type: "axisAreaSelect",
        event: "axisAreaSelected"
    }, function(e, t) {
        t.eachComponent({
            mainType: "parallelAxis",
            query: e
        }, function(t) {
            t.axis.model.setActiveIntervals(e.intervals);
        });
    }), Fo("parallelAxisExpand", function(e, t) {
        t.eachComponent({
            mainType: "parallel",
            query: e
        }, function(t) {
            t.setAxisExpand(e);
        });
    });
    var JS = z, QS = R, tM = L, eM = Math.min, iM = Math.max, nM = Math.pow, aM = 1e4, oM = 6, rM = 6, sM = "globalPan", lM = {
        w: [ 0, 0 ],
        e: [ 0, 1 ],
        n: [ 1, 0 ],
        s: [ 1, 1 ]
    }, hM = {
        w: "ew",
        e: "ew",
        n: "ns",
        s: "ns",
        ne: "nesw",
        sw: "nesw",
        nw: "nwse",
        se: "nwse"
    }, uM = {
        brushStyle: {
            lineWidth: 2,
            stroke: "rgba(0,0,0,0.3)",
            fill: "rgba(0,0,0,0.1)"
        },
        transformable: !0,
        brushMode: "single",
        removeOnClick: !1
    }, cM = 0;
    kh.prototype = {
        constructor: kh,
        enableBrush: function(t) {
            return this._brushType && Nh(this), t.brushType && Ph(this, t), this;
        },
        setPanels: function(t) {
            if (t && t.length) {
                var e = this._panels = {};
                R(t, function(t) {
                    e[t.panelId] = A(t);
                });
            } else this._panels = null;
            return this;
        },
        mount: function(t) {
            t = t || {}, this._enableGlobalPan = t.enableGlobalPan;
            var e = this.group;
            return this._zr.add(e), e.attr({
                position: t.position || [ 0, 0 ],
                rotation: t.rotation || 0,
                scale: t.scale || [ 1, 1 ]
            }), this._transform = e.getLocalTransform(), this;
        },
        eachCover: function(t, e) {
            QS(this._covers, t, e);
        },
        updateCovers: function(a) {
            function i(t, e) {
                return (null != t.id ? t.id : n + e) + "-" + t.brushType;
            }
            function t(t, e) {
                var i = a[t];
                if (null != e && o[e] === l) r[t] = o[e]; else {
                    var n = r[t] = null != e ? (o[e].__brushOption = i, o[e]) : Eh(s, Oh(s, i));
                    Bh(s, n);
                }
            }
            a = L(a, function(t) {
                return g(A(uM), t, !0);
            });
            var n = "\0-brush-index-", o = this._covers, r = this._covers = [], s = this, l = this._creatingCover;
            return new tr(o, a, function(t, e) {
                return i(t.__brushOption, e);
            }, i).add(t).update(t).remove(function(t) {
                o[t] !== l && s.group.remove(o[t]);
            }).execute(), this;
        },
        unmount: function() {
            return this.enableBrush(!1), Fh(this), this._zr.remove(this.group), this;
        },
        dispose: function() {
            this.unmount(), this.off();
        }
    }, a(kh, Up);
    var dM = {
        mousedown: function(t) {
            if (this._dragging) ou.call(this, t); else if (!t.target || !t.target.draggable) {
                eu(t);
                var e = this.group.transformCoordToLocal(t.offsetX, t.offsetY);
                this._creatingCover = null, (this._creatingPanel = Gh(this, t, e)) && (this._dragging = !0, 
                this._track = [ e.slice() ]);
            }
        },
        mousemove: function(t) {
            var e = this.group.transformCoordToLocal(t.offsetX, t.offsetY);
            if (function(t, e, i) {
                if (t._brushType) {
                    var n = t._zr, a = t._covers, o = Gh(t, e, i);
                    if (!t._dragging) for (var r = 0; r < a.length; r++) {
                        var s = a[r].__brushOption;
                        if (o && (!0 === o || s.panelId === o.panelId) && fM[s.brushType].contain(a[r], i[0], i[1])) return;
                    }
                    o && n.setCursorStyle("crosshair");
                }
            }(this, t, e), this._dragging) {
                eu(t);
                var i = nu(this, t, e, !1);
                i && Hh(this, i);
            }
        },
        mouseup: ou
    }, fM = {
        lineX: ru(0),
        lineY: ru(1),
        rect: {
            createCover: function(t, e) {
                return Uh(JS($h, function(t) {
                    return t;
                }, function(t) {
                    return t;
                }), t, e, [ "w", "e", "n", "s", "se", "sw", "ne", "nw" ]);
            },
            getCreatingRange: function(t) {
                var e = Zh(t);
                return Kh(e[1][0], e[1][1], e[0][0], e[0][1]);
            },
            updateCoverShape: function(t, e, i, n) {
                jh(t, e, i, n);
            },
            updateCommon: Xh,
            contain: iu
        },
        polygon: {
            createCover: function(t, e) {
                var i = new Dg();
                return i.add(new Gv({
                    name: "main",
                    style: qh(e),
                    silent: !0
                })), i;
            },
            getCreatingRange: function(t) {
                return t;
            },
            endCreating: function(t, e) {
                e.remove(e.childAt(0)), e.add(new Vv({
                    name: "main",
                    draggable: !0,
                    drift: JS(Jh, t, e),
                    ondragend: JS(Hh, t, {
                        isEnd: !0
                    })
                }));
            },
            updateCoverShape: function(t, e, i, n) {
                e.childAt(0).setShape({
                    points: tu(t, e, i)
                });
            },
            updateCommon: Xh,
            contain: iu
        }
    }, pM = [ "axisLine", "axisTickLabel", "axisName" ], gM = qo({
        type: "parallelAxis",
        init: function(t, e) {
            gM.superApply(this, "init", arguments), (this._brushController = new kh(e.getZr())).on("brush", _(this._onBrush, this));
        },
        render: function(t, e, i, n) {
            if (p = t, g = e, !(m = n) || "axisAreaSelect" !== m.type || g.findComponents({
                mainType: "parallelAxis",
                query: m
            })[0] !== p) {
                this.axisModel = t, this.api = i, this.group.removeAll();
                var a = this._axisGroup;
                if (this._axisGroup = new Dg(), this.group.add(this._axisGroup), t.get("show")) {
                    var o = (f = t, e.getComponent("parallel", f.get("parallelIndex"))), r = o.coordinateSystem, s = t.getAreaSelectStyle(), l = s.width, h = t.axis.dim, u = P({
                        strokeContainThreshold: l
                    }, r.getAxisLayout(h)), c = new Gw(t, u);
                    R(pM, c.add, c), this._axisGroup.add(c.getGroup()), this._refreshBrushController(u, s, t, o, l, i);
                    var d = n && !1 === n.animation ? null : t;
                    Cn(a, this._axisGroup, d);
                }
            }
            var f, p, g, m;
        },
        _refreshBrushController: function(t, e, i, n, a, o) {
            var r, s, l = i.axis.getExtent(), h = l[1] - l[0], u = Math.min(30, .1 * Math.abs(h)), c = Xt.create({
                x: l[0],
                y: -a / 2,
                width: h,
                height: a
            });
            c.x -= u, c.width += 2 * u, this._brushController.mount({
                enableGlobalPan: !0,
                rotation: t.rotation,
                position: t.position
            }).setPanels([ {
                panelId: "pl",
                clipPath: su(c),
                isTargetByCursor: hu(c, o, n),
                getLinearBrushOtherExtent: lu(c, 0)
            } ]).enableBrush({
                brushType: "lineX",
                brushStyle: e,
                removeOnClick: !0
            }).updateCovers((s = (r = i).axis, L(r.activeIntervals, function(t) {
                return {
                    brushType: "lineX",
                    panelId: "pl",
                    range: [ s.dataToCoord(t[0], !0), s.dataToCoord(t[1], !0) ]
                };
            })));
        },
        _onBrush: function(t, e) {
            var i = this.axisModel, n = i.axis, a = L(t, function(t) {
                return [ n.coordToData(t.range[0], !0), n.coordToData(t.range[1], !0) ];
            });
            (!i.option.realtime === e.isEnd || e.removeOnClick) && this.api.dispatchAction({
                type: "axisAreaSelect",
                parallelAxisId: i.id,
                intervals: a
            });
        },
        dispose: function() {
            this._brushController.dispose();
        }
    });
    qo({
        type: "parallel",
        render: function(t, e, i) {
            this._model = t, this._api = i, this._handlers || (this._handlers = {}, R(mM, function(t, e) {
                i.getZr().on(e, this._handlers[e] = _(t, this));
            }, this)), ro(this, "_throttledDispatchExpand", t.get("axisExpandRate"), "fixRate");
        },
        dispose: function(t, i) {
            R(this._handlers, function(t, e) {
                i.getZr().off(e, t);
            }), this._handlers = null;
        },
        _throttledDispatchExpand: function(t) {
            this._dispatchExpand(t);
        },
        _dispatchExpand: function(t) {
            t && this._api.dispatchAction(P({
                type: "parallelAxisExpand"
            }, t));
        }
    });
    var mM = {
        mousedown: function(t) {
            cu(this, "click") && (this._mouseDownPoint = [ t.offsetX, t.offsetY ]);
        },
        mouseup: function(t) {
            var e = this._mouseDownPoint;
            if (cu(this, "click") && e) {
                var i = [ t.offsetX, t.offsetY ];
                if (5 < Math.pow(e[0] - i[0], 2) + Math.pow(e[1] - i[1], 2)) return;
                var n = this._model.coordinateSystem.getSlidedAxisExpandWindow([ t.offsetX, t.offsetY ]);
                "none" !== n.behavior && this._dispatchExpand({
                    axisExpandWindow: n.axisExpandWindow
                });
            }
            this._mouseDownPoint = null;
        },
        mousemove: function(t) {
            if (!this._mouseDownPoint && cu(this, "mousemove")) {
                var e = this._model, i = e.coordinateSystem.getSlidedAxisExpandWindow([ t.offsetX, t.offsetY ]), n = i.behavior;
                "jump" === n && this._throttledDispatchExpand.debounceNextCall(e.get("axisExpandDebounce")), 
                this._throttledDispatchExpand("none" === n ? null : {
                    axisExpandWindow: i.axisExpandWindow,
                    animation: "jump" === n && null
                });
            }
        }
    };
    Go(function(t) {
        var n;
        (function(t) {
            if (!t.parallel) {
                var e = !1;
                R(t.series, function(t) {
                    t && "parallel" === t.type && (e = !0);
                }), e && (t.parallel = [ {} ]);
            }
        })(t), R(Qe((n = t).parallelAxis), function(t) {
            if (B(t)) {
                var e = t.parallelIndex || 0, i = Qe(n.parallel)[e];
                i && i.parallelAxisDefault && g(t, i.parallelAxisDefault, !1);
            }
        });
    }), px.extend({
        type: "series.parallel",
        dependencies: [ "parallel" ],
        visualColorAccessPath: "lineStyle.color",
        getInitialData: function(t, e) {
            this.option.progressive && (this.option.animation = !1);
            var i = this.getSource();
            return function(t, e) {
                if (!t.encodeDefine) {
                    var i = e.ecModel.getComponent("parallel", e.get("parallelIndex"));
                    if (i) {
                        var n = t.encodeDefine = W();
                        R(i.dimensions, function(t) {
                            var e = +t.replace("dim", "");
                            n.set(t, e);
                        });
                    }
                }
            }(i, this), gr(i, this);
        },
        getRawIndicesByActiveState: function(i) {
            var t = this.coordinateSystem, n = this.getData(), a = [];
            return t.eachActiveState(n, function(t, e) {
                i === t && a.push(n.getRawIndex(e));
            }), a;
        },
        defaultOption: {
            zlevel: 0,
            z: 2,
            coordinateSystem: "parallel",
            parallelIndex: 0,
            label: {
                show: !1
            },
            inactiveOpacity: .05,
            activeOpacity: 1,
            lineStyle: {
                width: 1,
                opacity: .45,
                type: "solid"
            },
            emphasis: {
                label: {
                    show: !1
                }
            },
            progressive: !1,
            smooth: !1,
            animationEasing: "linear"
        }
    }), to.extend({
        type: "parallel",
        init: function() {
            this._dataGroup = new Dg(), this.group.add(this._dataGroup), this._data;
        },
        render: function(t, e, i, n) {
            this._renderForNormal(t, n);
        },
        dispose: function() {},
        _renderForNormal: function(a, o) {
            var t, e, i, n, r, s, l, h, u, c, d, f = this._dataGroup, p = a.getData(), g = this._data, m = a.coordinateSystem, v = m.dimensions, y = a.option.smooth ? .3 : null;
            if (p.diff(g).add(function(t) {
                var e, i, n, a, o;
                i = f, a = du(e = p, n = t, v, m), o = new Gv({
                    shape: {
                        points: a
                    },
                    silent: !0,
                    z2: 10
                }), i.add(o), e.setItemGraphicEl(n, o);
            }).update(function(t, e) {
                var i = g.getItemGraphicEl(e), n = du(p, t, v, m);
                p.setItemGraphicEl(t, i), Mn(i, {
                    shape: {
                        points: n
                    }
                }, o && !1 === o.animation ? null : a, t);
            }).remove(function(t) {
                var e = g.getItemGraphicEl(t);
                f.remove(e);
            }).execute(), u = y, c = (h = p).hostModel.getModel("lineStyle"), d = c.getLineStyle(), 
            h.eachItemGraphicEl(function(t, e) {
                if (h.hasItemOption) {
                    var i = h.getItemModel(e).getModel("lineStyle", c);
                    d = i.getLineStyle([ "color", "stroke" ]);
                }
                t.useStyle(P(d, {
                    fill: null,
                    stroke: h.getItemVisual(e, "color"),
                    opacity: h.getItemVisual(e, "opacity")
                })), t.shape.smooth = u;
            }), !this._data) {
                var x = (e = a, i = function() {
                    setTimeout(function() {
                        f.removeClipPath();
                    });
                }, n = (t = m).model, r = t.getRect(), s = new Wv({
                    shape: {
                        x: r.x,
                        y: r.y,
                        width: r.width,
                        height: r.height
                    }
                }), l = "horizontal" === n.get("layout") ? "width" : "height", s.setShape(l, 0), 
                In(s, {
                    shape: {
                        width: r.width,
                        height: r.height
                    }
                }, e, i), s);
                f.setClipPath(x);
            }
            this._data = p;
        },
        remove: function() {
            this._dataGroup && this._dataGroup.removeAll(), this._data = null;
        }
    });
    var vM = [ "lineStyle", "normal", "opacity" ];
    Uo(function(c) {
        c.eachSeriesByType("parallel", function(t) {
            var e = t.getModel("itemStyle"), i = t.getModel("lineStyle"), n = c.get("color"), a = i.get("color") || e.get("color") || n[t.seriesIndex % n.length], o = t.get("inactiveOpacity"), r = t.get("activeOpacity"), s = t.getModel("lineStyle").getLineStyle(), l = t.coordinateSystem, h = t.getData(), u = {
                normal: s.opacity,
                active: r,
                inactive: o
            };
            l.eachActiveState(h, function(t, e) {
                var i = h.getItemModel(e), n = u[t];
                if ("normal" === t) {
                    var a = i.get(vM, !0);
                    null != a && (n = a);
                }
                h.setItemVisual(e, "opacity", n);
            }), h.setVisual("color", a);
        });
    });
    var yM = px.extend({
        type: "series.sankey",
        layoutInfo: null,
        getInitialData: function(t) {
            var e = t.edges || t.links, i = t.data || t.nodes;
            if (i && e) return xS(i, e, this, !0).data;
        },
        getGraph: function() {
            return this.getData().graph;
        },
        getEdgeData: function() {
            return this.getGraph().edgeData;
        },
        formatTooltip: function(t, e, i) {
            if ("edge" === i) {
                var n = this.getDataParams(t, i), a = n.data, o = a.source + " -- " + a.target;
                return n.value && (o += " : " + n.value), ta(o);
            }
            return yM.superCall(this, "formatTooltip", t, e);
        },
        defaultOption: {
            zlevel: 0,
            z: 2,
            coordinateSystem: "view",
            layout: null,
            left: "5%",
            top: "5%",
            right: "20%",
            bottom: "5%",
            nodeWidth: 20,
            nodeGap: 8,
            layoutIterations: 32,
            label: {
                show: !0,
                position: "right",
                color: "#000",
                fontSize: 12
            },
            itemStyle: {
                borderWidth: 1,
                borderColor: "#333"
            },
            lineStyle: {
                color: "#314656",
                opacity: .2,
                curveness: .5
            },
            emphasis: {
                label: {
                    show: !0
                },
                lineStyle: {
                    opacity: .6
                }
            },
            animationEasing: "linear",
            animationDuration: 1e3
        }
    }), xM = Yi({
        shape: {
            x1: 0,
            y1: 0,
            x2: 0,
            y2: 0,
            cpx1: 0,
            cpy1: 0,
            cpx2: 0,
            cpy2: 0,
            extent: 0
        },
        buildPath: function(t, e) {
            var i = e.extent / 2;
            t.moveTo(e.x1, e.y1 - i), t.bezierCurveTo(e.cpx1, e.cpy1 - i, e.cpx2, e.cpy2 - i, e.x2, e.y2 - i), 
            t.lineTo(e.x2, e.y2 + i), t.bezierCurveTo(e.cpx2, e.cpy2 + i, e.cpx1, e.cpy1 + i, e.x1, e.y1 + i), 
            t.closePath();
        }
    });
    $o({
        type: "sankey",
        _model: null,
        render: function(g, t, e) {
            var i, n, a, o, r = g.getGraph(), m = this.group, s = g.layoutInfo, l = g.getData(), v = g.getData("edge");
            this._model = g, m.removeAll(), m.attr("position", [ s.x, s.y ]), r.eachEdge(function(t) {
                var e = new xM();
                e.dataIndex = t.dataIndex, e.seriesIndex = g.seriesIndex, e.dataType = "edge";
                var i = t.getModel("lineStyle"), n = i.get("curveness"), a = t.node1.getLayout(), o = t.node2.getLayout(), r = t.getLayout();
                e.shape.extent = Math.max(1, r.dy);
                var s = a.x + a.dx, l = a.y + r.sy + r.dy / 2, h = o.x, u = o.y + r.ty + r.dy / 2, c = s * (1 - n) + h * n, d = l, f = s * n + h * (1 - n), p = u;
                switch (e.setShape({
                    x1: s,
                    y1: l,
                    x2: h,
                    y2: u,
                    cpx1: c,
                    cpy1: d,
                    cpx2: f,
                    cpy2: p
                }), e.setStyle(i.getItemStyle()), e.style.fill) {
                  case "source":
                    e.style.fill = t.node1.getVisual("color");
                    break;

                  case "target":
                    e.style.fill = t.node2.getVisual("color");
                }
                gn(e, t.getModel("emphasis.lineStyle").getItemStyle()), m.add(e), v.setItemGraphicEl(t.dataIndex, e);
            }), r.eachNode(function(t) {
                var e = t.getLayout(), i = t.getModel(), n = i.getModel("label"), a = i.getModel("emphasis.label"), o = new Wv({
                    shape: {
                        x: e.x,
                        y: e.y,
                        width: t.getLayout().dx,
                        height: t.getLayout().dy
                    },
                    style: i.getModel("itemStyle").getItemStyle()
                }), r = t.getModel("emphasis.itemStyle").getItemStyle();
                mn(o.style, r, n, a, {
                    labelFetcher: g,
                    labelDataIndex: t.dataIndex,
                    defaultText: t.id,
                    isRectText: !0
                }), o.setStyle("fill", t.getVisual("color")), gn(o, r), m.add(o), l.setItemGraphicEl(t.dataIndex, o), 
                o.dataType = "node";
            }), !this._data && g.get("animation") && m.setClipPath((i = m.getBoundingRect(), 
            n = g, a = function() {
                m.removeClipPath();
            }, In(o = new Wv({
                shape: {
                    x: i.x - 10,
                    y: i.y - 10,
                    width: 0,
                    height: i.height + 20
                }
            }), {
                shape: {
                    width: i.width + 20,
                    height: i.height + 20
                }
            }, n, a), o)), this._data = g.getData();
        },
        dispose: function() {}
    }), Zo(function(t, u, e) {
        t.eachSeriesByType("sankey", function(t) {
            var e, i = t.get("nodeWidth"), n = t.get("nodeGap"), a = (e = u, la(t.getBoxLayoutParams(), {
                width: e.getWidth(),
                height: e.getHeight()
            })), o = (t.layoutInfo = a).width, r = a.height, s = t.getGraph(), l = s.nodes, h = s.edges;
            R(l, function(t) {
                var e = bu(t.outEdges, Tu), i = bu(t.inEdges, Tu), n = Math.max(e, i);
                t.setLayout({
                    value: n
                }, !0);
            }), pu(l, h, i, n, o, r, 0 !== I(l, function(t) {
                return 0 === t.getLayout().value;
            }).length ? 0 : t.get("layoutIterations"));
        });
    }), Uo(function(t, e) {
        t.eachSeriesByType("sankey", function(n) {
            var t = n.getGraph().nodes;
            t.sort(function(t, e) {
                return t.getLayout().value - e.getLayout().value;
            });
            var a = t[0].getLayout().value, o = t[t.length - 1].getLayout().value;
            R(t, function(t) {
                var e = new eS({
                    type: "color",
                    mappingMethod: "linear",
                    dataExtent: [ a, o ],
                    visual: n.get("color")
                }).mapValueToVisual(t.getLayout().value);
                t.setVisual("color", e);
                var i = t.getModel().get("itemStyle.color");
                null != i && t.setVisual("color", i);
            });
        });
    });
    var _M = Wi.extend({
        type: "whiskerInBox",
        shape: {},
        buildPath: function(t, e) {
            for (var i in e) if (e.hasOwnProperty(i) && 0 === i.indexOf("ends")) {
                var n = e[i];
                t.moveTo(n[0][0], n[0][1]), t.lineTo(n[1][0], n[1][1]);
            }
        }
    }), wM = Du.prototype;
    wM._createContent = function(t, e, i) {
        var n = t.getItemLayout(e), a = "horizontal" === n.chartLayout ? 1 : 0, o = 0;
        this.add(new Vv({
            shape: {
                points: i ? Au(n.bodyEnds, a, n) : n.bodyEnds
            },
            style: {
                strokeNoScale: !0
            },
            z2: 100
        })), this.bodyIndex = o++;
        var r = L(n.whiskerEnds, function(t) {
            return i ? Au(t, a, n) : t;
        });
        this.add(new _M({
            shape: Cu(r),
            style: {
                strokeNoScale: !0
            },
            z2: 100
        })), this.whiskerIndex = o++;
    }, wM.updateData = function(t, e, i) {
        var n = this._seriesModel = t.hostModel, a = t.getItemLayout(e), o = iy[i ? "initProps" : "updateProps"];
        o(this.childAt(this.bodyIndex), {
            shape: {
                points: a.bodyEnds
            }
        }, n, e), o(this.childAt(this.whiskerIndex), {
            shape: Cu(a.whiskerEnds)
        }, n, e), this.styleUpdater.call(null, this, t, e);
    }, o(Du, Dg);
    var bM = Lu.prototype;
    bM.updateData = function(n) {
        var a = this.group, o = this._data, r = this.styleUpdater;
        this._data || a.removeAll(), n.diff(o).add(function(t) {
            if (n.hasValue(t)) {
                var e = new Du(n, t, r, !0);
                n.setItemGraphicEl(t, e), a.add(e);
            }
        }).update(function(t, e) {
            var i = o.getItemGraphicEl(e);
            n.hasValue(t) ? (i ? i.updateData(n, t) : i = new Du(n, t, r), a.add(i), n.setItemGraphicEl(t, i)) : a.remove(i);
        }).remove(function(t) {
            var e = o.getItemGraphicEl(t);
            e && a.remove(e);
        }).execute(), this._data = n;
    }, bM.incrementalPrepareUpdate = function(t, e, i) {
        this.group.removeAll(), this._data = null;
    }, bM.incrementalUpdate = function(t, e, i, n) {
        for (var a = e.getData(), o = t.start; o < t.end; o++) {
            var r = new Du(a, o, this.styleUpdater, !0);
            r.incremental = !0, this.group.add(r);
        }
    }, bM.remove = function() {
        var e = this.group, t = this._data;
        this._data = null, t && t.eachItemGraphicEl(function(t) {
            t && e.remove(t);
        });
    };
    var SM = {
        _baseAxisDim: null,
        getInitialData: function(t, e) {
            var i, n, a = e.getComponent("xAxis", this.get("xAxisIndex")), o = e.getComponent("yAxis", this.get("yAxisIndex")), r = a.get("type"), s = o.get("type");
            "category" === r ? (t.layout = "horizontal", i = a.getOrdinalMeta(), n = !0) : "category" === s ? (t.layout = "vertical", 
            i = o.getOrdinalMeta(), n = !0) : t.layout = t.layout || "horizontal";
            var l = [ "x", "y" ], h = "horizontal" === t.layout ? 0 : 1, u = this._baseAxisDim = l[h], c = l[1 - h], d = [ a, o ], f = d[h].get("type"), p = d[1 - h].get("type"), g = t.data;
            if (g && n) {
                var m = [];
                R(g, function(t, e) {
                    var i;
                    t.value && N(t.value) ? (i = t.value.slice(), t.value.unshift(e)) : N(t) ? (i = t.slice(), 
                    t.unshift(e)) : i = t, m.push(i);
                }), t.data = m;
            }
            var v = this.defaultValueDimensions;
            return ob(this, {
                coordDimensions: [ {
                    name: u,
                    type: ir(f),
                    ordinalMeta: i,
                    otherDims: {
                        tooltip: !1,
                        itemName: 0
                    },
                    dimsDef: [ "base" ]
                }, {
                    name: c,
                    type: ir(p),
                    dimsDef: v.slice()
                } ],
                dimensionsCount: v.length + 1
            });
        },
        getBaseAxis: function() {
            var t = this._baseAxisDim;
            return this.ecModel.getComponent(t + "Axis", this.get(t + "AxisIndex")).axis;
        }
    }, MM = {
        init: function() {
            var t = this._whiskerBoxDraw = new Lu(this.getStyleUpdater());
            this.group.add(t.group);
        },
        render: function(t, e, i) {
            this._whiskerBoxDraw.updateData(t.getData());
        },
        incrementalPrepareRender: function(t, e, i) {
            this._whiskerBoxDraw.incrementalPrepareUpdate(t, e, i);
        },
        incrementalRender: function(t, e, i, n) {
            this._whiskerBoxDraw.incrementalUpdate(t, e, i, n);
        },
        remove: function(t) {
            this._whiskerBoxDraw.remove();
        }
    };
    a(px.extend({
        type: "series.boxplot",
        dependencies: [ "xAxis", "yAxis", "grid" ],
        defaultValueDimensions: [ "min", "Q1", "median", "Q3", "max" ],
        dimensions: null,
        defaultOption: {
            zlevel: 0,
            z: 2,
            coordinateSystem: "cartesian2d",
            legendHoverLink: !0,
            hoverAnimation: !0,
            layout: null,
            boxWidth: [ 7, 50 ],
            itemStyle: {
                color: "#fff",
                borderWidth: 1
            },
            emphasis: {
                itemStyle: {
                    borderWidth: 2,
                    shadowBlur: 5,
                    shadowOffsetX: 2,
                    shadowOffsetY: 2,
                    shadowColor: "rgba(0,0,0,0.4)"
                }
            },
            animationEasing: "elasticOut",
            animationDuration: 800
        }
    }), SM, !0), a(to.extend({
        type: "boxplot",
        getStyleUpdater: function() {
            return ku;
        },
        dispose: S
    }), MM, !0);
    var IM = [ "itemStyle" ], TM = [ "emphasis", "itemStyle" ], DM = [ "itemStyle", "borderColor" ], AM = R;
    Uo(function(n, t) {
        var a = n.get("color");
        n.eachRawSeriesByType("boxplot", function(t) {
            var e = a[t.seriesIndex % a.length], i = t.getData();
            i.setVisual({
                legendSymbol: "roundRect",
                color: t.get(DM) || e
            }), n.isSeriesFiltered(t) || i.each(function(t) {
                var e = i.getItemModel(t);
                i.setItemVisual(t, {
                    color: e.get(DM, !0)
                });
            });
        });
    }), Zo(function(t) {
        var n, a, e = (n = [], a = [], t.eachSeriesByType("boxplot", function(t) {
            var e = t.getBaseAxis(), i = C(a, e);
            i < 0 && (i = a.length, a[i] = e, n[i] = {
                axis: e,
                seriesModels: []
            }), n[i].seriesModels.push(t);
        }), n);
        AM(e, function(r) {
            var t = r.seriesModels;
            t.length && (function(t) {
                var e, i, n = t.axis, a = t.seriesModels, o = a.length, r = t.boxWidthList = [], s = t.boxOffsetList = [], l = [];
                if ("category" === n.type) i = n.getBandWidth(); else {
                    var h = 0;
                    AM(a, function(t) {
                        h = Math.max(h, t.getData().count());
                    }), e = n.getExtent(), Math.abs(e[1] - e[0]);
                }
                AM(a, function(t) {
                    var e = t.get("boxWidth");
                    N(e) || (e = [ e, e ]), l.push([ zn(e[0], i) || 0, zn(e[1], i) || 0 ]);
                });
                var u = .8 * i - 2, c = u / o * .3, d = (u - c * (o - 1)) / o, f = d / 2 - u / 2;
                AM(a, function(t, e) {
                    s.push(f), f += c + d, r.push(Math.min(Math.max(d, l[e][0]), l[e][1]));
                });
            }(r), AM(t, function(t, e) {
                var i, c, n, a, d, f, p, g, m, v, o, y;
                i = t, c = r.boxOffsetList[e], n = r.boxWidthList[e], d = i.coordinateSystem, f = i.getData(), 
                p = n / 2, g = i.get("layout"), v = 1 - (m = "horizontal" === g ? 0 : 1), o = [ "x", "y" ], 
                y = [], R(f.dimensions, function(t) {
                    var e = f.getDimensionInfo(t).coordDim;
                    e === o[v] ? y.push(t) : e === o[m] && (a = t);
                }), null == a || y.length < 5 || f.each([ a ].concat(y), function() {
                    function t(t) {
                        var e, i = [];
                        return i[m] = a, i[v] = t, isNaN(a) || isNaN(t) ? e = [ NaN, NaN ] : (e = d.dataToPoint(i))[m] += c, 
                        e;
                    }
                    function e(t, e) {
                        var i = t.slice(), n = t.slice();
                        i[m] += p, n[m] -= p, e ? u.push(i, n) : u.push(n, i);
                    }
                    function i(t) {
                        var e = [ t.slice(), t.slice() ];
                        e[0][m] -= p, e[1][m] += p, h.push(e);
                    }
                    var n = arguments, a = n[0], o = n[y.length + 1], r = t(n[3]), s = t(n[1]), l = t(n[5]), h = [ [ s, t(n[2]) ], [ l, t(n[4]) ] ];
                    i(s), i(l), i(r);
                    var u = [];
                    e(h[0][1], 0), e(h[1][1], 1), f.setItemLayout(o, {
                        chartLayout: g,
                        initBaseline: r[v],
                        median: r,
                        bodyEnds: u,
                        whiskerEnds: h
                    });
                });
            }));
        });
    }), a(px.extend({
        type: "series.candlestick",
        dependencies: [ "xAxis", "yAxis", "grid" ],
        defaultValueDimensions: [ "open", "close", "lowest", "highest" ],
        dimensions: null,
        defaultOption: {
            zlevel: 0,
            z: 2,
            coordinateSystem: "cartesian2d",
            legendHoverLink: !0,
            hoverAnimation: !0,
            layout: null,
            itemStyle: {
                color: "#c23531",
                color0: "#314656",
                borderWidth: 1,
                borderColor: "#c23531",
                borderColor0: "#314656"
            },
            emphasis: {
                itemStyle: {
                    borderWidth: 2
                }
            },
            barMaxWidth: null,
            barMinWidth: null,
            barWidth: null,
            animationUpdate: !1,
            animationEasing: "linear",
            animationDuration: 300
        },
        getShadowDim: function() {
            return "open";
        },
        brushSelector: function(t, e, i) {
            var n = e.getItemLayout(t);
            return i.rect(n.brushRect);
        }
    }), SM, !0), a(to.extend({
        type: "candlestick",
        getStyleUpdater: function() {
            return Pu;
        },
        dispose: S
    }), MM, !0);
    var CM = [ "itemStyle" ], LM = [ "emphasis", "itemStyle" ], kM = [ "itemStyle", "borderColor" ], PM = [ "itemStyle", "borderColor0" ], NM = [ "itemStyle", "color" ], OM = [ "itemStyle", "color0" ], EM = k;
    Go(function(t) {
        t && N(t.series) && R(t.series, function(t) {
            B(t) && "k" === t.type && (t.type = "candlestick");
        });
    }), Uo(function(e, t) {
        e.eachRawSeriesByType("candlestick", function(t) {
            var n = t.getData();
            n.setVisual({
                legendSymbol: "roundRect"
            }), e.isSeriesFiltered(t) || n.each(function(t) {
                var e = n.getItemModel(t), i = n.getItemLayout(t).sign;
                n.setItemVisual(t, {
                    color: e.get(0 < i ? NM : OM),
                    borderColor: e.get(0 < i ? kM : PM)
                });
            });
        });
    }), Zo(function(t) {
        t.eachSeriesByType("candlestick", function(t) {
            var i, e, n, a, o, r, s, l, h, _ = t.coordinateSystem, w = t.getData(), b = (n = w, 
            o = (e = t).getBaseAxis(), r = "category" === o.type ? o.getBandWidth() : (a = o.getExtent(), 
            Math.abs(a[1] - a[0]) / n.count()), s = zn(EM(e.get("barMaxWidth"), r), r), l = zn(EM(e.get("barMinWidth"), 1), r), 
            null != (h = e.get("barWidth")) ? zn(h, r) : Math.max(Math.min(r / 2, s), l)), S = t.get("layout"), M = "horizontal" === S ? 0 : 1, I = 1 - M, u = [ "x", "y" ], T = [];
            if (R(w.dimensions, function(t) {
                var e = w.getDimensionInfo(t).coordDim;
                e === u[I] ? T.push(t) : e === u[M] && (i = t);
            }), !(null == i || T.length < 4)) {
                var D = 0;
                w.each([ i ].concat(T), function() {
                    function t(t) {
                        var e = [];
                        return e[M] = s, e[I] = t, isNaN(s) || isNaN(t) ? [ NaN, NaN ] : _.dataToPoint(e);
                    }
                    function e(t, e) {
                        var i = t.slice(), n = t.slice();
                        i[M] = en(i[M] + b / 2, 1, !1), n[M] = en(n[M] - b / 2, 1, !0), e ? x.push(i, n) : x.push(n, i);
                    }
                    function i(t) {
                        return t[M] = en(t[M], 1), t;
                    }
                    var n, a, o, r = arguments, s = r[0], l = r[T.length + 1], h = r[1], u = r[2], c = r[3], d = r[4], f = Math.min(h, u), p = Math.max(h, u), g = t(f), m = t(p), v = t(c), y = [ [ i(t(d)), i(m) ], [ i(v), i(g) ] ], x = [];
                    e(m, 0), e(g, 1), n = u < h ? -1 : h < u ? 1 : 0 < D ? w.getItemModel(D - 1).get()[2] <= u ? 1 : -1 : 1, 
                    w.setItemLayout(l, {
                        chartLayout: S,
                        sign: n,
                        initBaseline: u < h ? m[I] : g[I],
                        bodyEnds: x,
                        whiskerEnds: y,
                        brushRect: (a = t(Math.min(h, u, c, d)), o = t(Math.max(h, u, c, d)), a[M] -= b / 2, 
                        o[M] -= b / 2, {
                            x: a[0],
                            y: a[1],
                            width: I ? b : o[0] - a[0],
                            height: I ? o[1] - a[1] : b
                        })
                    }), ++D;
                });
            }
        });
    }), px.extend({
        type: "series.effectScatter",
        dependencies: [ "grid", "polar" ],
        getInitialData: function(t, e) {
            return gr(this.getSource(), this);
        },
        brushSelector: "point",
        defaultOption: {
            coordinateSystem: "cartesian2d",
            zlevel: 0,
            z: 2,
            legendHoverLink: !0,
            effectType: "ripple",
            progressive: 0,
            showEffectOn: "render",
            rippleEffect: {
                period: 4,
                scale: 2.5,
                brushType: "fill"
            },
            symbolSize: 10
        }
    });
    var RM = Ou.prototype;
    RM.stopEffectAnimation = function() {
        this.childAt(1).removeAll();
    }, RM.startEffectAnimation = function(t) {
        for (var e = t.symbolType, i = t.color, n = this.childAt(1), a = 0; a < 3; a++) {
            var o = Rr(e, -1, -1, 2, 2, i);
            o.attr({
                style: {
                    strokeNoScale: !0
                },
                z2: 99,
                silent: !0,
                scale: [ .5, .5 ]
            });
            var r = -a / 3 * t.period + t.effectOffset;
            o.animate("", !0).when(t.period, {
                scale: [ t.rippleScale / 2, t.rippleScale / 2 ]
            }).delay(r).start(), o.animateStyle(!0).when(t.period, {
                opacity: 0
            }).delay(r).start(), n.add(o);
        }
        Nu(n, t);
    }, RM.updateEffectAnimation = function(t) {
        for (var e = this._effectCfg, i = this.childAt(1), n = [ "symbolType", "period", "rippleScale" ], a = 0; a < n.length; a++) {
            var o = n[a];
            if (e[o] !== t[o]) return this.stopEffectAnimation(), void this.startEffectAnimation(t);
        }
        Nu(i, t);
    }, RM.highlight = function() {
        this.trigger("emphasis");
    }, RM.downplay = function() {
        this.trigger("normal");
    }, RM.updateData = function(t, e) {
        var i = t.hostModel;
        this.childAt(0).updateData(t, e);
        var n, a = this.childAt(1), o = t.getItemModel(e), r = t.getItemVisual(e, "symbol"), s = (N(n = t.getItemVisual(e, "symbolSize")) || (n = [ +n, +n ]), 
        n), l = t.getItemVisual(e, "color");
        a.attr("scale", s), a.traverse(function(t) {
            t.attr({
                fill: l
            });
        });
        var h = o.getShallow("symbolOffset");
        if (h) {
            var u = a.position;
            u[0] = zn(h[0], s[0]), u[1] = zn(h[1], s[1]);
        }
        a.rotation = (o.getShallow("symbolRotate") || 0) * Math.PI / 180 || 0;
        var c = {};
        if (c.showEffectOn = i.get("showEffectOn"), c.rippleScale = o.get("rippleEffect.scale"), 
        c.brushType = o.get("rippleEffect.brushType"), c.period = 1e3 * o.get("rippleEffect.period"), 
        c.effectOffset = e / t.count(), c.z = o.getShallow("z") || 0, c.zlevel = o.getShallow("zlevel") || 0, 
        c.symbolType = r, c.color = l, this.off("mouseover").off("mouseout").off("emphasis").off("normal"), 
        "render" === c.showEffectOn) this._effectCfg ? this.updateEffectAnimation(c) : this.startEffectAnimation(c), 
        this._effectCfg = c; else {
            this._effectCfg = null, this.stopEffectAnimation();
            var d = this.childAt(0), f = function() {
                d.highlight(), "render" !== c.showEffectOn && this.startEffectAnimation(c);
            }, p = function() {
                d.downplay(), "render" !== c.showEffectOn && this.stopEffectAnimation();
            };
            this.on("mouseover", f, this).on("mouseout", p, this).on("emphasis", f, this).on("normal", p, this);
        }
        this._effectCfg = c;
    }, RM.fadeOut = function(t) {
        this.off("mouseover").off("mouseout").off("emphasis").off("normal"), t && t();
    }, o(Ou, Dg), $o({
        type: "effectScatter",
        init: function() {
            this._symbolDraw = new jr(Ou);
        },
        render: function(t, e, i) {
            var n = t.getData(), a = this._symbolDraw;
            a.updateData(n), this.group.add(a.group);
        },
        updateTransform: function(t, e, i) {
            var n = t.getData();
            this.group.dirty();
            var a = Sw().reset(t);
            a.progress && a.progress({
                start: 0,
                end: n.count()
            }, n), this._symbolDraw.updateLayout(n);
        },
        _updateGroupTransform: function(t) {
            var e = t.coordinateSystem;
            e && e.getRoamTransform && (this.group.transform = pt(e.getRoamTransform()), this.group.decomposeTransform());
        },
        remove: function(t, e) {
            this._symbolDraw && this._symbolDraw.remove(e);
        },
        dispose: function() {}
    }), Uo(bw("effectScatter", "circle")), Zo(Sw("effectScatter"));
    var zM = "undefined" == typeof window ? global : window, BM = zM.Uint32Array || Array, VM = zM.Float64Array || Array, GM = px.extend({
        type: "series.lines",
        dependencies: [ "grid", "polar" ],
        visualColorAccessPath: "lineStyle.color",
        init: function(t) {
            Eu(t);
            var e = this._processFlatCoordsArray(t.data);
            this._flatCoords = e.flatCoords, this._flatCoordsOffset = e.flatCoordsOffset, e.flatCoords && (t.data = new Float32Array(e.count)), 
            GM.superApply(this, "init", arguments);
        },
        mergeOption: function(t) {
            if (Eu(t), t.data) {
                var e = this._processFlatCoordsArray(t.data);
                this._flatCoords = e.flatCoords, this._flatCoordsOffset = e.flatCoordsOffset, e.flatCoords && (t.data = new Float32Array(e.count));
            }
            GM.superApply(this, "mergeOption", arguments);
        },
        appendData: function(t) {
            var e = this._processFlatCoordsArray(t.data);
            e.flatCoords && (this._flatCoords ? (this._flatCoords = i(this._flatCoords, e.flatCoords), 
            this._flatCoordsOffset = i(this._flatCoordsOffset, e.flatCoordsOffset)) : (this._flatCoords = e.flatCoords, 
            this._flatCoordsOffset = e.flatCoordsOffset), t.data = new Float32Array(e.count)), 
            this.getRawData().appendData(t.data);
        },
        _getCoordsFromItemModel: function(t) {
            var e = this.getData().getItemModel(t);
            return e.option instanceof Array ? e.option : e.getShallow("coords");
        },
        getLineCoordsCount: function(t) {
            return this._flatCoordsOffset ? this._flatCoordsOffset[2 * t + 1] : this._getCoordsFromItemModel(t).length;
        },
        getLineCoords: function(t, e) {
            if (this._flatCoordsOffset) {
                for (var i = this._flatCoordsOffset[2 * t], n = this._flatCoordsOffset[2 * t + 1], a = 0; a < n; a++) e[a] = e[a] || [], 
                e[a][0] = this._flatCoords[i + 2 * a], e[a][1] = this._flatCoords[i + 2 * a + 1];
                return n;
            }
            var o = this._getCoordsFromItemModel(t);
            for (a = 0; a < o.length; a++) e[a] = e[a] || [], e[a][0] = o[a][0], e[a][1] = o[a][1];
            return o.length;
        },
        _processFlatCoordsArray: function(t) {
            var e = 0;
            if (this._flatCoords && (e = this._flatCoords.length), "number" == typeof t[0]) {
                for (var i = t.length, n = new BM(i), a = new VM(i), o = 0, r = 0, s = 0, l = 0; l < i; ) {
                    s++;
                    var h = t[l++];
                    n[r++] = o + e, n[r++] = h;
                    for (var u = 0; u < h; u++) {
                        var c = t[l++], d = t[l++];
                        a[o++] = c, a[o++] = d;
                    }
                }
                return {
                    flatCoordsOffset: new Uint32Array(n.buffer, 0, r),
                    flatCoords: a,
                    count: s
                };
            }
            return {
                flatCoordsOffset: null,
                flatCoords: null,
                count: t.length
            };
        },
        getInitialData: function(t, e) {
            var o = new x_([ "value" ], this);
            return o.hasItemOption = !1, o.initData(t.data, [], function(t, e, i, n) {
                if (t instanceof Array) return NaN;
                o.hasItemOption = !0;
                var a = t.value;
                return null != a ? a instanceof Array ? a[n] : a : void 0;
            }), o;
        },
        formatTooltip: function(t) {
            var e = this.getData().getItemModel(t), i = e.get("name");
            if (i) return i;
            var n = e.get("fromName"), a = e.get("toName"), o = [];
            return null != n && o.push(n), null != a && o.push(a), ta(o.join(" > "));
        },
        preventIncremental: function() {
            return !!this.get("effect.show");
        },
        getProgressive: function() {
            var t = this.option.progressive;
            return null == t ? this.option.large ? 1e4 : this.get("progressive") : t;
        },
        getProgressiveThreshold: function() {
            var t = this.option.progressiveThreshold;
            return null == t ? this.option.large ? 2e4 : this.get("progressiveThreshold") : t;
        },
        defaultOption: {
            coordinateSystem: "geo",
            zlevel: 0,
            z: 2,
            legendHoverLink: !0,
            hoverAnimation: !0,
            xAxisIndex: 0,
            yAxisIndex: 0,
            symbol: [ "none", "none" ],
            symbolSize: [ 10, 10 ],
            geoIndex: 0,
            effect: {
                show: !1,
                period: 4,
                constantSpeed: 0,
                symbol: "circle",
                symbolSize: 3,
                loop: !0,
                trailLength: .2
            },
            large: !1,
            largeThreshold: 2e3,
            polyline: !1,
            label: {
                show: !1,
                position: "end"
            },
            lineStyle: {
                opacity: .5
            }
        }
    }), WM = Ru.prototype;
    WM.createLine = function(t, e, i) {
        return new dh(t, e, i);
    }, WM._updateEffectSymbol = function(t, e) {
        var i = t.getItemModel(e).getModel("effect"), n = i.get("symbolSize"), a = i.get("symbol");
        N(n) || (n = [ n, n ]);
        var o = i.get("color") || t.getItemVisual(e, "color"), r = this.childAt(1);
        this._symbolType !== a && (this.remove(r), (r = Rr(a, -.5, -.5, 1, 1, o)).z2 = 100, 
        r.culling = !0, this.add(r)), r && (r.setStyle("shadowColor", o), r.setStyle(i.getItemStyle([ "color" ])), 
        r.attr("scale", n), r.setColor(o), r.attr("scale", n), this._symbolType = a, this._updateEffectAnimation(t, i, e));
    }, WM._updateEffectAnimation = function(e, t, i) {
        var n = this.childAt(1);
        if (n) {
            var a = this, o = e.getItemLayout(i), r = 1e3 * t.get("period"), s = t.get("loop"), l = t.get("constantSpeed"), h = V(t.get("delay"), function(t) {
                return t / e.count() * r / 3;
            }), u = "function" == typeof h;
            if (n.ignore = !0, this.updateAnimationPoints(n, o), 0 < l && (r = this.getLineLength(n) / l * 1e3), 
            r !== this._period || s !== this._loop) {
                n.stopAnimation();
                var c = h;
                u && (c = h(i)), 0 < n.__t && (c = -r * n.__t), n.__t = 0;
                var d = n.animate("", s).when(r, {
                    __t: 1
                }).delay(c).during(function() {
                    a.updateSymbolPosition(n);
                });
                s || d.done(function() {
                    a.remove(n);
                }), d.start();
            }
            this._period = r, this._loop = s;
        }
    }, WM.getLineLength = function(t) {
        return Wp(t.__p1, t.__cp1) + Wp(t.__cp1, t.__p2);
    }, WM.updateAnimationPoints = function(t, e) {
        t.__p1 = e[0], t.__p2 = e[1], t.__cp1 = e[2] || [ (e[0][0] + e[1][0]) / 2, (e[0][1] + e[1][1]) / 2 ];
    }, WM.updateData = function(t, e, i) {
        this.childAt(0).updateData(t, e, i), this._updateEffectSymbol(t, e);
    }, WM.updateSymbolPosition = function(t) {
        var e = t.__p1, i = t.__p2, n = t.__cp1, a = t.__t, o = t.position, r = Si, s = Mi;
        o[0] = r(e[0], n[0], i[0], a), o[1] = r(e[1], n[1], i[1], a);
        var l = s(e[0], n[0], i[0], a), h = s(e[1], n[1], i[1], a);
        t.rotation = -Math.atan2(h, l) - Math.PI / 2, t.ignore = !1;
    }, WM.updateLayout = function(t, e) {
        this.childAt(0).updateLayout(t, e);
        var i = t.getItemModel(e).getModel("effect");
        this._updateEffectAnimation(t, i, e);
    }, o(Ru, Dg);
    var FM = zu.prototype;
    FM._createPolyline = function(t, e, i) {
        var n = t.getItemLayout(e), a = new Gv({
            shape: {
                points: n
            }
        });
        this.add(a), this._updateCommonStl(t, e, i);
    }, FM.updateData = function(t, e, i) {
        var n = t.hostModel;
        Mn(this.childAt(0), {
            shape: {
                points: t.getItemLayout(e)
            }
        }, n, e), this._updateCommonStl(t, e, i);
    }, FM._updateCommonStl = function(t, e, i) {
        var n = this.childAt(0), a = t.getItemModel(e), o = t.getItemVisual(e, "color"), r = i && i.lineStyle, s = i && i.hoverLineStyle;
        i && !t.hasItemOption || (r = a.getModel("lineStyle").getLineStyle(), s = a.getModel("emphasis.lineStyle").getLineStyle()), 
        n.useStyle(E({
            strokeNoScale: !0,
            fill: "none",
            stroke: o
        }, r)), n.hoverStyle = s, gn(this);
    }, FM.updateLayout = function(t, e) {
        this.childAt(0).setShape("points", t.getItemLayout(e));
    }, o(zu, Dg);
    var HM = Bu.prototype;
    HM.createLine = function(t, e, i) {
        return new zu(t, e, i);
    }, HM.updateAnimationPoints = function(t, e) {
        this._points = e;
        for (var i = [ 0 ], n = 0, a = 1; a < e.length; a++) {
            var o = e[a - 1], r = e[a];
            n += Wp(o, r), i.push(n);
        }
        if (0 !== n) {
            for (a = 0; a < i.length; a++) i[a] /= n;
            this._offsets = i, this._length = n;
        }
    }, HM.getLineLength = function(t) {
        return this._length;
    }, HM.updateSymbolPosition = function(t) {
        var e = t.__t, i = this._points, n = this._offsets, a = i.length;
        if (n) {
            var o = this._lastFrame;
            if (e < this._lastFramePercent) {
                for (r = Math.min(o + 1, a - 1); 0 <= r && !(n[r] <= e); r--) ;
                r = Math.min(r, a - 2);
            } else {
                for (var r = o; r < a && !(n[r] > e); r++) ;
                r = Math.min(r - 1, a - 2);
            }
            J(t.position, i[r], i[r + 1], (e - n[r]) / (n[r + 1] - n[r]));
            var s = i[r + 1][0] - i[r][0], l = i[r + 1][1] - i[r][1];
            t.rotation = -Math.atan2(l, s) - Math.PI / 2, this._lastFrame = r, this._lastFramePercent = e, 
            t.ignore = !1;
        }
    }, o(Bu, Ru);
    var ZM = Yi({
        shape: {
            polyline: !1,
            curveness: 0,
            segs: []
        },
        buildPath: function(t, e) {
            var i = e.segs, n = e.curveness;
            if (e.polyline) for (r = 0; r < i.length; ) {
                var a = i[r++];
                if (0 < a) {
                    t.moveTo(i[r++], i[r++]);
                    for (var o = 1; o < a; o++) t.lineTo(i[r++], i[r++]);
                }
            } else for (var r = 0; r < i.length; ) {
                var s = i[r++], l = i[r++], h = i[r++], u = i[r++];
                if (t.moveTo(s, l), 0 < n) {
                    var c = (s + h) / 2 - (l - u) * n, d = (l + u) / 2 - (h - s) * n;
                    t.quadraticCurveTo(c, d, h, u);
                } else t.lineTo(h, u);
            }
        },
        findDataIndex: function(t, e) {
            var i = this.shape, n = i.segs, a = i.curveness;
            if (i.polyline) for (var o = 0, r = 0; r < n.length; ) {
                var s = n[r++];
                if (0 < s) for (var l = n[r++], h = n[r++], u = 1; u < s; u++) if (ki(l, h, c = n[r++], d = n[r++])) return o;
                o++;
            } else for (o = 0, r = 0; r < n.length; ) {
                l = n[r++], h = n[r++];
                var c = n[r++], d = n[r++];
                if (0 < a) {
                    if (Ni(l, h, (l + c) / 2 - (h - d) * a, (h + d) / 2 - (c - l) * a, c, d)) return o;
                } else if (ki(l, h, c, d)) return o;
                o++;
            }
            return -1;
        }
    }), UM = Vu.prototype;
    UM.isPersistent = function() {
        return !this._incremental;
    }, UM.updateData = function(t) {
        this.group.removeAll();
        var e = new ZM({
            rectHover: !0,
            cursor: "default"
        });
        e.setShape({
            segs: t.getLayout("linesPoints")
        }), this._setCommon(e, t), this.group.add(e), this._incremental = null;
    }, UM.incrementalPrepareUpdate = function(t) {
        this.group.removeAll(), this._clearIncremental(), 5e5 < t.count() ? (this._incremental || (this._incremental = new Xi({
            silent: !0
        })), this.group.add(this._incremental)) : this._incremental = null;
    }, UM.incrementalUpdate = function(t, e) {
        var i = new ZM();
        i.setShape({
            segs: e.getLayout("linesPoints")
        }), this._setCommon(i, e, !!this._incremental), this._incremental ? this._incremental.addDisplayable(i, !0) : (i.rectHover = !0, 
        i.cursor = "default", i.__startIndex = t.start, this.group.add(i));
    }, UM.remove = function() {
        this._clearIncremental(), this._incremental = null, this.group.removeAll();
    }, UM._setCommon = function(i, t, e) {
        var n = t.hostModel;
        i.setShape({
            polyline: n.get("polyline"),
            curveness: n.get("lineStyle.curveness")
        }), i.useStyle(n.getModel("lineStyle").getLineStyle()), i.style.strokeNoScale = !0;
        var a = t.getVisual("color");
        a && i.setStyle("stroke", a), i.setStyle("fill"), e || (i.seriesIndex = n.seriesIndex, 
        i.on("mousemove", function(t) {
            i.dataIndex = null;
            var e = i.findDataIndex(t.offsetX, t.offsetY);
            0 < e && (i.dataIndex = e + i.__startIndex);
        }));
    }, UM._clearIncremental = function() {
        var t = this._incremental;
        t && t.clearDisplaybles();
    };
    var jM = {
        seriesType: "lines",
        plan: vx(),
        reset: function(g) {
            var m = g.coordinateSystem, v = g.get("polyline"), y = g.pipelineContext.large;
            return {
                progress: function(t, e) {
                    var i = [];
                    if (y) {
                        var n, a = t.end - t.start;
                        if (v) {
                            for (var o = 0, r = t.start; r < t.end; r++) o += g.getLineCoordsCount(r);
                            n = new Float32Array(a + 2 * o);
                        } else n = new Float32Array(2 * a);
                        var s = 0, l = [];
                        for (r = t.start; r < t.end; r++) {
                            c = g.getLineCoords(r, i), v && (n[s++] = c);
                            for (var h = 0; h < c; h++) l = m.dataToPoint(i[h], !1, l), n[s++] = l[0], n[s++] = l[1];
                        }
                        e.setLayout("linesPoints", n);
                    } else for (r = t.start; r < t.end; r++) {
                        var u = e.getItemModel(r), c = g.getLineCoords(r, i), d = [];
                        if (v) for (var f = 0; f < c; f++) d.push(m.dataToPoint(i[f])); else {
                            d[0] = m.dataToPoint(i[0]), d[1] = m.dataToPoint(i[1]);
                            var p = u.get("lineStyle.curveness");
                            +p && (d[2] = [ (d[0][0] + d[1][0]) / 2 - (d[0][1] - d[1][1]) * p, (d[0][1] + d[1][1]) / 2 - (d[1][0] - d[0][0]) * p ]);
                        }
                        e.setItemLayout(r, d);
                    }
                }
            };
        }
    };
    $o({
        type: "lines",
        init: function() {},
        render: function(t, e, i) {
            var n = t.getData(), a = this._updateLineDraw(n, t), o = t.get("zlevel"), r = t.get("effect.trailLength"), s = i.getZr(), l = "svg" === s.painter.getType();
            l || s.painter.getLayer(o).clear(!0), null == this._lastZlevel || l || s.configLayer(this._lastZlevel, {
                motionBlur: !1
            }), this._showEffect(t) && r && (l || s.configLayer(o, {
                motionBlur: !0,
                lastFrameAlpha: Math.max(Math.min(r / 10 + .9, 1), 0)
            })), a.updateData(n), this._lastZlevel = o, this._finished = !0;
        },
        incrementalPrepareRender: function(t, e, i) {
            var n = t.getData();
            this._updateLineDraw(n, t).incrementalPrepareUpdate(n), this._clearLayer(i), this._finished = !1;
        },
        incrementalRender: function(t, e, i) {
            this._lineDraw.incrementalUpdate(t, e.getData()), this._finished = t.end === e.getData().count();
        },
        updateTransform: function(t, e, i) {
            var n = t.getData();
            if (!this._finished || t.pipelineContext.large) return {
                update: !0
            };
            var a = jM.reset(t);
            a.progress && a.progress({
                start: 0,
                end: n.count()
            }, n), this._lineDraw.updateLayout(), this._clearLayer(i);
        },
        _updateLineDraw: function(t, e) {
            var i = this._lineDraw, n = this._showEffect(e), a = !!e.get("polyline"), o = e.pipelineContext.large;
            return i && n === this._hasEffet && a === this._isPolyline && o === this._isLargeDraw || (i && i.remove(), 
            i = this._lineDraw = o ? new Vu() : new fh(a ? n ? Bu : zu : n ? Ru : dh), this._hasEffet = n, 
            this._isPolyline = a, this._isLargeDraw = o, this.group.removeAll()), this.group.add(i.group), 
            i;
        },
        _showEffect: function(t) {
            return !!t.get("effect.show");
        },
        _clearLayer: function(t) {
            var e = t.getZr();
            "svg" === e.painter.getType() || null == this._lastZlevel || e.painter.getLayer(this._lastZlevel).clear(!0);
        },
        remove: function(t, e) {
            this._lineDraw && this._lineDraw.remove(), this._lineDraw = null, this._clearLayer(e);
        },
        dispose: function() {}
    });
    var XM = "lineStyle.opacity".split("."), YM = {
        seriesType: "lines",
        reset: function(t, e, i) {
            var n = Gu(t.get("symbol")), a = Gu(t.get("symbolSize")), o = t.getData();
            return o.setVisual("fromSymbol", n && n[0]), o.setVisual("toSymbol", n && n[1]), 
            o.setVisual("fromSymbolSize", a && a[0]), o.setVisual("toSymbolSize", a && a[1]), 
            o.setVisual("opacity", t.get(XM)), {
                dataEach: o.hasItemOption ? function(t, e) {
                    var i = t.getItemModel(e), n = Gu(i.getShallow("symbol", !0)), a = Gu(i.getShallow("symbolSize", !0)), o = i.get(XM);
                    n[0] && t.setItemVisual(e, "fromSymbol", n[0]), n[1] && t.setItemVisual(e, "toSymbol", n[1]), 
                    a[0] && t.setItemVisual(e, "fromSymbolSize", a[0]), a[1] && t.setItemVisual(e, "toSymbolSize", a[1]), 
                    t.setItemVisual(e, "opacity", o);
                } : null
            };
        }
    };
    Zo(jM), Uo(YM), px.extend({
        type: "series.heatmap",
        getInitialData: function(t, e) {
            return gr(this.getSource(), this, {
                generateCoord: "value"
            });
        },
        preventIncremental: function() {
            var t = Ma.get(this.get("coordinateSystem"));
            if (t && t.dimensions) return "lng" === t.dimensions[0] && "lat" === t.dimensions[1];
        },
        defaultOption: {
            coordinateSystem: "cartesian2d",
            zlevel: 0,
            z: 2,
            geoIndex: 0,
            blurSize: 30,
            pointSize: 20,
            maxOpacity: 1,
            minOpacity: 0
        }
    }), Wu.prototype = {
        update: function(t, e, i, n, a, o) {
            var r = this._getBrush(), s = this._getGradient(t, a, "inRange"), l = this._getGradient(t, a, "outOfRange"), h = this.pointSize + this.blurSize, u = this.canvas, c = u.getContext("2d"), d = t.length;
            u.width = e, u.height = i;
            for (var f = 0; f < d; ++f) {
                var p = t[f], g = p[0], m = p[1], v = n(p[2]);
                c.globalAlpha = v, c.drawImage(r, g - h, m - h);
            }
            if (!u.width || !u.height) return u;
            for (var y = c.getImageData(0, 0, u.width, u.height), x = y.data, _ = 0, w = x.length, b = this.minOpacity, S = this.maxOpacity - b; _ < w; ) {
                v = x[_ + 3] / 256;
                var M = 4 * Math.floor(255 * v);
                if (0 < v) {
                    var I = o(v) ? s : l;
                    0 < v && (v = v * S + b), x[_++] = I[M], x[_++] = I[M + 1], x[_++] = I[M + 2], x[_++] = I[M + 3] * v * 256;
                } else _ += 4;
            }
            return c.putImageData(y, 0, 0), u;
        },
        _getBrush: function() {
            var t = this._brushCanvas || (this._brushCanvas = Op()), e = this.pointSize + this.blurSize, i = 2 * e;
            t.width = i, t.height = i;
            var n = t.getContext("2d");
            return n.clearRect(0, 0, i, i), n.shadowOffsetX = i, n.shadowBlur = this.blurSize, 
            n.shadowColor = "#000", n.beginPath(), n.arc(-e, e, this.pointSize, 0, 2 * Math.PI, !0), 
            n.closePath(), n.fill(), t;
        },
        _getGradient: function(t, e, i) {
            for (var n = this._gradientPixels, a = n[i] || (n[i] = new Uint8ClampedArray(1024)), o = [ 0, 0, 0, 0 ], r = 0, s = 0; s < 256; s++) e[i](s / 255, !0, o), 
            a[r++] = o[0], a[r++] = o[1], a[r++] = o[2], a[r++] = o[3];
            return a;
        }
    }, $o({
        type: "heatmap",
        render: function(i, t, e) {
            var n;
            t.eachComponent("visualMap", function(e) {
                e.eachTargetSeries(function(t) {
                    t === i && (n = e);
                });
            }), this.group.removeAll(), this._incrementalDisplayable = null;
            var a, o = i.coordinateSystem;
            "cartesian2d" === o.type || "calendar" === o.type ? this._renderOnCartesianAndCalendar(i, e, 0, i.getData().count()) : "lng" === (a = o.dimensions)[0] && "lat" === a[1] && this._renderOnGeo(o, i, n, e);
        },
        incrementalPrepareRender: function(t, e, i) {
            this.group.removeAll();
        },
        incrementalRender: function(t, e, i, n) {
            e.coordinateSystem && this._renderOnCartesianAndCalendar(e, n, t.start, t.end, !0);
        },
        _renderOnCartesianAndCalendar: function(t, e, i, n, a) {
            var o, r, s = t.coordinateSystem;
            if ("cartesian2d" === s.type) {
                var l = s.getAxis("x"), h = s.getAxis("y");
                o = l.getBandWidth(), r = h.getBandWidth();
            }
            for (var u = this.group, c = t.getData(), d = t.getModel("itemStyle").getItemStyle([ "color" ]), f = t.getModel("emphasis.itemStyle").getItemStyle(), p = t.getModel("label"), g = t.getModel("emphasis.label"), m = s.type, v = "cartesian2d" === m ? [ c.mapDimension("x"), c.mapDimension("y"), c.mapDimension("value") ] : [ c.mapDimension("time"), c.mapDimension("value") ], y = i; y < n; y++) {
                var x;
                if ("cartesian2d" === m) {
                    if (isNaN(c.get(v[2], y))) continue;
                    var _ = s.dataToPoint([ c.get(v[0], y), c.get(v[1], y) ]);
                    x = new Wv({
                        shape: {
                            x: _[0] - o / 2,
                            y: _[1] - r / 2,
                            width: o,
                            height: r
                        },
                        style: {
                            fill: c.getItemVisual(y, "color"),
                            opacity: c.getItemVisual(y, "opacity")
                        }
                    });
                } else {
                    if (isNaN(c.get(v[1], y))) continue;
                    x = new Wv({
                        z2: 1,
                        shape: s.dataToRect([ c.get(v[0], y) ]).contentShape,
                        style: {
                            fill: c.getItemVisual(y, "color"),
                            opacity: c.getItemVisual(y, "opacity")
                        }
                    });
                }
                var w = c.getItemModel(y);
                c.hasItemOption && (d = w.getModel("itemStyle").getItemStyle([ "color" ]), f = w.getModel("emphasis.itemStyle").getItemStyle(), 
                p = w.getModel("label"), g = w.getModel("emphasis.label"));
                var b = t.getRawValue(y), S = "-";
                b && null != b[2] && (S = b[2]), mn(d, f, p, g, {
                    labelFetcher: t,
                    labelDataIndex: y,
                    defaultText: S,
                    isRectText: !0
                }), x.setStyle(d), gn(x, c.hasItemOption ? f : P({}, f)), (x.incremental = a) && (x.useHoverLayer = !0), 
                u.add(x), c.setItemGraphicEl(y, x);
            }
        },
        _renderOnGeo: function(a, t, e, i) {
            var n = e.targetVisuals.inRange, o = e.targetVisuals.outOfRange, r = t.getData(), s = this._hmLayer || this._hmLayer || new Wu();
            s.blurSize = t.get("blurSize"), s.pointSize = t.get("pointSize"), s.minOpacity = t.get("minOpacity"), 
            s.maxOpacity = t.get("maxOpacity");
            var l = a.getViewRect().clone(), h = a.getRoamTransform();
            l.applyTransform(h);
            var u, c, d, f, p, g, m, v, y, x = Math.max(l.x, 0), _ = Math.max(l.y, 0), w = Math.min(l.width + l.x, i.getWidth()), b = Math.min(l.height + l.y, i.getHeight()), S = w - x, M = b - _, I = [ r.mapDimension("lng"), r.mapDimension("lat"), r.mapDimension("value") ], T = r.mapArray(I, function(t, e, i) {
                var n = a.dataToPoint([ t, e ]);
                return n[0] -= x, n[1] -= _, n.push(i), n;
            }), D = e.getExtent(), A = "visualMap.continuous" === e.type ? (m = D, v = e.option.range, 
            y = m[1] - m[0], v = [ (v[0] - m[0]) / y, (v[1] - m[0]) / y ], function(t) {
                return t >= v[0] && t <= v[1];
            }) : (u = D, c = e.getPieceList(), d = e.option.selected, f = u[1] - u[0], p = (c = L(c, function(t) {
                return {
                    interval: [ (t.interval[0] - u[0]) / f, (t.interval[1] - u[0]) / f ]
                };
            })).length, g = 0, function(t) {
                for (e = g; e < p; e++) if ((i = c[e].interval)[0] <= t && t <= i[1]) {
                    g = e;
                    break;
                }
                if (e === p) for (var e = g - 1; 0 <= e; e--) {
                    var i = c[e].interval;
                    if (i[0] <= t && t <= i[1]) {
                        g = e;
                        break;
                    }
                }
                return 0 <= e && e < p && d[e];
            });
            s.update(T, S, M, n.color.getNormalizer(), {
                inRange: n.color.getColorMapper(),
                outOfRange: o.color.getColorMapper()
            }, A);
            var C = new Be({
                style: {
                    width: S,
                    height: M,
                    x: x,
                    y: _,
                    image: s.canvas
                },
                silent: !0
            });
            this.group.add(C);
        },
        dispose: function() {}
    });
    var qM = tb.extend({
        type: "series.pictorialBar",
        dependencies: [ "grid" ],
        defaultOption: {
            symbol: "circle",
            symbolSize: null,
            symbolRotate: null,
            symbolPosition: null,
            symbolOffset: null,
            symbolMargin: null,
            symbolRepeat: !1,
            symbolRepeatDirection: "end",
            symbolClip: !1,
            symbolBoundingData: null,
            symbolPatternSize: 400,
            barGap: "-100%",
            progressive: 0,
            hoverAnimation: !1
        },
        getInitialData: function(t) {
            return t.stack = null, qM.superApply(this, "getInitialData", arguments);
        }
    }), KM = [ "itemStyle", "borderWidth" ], $M = [ {
        xy: "x",
        wh: "width",
        index: 0,
        posDesc: [ "left", "right" ]
    }, {
        xy: "y",
        wh: "height",
        index: 1,
        posDesc: [ "top", "bottom" ]
    } ], JM = new Ov();
    $o({
        type: "pictorialBar",
        render: function(t, e, i) {
            var c = this.group, d = t.getData(), f = this._data, n = t.coordinateSystem, a = !!n.getBaseAxis().isHorizontal(), o = n.grid.getRect(), p = {
                ecSize: {
                    width: i.getWidth(),
                    height: i.getHeight()
                },
                seriesModel: t,
                coordSys: n,
                coordSysExtent: [ [ o.x, o.x + o.width ], [ o.y, o.y + o.height ] ],
                isHorizontal: a,
                valueDim: $M[+a],
                categoryDim: $M[1 - a]
            };
            return d.diff(f).add(function(t) {
                if (d.hasValue(t)) {
                    var e = qu(d, t), i = Fu(d, t, e, p), n = Qu(d, p, i);
                    d.setItemGraphicEl(t, n), c.add(n), ac(n, p, i);
                }
            }).update(function(t, e) {
                var i, n, a, o, r, s = f.getItemGraphicEl(e);
                if (d.hasValue(t)) {
                    var l = qu(d, t), h = Fu(d, t, l, p), u = ec(d, h);
                    s && u !== s.__pictorialShapeStr && (c.remove(s), d.setItemGraphicEl(t, null), s = null), 
                    s ? (i = s, n = p, o = (a = h).animationModel, r = a.dataIndex, Mn(i.__pictorialBundle, {
                        position: a.bundlePosition.slice()
                    }, o, r), a.symbolRepeat ? Uu(i, n, a, !0) : ju(i, 0, a, !0), Xu(i, a, !0), Yu(i, n, a, !0)) : s = Qu(d, p, h, !0), 
                    d.setItemGraphicEl(t, s), s.__pictorialSymbolMeta = h, c.add(s), ac(s, p, h);
                } else c.remove(s);
            }).remove(function(t) {
                var e = f.getItemGraphicEl(t);
                e && tc(f, t, e.__pictorialSymbolMeta.animationModel, e);
            }).execute(), this._data = d, this.group;
        },
        dispose: S,
        remove: function(e, t) {
            var i = this.group, n = this._data;
            e.get("animation") ? n && n.eachItemGraphicEl(function(t) {
                tc(n, t.dataIndex, e, t);
            }) : i.removeAll();
        }
    }), Zo(z(Dr, "pictorialBar")), Uo(bw("pictorialBar", "roundRect"));
    var QM = function(t, e, i, n, a) {
        aw.call(this, t, e, i), this.type = n || "value", this.position = a || "bottom", 
        this.orient = null, this._labelInterval = null;
    };
    QM.prototype = {
        constructor: QM,
        model: null,
        isHorizontal: function() {
            var t = this.position;
            return "top" === t || "bottom" === t;
        },
        pointToData: function(t, e) {
            return this.coordinateSystem.pointToData(t, e)[0];
        },
        toGlobalCoord: null,
        toLocalCoord: null
    }, o(QM, aw), Ma.register("single", {
        create: function(n, a) {
            var o = [];
            return n.eachComponent("singleAxis", function(t, e) {
                var i = new rc(t, n, a);
                i.name = "single_" + e, i.resize(t, a), t.coordinateSystem = i, o.push(i);
            }), n.eachSeries(function(t) {
                if ("singleAxis" === t.get("coordinateSystem")) {
                    var e = n.queryComponents({
                        mainType: "singleAxis",
                        index: t.get("singleAxisIndex"),
                        id: t.get("singleAxisId")
                    })[0];
                    t.coordinateSystem = e && e.coordinateSystem;
                }
            }), o;
        },
        dimensions: (rc.prototype = {
            type: "singleAxis",
            axisPointerEnabled: !0,
            constructor: rc,
            _init: function(t, e, i) {
                var n = this.dimension, a = new QM(n, kr(t), [ 0, 0 ], t.get("type"), t.get("position")), o = "category" === a.type;
                a.onBand = o && t.get("boundaryGap"), a.inverse = t.get("inverse"), a.orient = t.get("orient"), 
                (t.axis = a).model = t, (a.coordinateSystem = this)._axis = a;
            },
            update: function(t, e) {
                t.eachSeries(function(t) {
                    if (t.coordinateSystem === this) {
                        var e = t.getData();
                        R(e.mapDimension(this.dimension, !0), function(t) {
                            this._axis.scale.unionExtentFromData(e, t);
                        }, this), Lr(this._axis.scale, this._axis.model);
                    }
                }, this);
            },
            resize: function(t, e) {
                this._rect = la({
                    left: t.get("left"),
                    top: t.get("top"),
                    right: t.get("right"),
                    bottom: t.get("bottom"),
                    width: t.get("width"),
                    height: t.get("height")
                }, {
                    width: e.getWidth(),
                    height: e.getHeight()
                }), this._adjustAxis();
            },
            getRect: function() {
                return this._rect;
            },
            _adjustAxis: function() {
                var t = this._rect, e = this._axis, i = e.isHorizontal(), n = i ? [ 0, t.width ] : [ 0, t.height ], a = e.reverse ? 1 : 0;
                e.setExtent(n[a], n[1 - a]), this._updateAxisTransform(e, i ? t.x : t.y);
            },
            _updateAxisTransform: function(t, e) {
                var i = t.getExtent(), n = i[0] + i[1], a = t.isHorizontal();
                t.toGlobalCoord = a ? function(t) {
                    return t + e;
                } : function(t) {
                    return n - t + e;
                }, t.toLocalCoord = a ? function(t) {
                    return t - e;
                } : function(t) {
                    return n - t + e;
                };
            },
            getAxis: function() {
                return this._axis;
            },
            getBaseAxis: function() {
                return this._axis;
            },
            getAxes: function() {
                return [ this._axis ];
            },
            getTooltipAxes: function() {
                return {
                    baseAxes: [ this.getAxis() ]
                };
            },
            containPoint: function(t) {
                var e = this.getRect(), i = this.getAxis();
                return "horizontal" === i.orient ? i.contain(i.toLocalCoord(t[0])) && t[1] >= e.y && t[1] <= e.y + e.height : i.contain(i.toLocalCoord(t[1])) && t[0] >= e.y && t[0] <= e.y + e.height;
            },
            pointToData: function(t) {
                var e = this.getAxis();
                return [ e.coordToData(e.toLocalCoord(t["horizontal" === e.orient ? 0 : 1])) ];
            },
            dataToPoint: function(t) {
                var e = this.getAxis(), i = this.getRect(), n = [], a = "horizontal" === e.orient ? 0 : 1;
                return t instanceof Array && (t = t[0]), n[a] = e.toGlobalCoord(e.dataToCoord(+t)), 
                n[1 - a] = 0 === a ? i.y + i.height / 2 : i.x + i.width / 2, n;
            }
        }).dimensions
    });
    var tI = Gw.getInterval, eI = Gw.ifIgnoreOnTick, iI = [ "axisLine", "axisTickLabel", "axisName" ], nI = Xw.extend({
        type: "singleAxis",
        axisPointerClass: "SingleAxisPointer",
        render: function(t, e, i, n) {
            var a = this.group;
            a.removeAll();
            var o = sc(t), r = new Gw(t, o);
            R(iI, r.add, r), a.add(r.getGroup()), t.get("splitLine.show") && this._splitLine(t, o.labelInterval), 
            nI.superCall(this, "render", t, e, i, n);
        },
        _splitLine: function(t, e) {
            var i = t.axis;
            if (!i.scale.isBlank()) {
                var n = t.getModel("splitLine"), a = n.getModel("lineStyle"), o = a.get("width"), r = a.get("color"), s = tI(n, e);
                r = r instanceof Array ? r : [ r ];
                for (var l = t.coordinateSystem.getRect(), h = i.isHorizontal(), u = [], c = 0, d = i.getTicksCoords(), f = [], p = [], g = t.get("axisLabel.showMinLabel"), m = t.get("axisLabel.showMaxLabel"), v = 0; v < d.length; ++v) if (!eI(i, v, s, d.length, g, m)) {
                    var y = i.toGlobalCoord(d[v]);
                    h ? (f[0] = y, f[1] = l.y, p[0] = y, p[1] = l.y + l.height) : (f[0] = l.x, f[1] = y, 
                    p[0] = l.x + l.width, p[1] = y);
                    var x = c++ % r.length;
                    u[x] = u[x] || [], u[x].push(new Fv(Qi({
                        shape: {
                            x1: f[0],
                            y1: f[1],
                            x2: p[0],
                            y2: p[1]
                        },
                        style: {
                            lineWidth: o
                        },
                        silent: !0
                    })));
                }
                for (v = 0; v < u.length; ++v) this.group.add(ey(u[v], {
                    style: {
                        stroke: r[v % r.length],
                        lineDash: a.getLineDash(o),
                        lineWidth: o
                    },
                    silent: !0
                }));
            }
        }
    }), aI = Cy.extend({
        type: "singleAxis",
        layoutMode: "box",
        axis: null,
        coordinateSystem: null,
        getCoordSysModel: function() {
            return this;
        }
    });
    g(aI.prototype, Z_), kw("single", aI, function(t, e) {
        return e.type || (e.data ? "category" : "value");
    }, {
        left: "5%",
        top: "5%",
        right: "5%",
        bottom: "5%",
        type: "value",
        position: "bottom",
        orient: "horizontal",
        axisLine: {
            show: !0,
            lineStyle: {
                width: 2,
                type: "solid"
            }
        },
        tooltip: {
            show: !0
        },
        axisTick: {
            show: !0,
            length: 6,
            lineStyle: {
                width: 2
            }
        },
        axisLabel: {
            show: !0,
            interval: "auto"
        },
        splitLine: {
            show: !0,
            lineStyle: {
                type: "dashed",
                opacity: .2
            }
        }
    });
    var oI = function(t, e) {
        var i, n = [], a = t.seriesIndex;
        if (null == a || !(i = e.getSeriesByIndex(a))) return {
            point: []
        };
        var o = i.getData(), r = ri(o, t);
        if (null == r || r < 0 || N(r)) return {
            point: []
        };
        var s = o.getItemGraphicEl(r), l = i.coordinateSystem;
        if (i.getTooltipPosition) n = i.getTooltipPosition(r) || []; else if (l && l.dataToPoint) n = l.dataToPoint(o.getValues(L(l.dimensions, function(t) {
            return o.mapDimension(t);
        }), r, !0)) || []; else if (s) {
            var h = s.getBoundingRect().clone();
            h.applyTransform(s.transform), n = [ h.x + h.width / 2, h.y + h.height / 2 ];
        }
        return {
            point: n,
            el: s
        };
    }, rI = R, sI = z, lI = si(), hI = (Yo({
        type: "axisPointer",
        coordSysAxesInfo: null,
        defaultOption: {
            show: "auto",
            triggerOn: null,
            zlevel: 0,
            z: 50,
            type: "line",
            snap: !1,
            triggerTooltip: !0,
            value: null,
            status: null,
            link: [],
            animation: null,
            animationDurationUpdate: 200,
            lineStyle: {
                color: "#aaa",
                width: 1,
                type: "solid"
            },
            shadowStyle: {
                color: "rgba(150,150,150,0.3)"
            },
            label: {
                show: !0,
                formatter: null,
                precision: "auto",
                margin: 3,
                color: "#fff",
                padding: [ 5, 7, 5, 7 ],
                backgroundColor: "auto",
                borderColor: null,
                borderWidth: 0,
                shadowBlur: 3,
                shadowColor: "#aaa"
            },
            handle: {
                show: !1,
                icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z",
                size: 45,
                margin: 50,
                color: "#333",
                shadowBlur: 3,
                shadowColor: "#aaa",
                shadowOffsetX: 0,
                shadowOffsetY: 2,
                throttle: 40
            }
        }
    }), si()), uI = R, cI = qo({
        type: "axisPointer",
        render: function(t, e, i) {
            var n = e.getComponent("tooltip"), a = t.get("triggerOn") || n && n.get("triggerOn") || "mousemove|click";
            fc("axisPointer", i, function(t, e, i) {
                "none" !== a && ("leave" === t || 0 <= a.indexOf(t)) && i({
                    type: "updateAxisPointer",
                    currTrigger: t,
                    x: e && e.offsetX,
                    y: e && e.offsetY
                });
            });
        },
        remove: function(t, e) {
            mc(e.getZr(), "axisPointer"), cI.superApply(this._model, "remove", arguments);
        },
        dispose: function(t, e) {
            mc("axisPointer", e), cI.superApply(this._model, "dispose", arguments);
        }
    }), dI = si(), fI = A, pI = _;
    di((vc.prototype = {
        _group: null,
        _lastGraphicKey: null,
        _handle: null,
        _dragging: !1,
        _lastValue: null,
        _lastStatus: null,
        _payloadInfo: null,
        animationThreshold: 15,
        render: function(t, e, i, n) {
            var a = e.get("value"), o = e.get("status");
            if (this._axisModel = t, this._axisPointerModel = e, this._api = i, n || this._lastValue !== a || this._lastStatus !== o) {
                this._lastValue = a, this._lastStatus = o;
                var r = this._group, s = this._handle;
                if (!o || "hide" === o) return r && r.hide(), void (s && s.hide());
                r && r.show(), s && s.show();
                var l = {};
                this.makeElOption(l, a, t, e, i);
                var h = l.graphicKey;
                h !== this._lastGraphicKey && this.clear(i), this._lastGraphicKey = h;
                var u = this._moveAnimation = this.determineAnimation(t, e);
                if (r) {
                    var c = z(yc, e, u);
                    this.updatePointerEl(r, l, c, e), this.updateLabelEl(r, l, c, e);
                } else r = this._group = new Dg(), this.createPointerEl(r, l, t, e), this.createLabelEl(r, l, t, e), 
                i.getZr().add(r);
                wc(r, e, !0), this._renderHandle(a);
            }
        },
        remove: function(t) {
            this.clear(t);
        },
        dispose: function(t) {
            this.clear(t);
        },
        determineAnimation: function(t, e) {
            var i = e.get("animation"), n = t.axis, a = "category" === n.type, o = e.get("snap");
            if (!o && !a) return !1;
            if ("auto" === i || null == i) {
                var r = this.animationThreshold;
                if (a && n.getBandWidth() > r) return !0;
                if (o) {
                    var s = Is(t).seriesDataCount, l = n.getExtent();
                    return Math.abs(l[0] - l[1]) / s > r;
                }
                return !1;
            }
            return !0 === i;
        },
        makeElOption: function(t, e, i, n, a) {},
        createPointerEl: function(t, e, i, n) {
            var a = e.pointer;
            if (a) {
                var o = dI(t).pointerEl = new iy[a.type](fI(e.pointer));
                t.add(o);
            }
        },
        createLabelEl: function(t, e, i, n) {
            if (e.label) {
                var a = dI(t).labelEl = new Wv(fI(e.label));
                t.add(a), xc(a, n);
            }
        },
        updatePointerEl: function(t, e, i) {
            var n = dI(t).pointerEl;
            n && (n.setStyle(e.pointer.style), i(n, {
                shape: e.pointer.shape
            }));
        },
        updateLabelEl: function(t, e, i, n) {
            var a = dI(t).labelEl;
            a && (a.setStyle(e.label.style), i(a, {
                shape: e.label.shape,
                position: e.label.position
            }), xc(a, n));
        },
        _renderHandle: function(t) {
            if (!this._dragging && this.updateHandleTransform) {
                var e, i = this._axisPointerModel, n = this._api.getZr(), a = this._handle, o = i.getModel("handle"), r = i.get("status");
                if (!o.get("show") || !r || "hide" === r) return a && n.remove(a), void (this._handle = null);
                this._handle || (e = !0, a = this._handle = kn(o.get("icon"), {
                    cursor: "move",
                    draggable: !0,
                    onmousemove: function(t) {
                        nm(t.event);
                    },
                    onmousedown: pI(this._onHandleDragMove, this, 0, 0),
                    drift: pI(this._onHandleDragMove, this),
                    ondragend: pI(this._onHandleDragEnd, this)
                }), n.add(a)), wc(a, i, !1), a.setStyle(o.getItemStyle(null, [ "color", "borderColor", "borderWidth", "opacity", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY" ]));
                var s = o.get("size");
                N(s) || (s = [ s, s ]), a.attr("scale", [ s[0] / 2, s[1] / 2 ]), ro(this, "_doDispatchAxisPointer", o.get("throttle") || 0, "fixRate"), 
                this._moveHandleToValue(t, e);
            }
        },
        _moveHandleToValue: function(t, e) {
            yc(this._axisPointerModel, !e && this._moveAnimation, this._handle, _c(this.getHandleTransform(t, this._axisModel, this._axisPointerModel)));
        },
        _onHandleDragMove: function(t, e) {
            var i = this._handle;
            if (i) {
                this._dragging = !0;
                var n = this.updateHandleTransform(_c(i), [ t, e ], this._axisModel, this._axisPointerModel);
                this._payloadInfo = n, i.stopAnimation(), i.attr(_c(n)), dI(i).lastProp = null, 
                this._doDispatchAxisPointer();
            }
        },
        _doDispatchAxisPointer: function() {
            if (this._handle) {
                var t = this._payloadInfo, e = this._axisModel;
                this._api.dispatchAction({
                    type: "updateAxisPointer",
                    x: t.cursorPoint[0],
                    y: t.cursorPoint[1],
                    tooltipOption: t.tooltipOption,
                    axesInfo: [ {
                        axisDim: e.axis.dim,
                        axisIndex: e.componentIndex
                    } ]
                });
            }
        },
        _onHandleDragEnd: function(t) {
            if (this._dragging = !1, this._handle) {
                var e = this._axisPointerModel.get("value");
                this._moveHandleToValue(e), this._api.dispatchAction({
                    type: "hideTip"
                });
            }
        },
        getHandleTransform: null,
        updateHandleTransform: null,
        clear: function(t) {
            this._lastValue = null, this._lastStatus = null;
            var e = t.getZr(), i = this._group, n = this._handle;
            e && i && (this._lastGraphicKey = null, i && e.remove(i), n && e.remove(n), this._group = null, 
            this._handle = null, this._payloadInfo = null);
        },
        doClear: function() {},
        buildLabel: function(t, e, i) {
            return {
                x: t[i = i || 0],
                y: t[1 - i],
                width: e[i],
                height: e[1 - i]
            };
        }
    }).constructor = vc);
    var gI = vc.extend({
        makeElOption: function(t, e, i, n, a) {
            var o = i.axis, r = o.grid, s = n.get("type"), l = Lc(r, o).getOtherAxis(o).getGlobalExtent(), h = o.toGlobalCoord(o.dataToCoord(e, !0));
            if (s && "none" !== s) {
                var u = bc(n), c = mI[s](o, h, l, u);
                c.style = u, t.graphicKey = c.type, t.pointer = c;
            }
            Tc(e, t, Ls(r.model, i), i, n, a);
        },
        getHandleTransform: function(t, e, i) {
            var n = Ls(e.axis.grid.model, e, {
                labelInside: !1
            });
            return n.labelMargin = i.get("handle.margin"), {
                position: Ic(e.axis, t, n),
                rotation: n.rotation + (n.labelDirection < 0 ? Math.PI : 0)
            };
        },
        updateHandleTransform: function(t, e, i, n) {
            var a = i.axis, o = a.grid, r = a.getGlobalExtent(!0), s = Lc(o, a).getOtherAxis(a).getGlobalExtent(), l = "x" === a.dim ? 0 : 1, h = t.position;
            h[l] += e[l], h[l] = Math.min(r[1], h[l]), h[l] = Math.max(r[0], h[l]);
            var u = (s[1] + s[0]) / 2, c = [ u, u ];
            return c[l] = h[l], {
                position: h,
                rotation: t.rotation,
                cursorPoint: c,
                tooltipOption: [ {
                    verticalAlign: "middle"
                }, {
                    align: "center"
                } ][l]
            };
        }
    }), mI = {
        line: function(t, e, i, n) {
            var a = Dc([ e, i[0] ], [ e, i[1] ], kc(t));
            return Qi({
                shape: a,
                style: n
            }), {
                type: "Line",
                shape: a
            };
        },
        shadow: function(t, e, i, n) {
            var a = t.getBandWidth(), o = i[1] - i[0];
            return {
                type: "Rect",
                shape: Ac([ e - a / 2, i[0] ], [ a, o ], kc(t))
            };
        }
    };
    Xw.registerAxisPointerClass("CartesianAxisPointer", gI), Go(function(t) {
        if (t) {
            (!t.axisPointer || 0 === t.axisPointer.length) && (t.axisPointer = {});
            var e = t.axisPointer.link;
            e && !N(e) && (t.axisPointer.link = [ e ]);
        }
    }), Wo(Zx.PROCESSOR.STATISTIC, function(t, e) {
        t.getComponent("axisPointer").coordSysAxesInfo = Ss(t, e);
    }), Fo({
        type: "updateAxisPointer",
        event: "updateAxisPointer",
        update: ":updateAxisPointer"
    }, function(t, e, i) {
        var a, n, o, r = t.currTrigger, s = [ t.x, t.y ], l = t, h = t.dispatchAction || _(i.dispatchAction, i), u = e.getComponent("axisPointer").coordSysAxesInfo;
        if (u) {
            dc(s) && (s = oI({
                seriesIndex: l.seriesIndex,
                dataIndex: l.dataIndex
            }, e).point);
            var c = dc(s), d = l.axesInfo, f = u.axesInfo, p = "leave" === r || dc(s), g = {}, m = {}, v = {
                list: [],
                map: {}
            }, y = {
                showPointer: sI(hc, m),
                showTooltip: sI(uc, v)
            };
            rI(u.coordSysMap, function(t, e) {
                var o = c || t.containPoint(s);
                rI(u.coordSysAxesInfo[e], function(t, e) {
                    var i = t.axis, n = function(t, e) {
                        for (var i = 0; i < (t || []).length; i++) {
                            var n = t[i];
                            if (e.axis.dim === n.axisDim && e.axis.model.componentIndex === n.axisIndex) return n;
                        }
                    }(d, t);
                    if (!p && o && (!d || n)) {
                        var a = n && n.value;
                        null != a || c || (a = i.pointToData(s)), null != a && lc(t, a, y, !1, g);
                    }
                });
            });
            var x = {};
            return rI(f, function(a, t) {
                var o = a.linkGroup;
                o && !m[t] && rI(o.axesInfo, function(t, e) {
                    var i = m[e];
                    if (t !== a && i) {
                        var n = i.value;
                        o.mapper && (n = a.axis.scale.parse(o.mapper(n, cc(t), cc(a)))), x[a.key] = n;
                    }
                });
            }), rI(x, function(t, e) {
                lc(f[e], t, y, !0, g);
            }), a = m, n = f, o = g.axesInfo = [], rI(n, function(t, e) {
                var i = t.axisPointerModel.option, n = a[e];
                n ? (!t.useHandle && (i.status = "show"), i.value = n.value, i.seriesDataIndices = (n.payloadBatch || []).slice()) : !t.useHandle && (i.status = "hide"), 
                "show" === i.status && o.push({
                    axisDim: t.axis.dim,
                    axisIndex: t.axis.model.componentIndex,
                    value: i.value
                });
            }), function(t, e, i, n) {
                if (!dc(e) && t.list.length) {
                    var a = ((t.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
                    n({
                        type: "showTip",
                        escapeConnect: !0,
                        x: e[0],
                        y: e[1],
                        tooltipOption: i.tooltipOption,
                        position: i.position,
                        dataIndexInside: a.dataIndexInside,
                        dataIndex: a.dataIndex,
                        seriesIndex: a.seriesIndex,
                        dataByCoordSys: t.list
                    });
                } else n({
                    type: "hideTip"
                });
            }(v, s, t, h), function(t, e, i) {
                var n = i.getZr(), a = lI(n).axisPointerLastHighlights || {}, o = lI(n).axisPointerLastHighlights = {};
                rI(t, function(t, e) {
                    var i = t.axisPointerModel.option;
                    "show" === i.status && rI(i.seriesDataIndices, function(t) {
                        var e = t.seriesIndex + " | " + t.dataIndex;
                        o[e] = t;
                    });
                });
                var r = [], s = [];
                R(a, function(t, e) {
                    !o[e] && s.push(t);
                }), R(o, function(t, e) {
                    !a[e] && r.push(t);
                }), s.length && i.dispatchAction({
                    type: "downplay",
                    escapeConnect: !0,
                    batch: s
                }), r.length && i.dispatchAction({
                    type: "highlight",
                    escapeConnect: !0,
                    batch: r
                });
            }(f, 0, i), g;
        }
    });
    var vI = [ "x", "y" ], yI = [ "width", "height" ], xI = vc.extend({
        makeElOption: function(t, e, i, n, a) {
            var o = i.axis, r = o.coordinateSystem, s = Nc(r, 1 - Pc(o)), l = r.dataToPoint(e)[0], h = n.get("type");
            if (h && "none" !== h) {
                var u = bc(n), c = _I[h](o, l, s, u);
                c.style = u, t.graphicKey = c.type, t.pointer = c;
            }
            Tc(e, t, sc(i), i, n, a);
        },
        getHandleTransform: function(t, e, i) {
            var n = sc(e, {
                labelInside: !1
            });
            return n.labelMargin = i.get("handle.margin"), {
                position: Ic(e.axis, t, n),
                rotation: n.rotation + (n.labelDirection < 0 ? Math.PI : 0)
            };
        },
        updateHandleTransform: function(t, e, i, n) {
            var a = i.axis, o = a.coordinateSystem, r = Pc(a), s = Nc(o, r), l = t.position;
            l[r] += e[r], l[r] = Math.min(s[1], l[r]), l[r] = Math.max(s[0], l[r]);
            var h = Nc(o, 1 - r), u = (h[1] + h[0]) / 2, c = [ u, u ];
            return c[r] = l[r], {
                position: l,
                rotation: t.rotation,
                cursorPoint: c,
                tooltipOption: {
                    verticalAlign: "middle"
                }
            };
        }
    }), _I = {
        line: function(t, e, i, n) {
            var a = Dc([ e, i[0] ], [ e, i[1] ], Pc(t));
            return Qi({
                shape: a,
                style: n
            }), {
                type: "Line",
                shape: a
            };
        },
        shadow: function(t, e, i, n) {
            var a = t.getBandWidth(), o = i[1] - i[0];
            return {
                type: "Rect",
                shape: Ac([ e - a / 2, i[0] ], [ a, o ], Pc(t))
            };
        }
    };
    Xw.registerAxisPointerClass("SingleAxisPointer", xI), qo({
        type: "single"
    });
    var wI = px.extend({
        type: "series.themeRiver",
        dependencies: [ "singleAxis" ],
        nameMap: null,
        init: function(t) {
            wI.superApply(this, "init", arguments), this.legendDataProvider = function() {
                return this.getRawData();
            };
        },
        fixData: function(t) {
            for (var e = t.length, i = L(fu().key(function(t) {
                return t[2];
            }).entries(t), function(t) {
                return {
                    name: t.key,
                    dataList: t.values
                };
            }), n = i.length, a = -1, o = -1, r = 0; r < n; ++r) {
                var s = i[r].dataList.length;
                a < s && (a = s, o = r);
            }
            for (var l = 0; l < n; ++l) if (l !== o) for (var h = i[l].name, u = 0; u < a; ++u) {
                for (var c = i[o].dataList[u][0], d = i[l].dataList.length, f = -1, p = 0; p < d; ++p) if (i[l].dataList[p][0] === c) {
                    f = p;
                    break;
                }
                -1 === f && (t[e] = [], t[e][0] = c, t[e][1] = 0, t[e][2] = h, e++);
            }
            return t;
        },
        getInitialData: function(t, e) {
            for (var i = e.queryComponents({
                mainType: "singleAxis",
                index: this.get("singleAxisIndex"),
                id: this.get("singleAxisId")
            })[0].get("type"), n = I(t.data, function(t) {
                return void 0 !== t[2];
            }), a = this.fixData(n || []), o = [], r = this.nameMap = W(), s = 0, l = 0; l < a.length; ++l) o.push(a[l][2]), 
            r.get(a[l][2]) || (r.set(a[l][2], s), s++);
            var h = b_(a, {
                coordDimensions: [ "single" ],
                dimensionsDefine: [ {
                    name: "time",
                    type: ir(i)
                }, {
                    name: "value",
                    type: "float"
                }, {
                    name: "name",
                    type: "ordinal"
                } ],
                encodeDefine: {
                    single: 0,
                    value: 1,
                    itemName: 2
                }
            }), u = new x_(h, this);
            return u.initData(a), u;
        },
        getLayerSeries: function() {
            for (var i = this.getData(), t = i.count(), e = [], n = 0; n < t; ++n) e[n] = n;
            for (var a = L(fu().key(function(t) {
                return i.get("name", t);
            }).entries(e), function(t) {
                return {
                    name: t.key,
                    indices: t.values
                };
            }), o = i.mapDimension("single"), r = 0; r < a.length; ++r) a[r].indices.sort(function(t, e) {
                return i.get(o, t) - i.get(o, e);
            });
            return a;
        },
        getAxisTooltipData: function(t, e, i) {
            N(t) || (t = t ? [ t ] : []);
            for (var n, a = this.getData(), o = this.getLayerSeries(), r = [], s = o.length, l = 0; l < s; ++l) {
                for (var h = Number.MAX_VALUE, u = -1, c = o[l].indices.length, d = 0; d < c; ++d) {
                    var f = a.get(t[0], o[l].indices[d]), p = Math.abs(f - e);
                    p <= h && (n = f, h = p, u = o[l].indices[d]);
                }
                r.push(u);
            }
            return {
                dataIndices: r,
                nestestValue: n
            };
        },
        formatTooltip: function(t) {
            var e = this.getData(), i = e.getName(t), n = e.get(e.mapDimension("value"), t);
            return (isNaN(n) || null == n) && (n = "-"), ta(i + " : " + n);
        },
        defaultOption: {
            zlevel: 0,
            z: 2,
            coordinateSystem: "singleAxis",
            boundaryGap: [ "10%", "10%" ],
            singleAxisIndex: 0,
            animationEasing: "linear",
            label: {
                margin: 4,
                textAlign: "right",
                show: !0,
                position: "left",
                color: "#000",
                fontSize: 11
            },
            emphasis: {
                label: {
                    show: !0
                }
            }
        }
    });
    $o({
        type: "themeRiver",
        init: function() {
            this._layers = [];
        },
        render: function(T, t, e) {
            function i(t) {
                return t.name;
            }
            function n(t, e, i) {
                var n, a, o, r, s = this._layers;
                if ("remove" !== t) {
                    for (var l, h = [], u = [], c = C[e].indices, d = 0; d < c.length; d++) {
                        var f = D.getItemLayout(c[d]), p = f.x, g = f.y0, m = f.y;
                        h.push([ p, g ]), u.push([ p, g + m ]), l = D.getItemVisual(c[d], "color");
                    }
                    var v, y, x = D.getItemLayout(c[0]), _ = D.getItemModel(c[d - 1]), w = _.getModel("label"), b = w.get("margin");
                    if ("add" === t) S = L[e] = new Dg(), v = new ww({
                        shape: {
                            points: h,
                            stackedOnPoints: u,
                            smooth: .4,
                            stackedOnSmooth: .4,
                            smoothConstraint: !1
                        },
                        z2: 0
                    }), y = new Nv({
                        style: {
                            x: x.x - b,
                            y: x.y0 + x.y / 2
                        }
                    }), S.add(v), S.add(y), A.add(S), v.setClipPath((n = v.getBoundingRect(), a = T, 
                    o = function() {
                        v.removeClipPath();
                    }, In(r = new Wv({
                        shape: {
                            x: n.x - 10,
                            y: n.y - 10,
                            width: 0,
                            height: n.height + 20
                        }
                    }), {
                        shape: {
                            width: n.width + 20,
                            height: n.height + 20
                        }
                    }, a, o), r)); else {
                        var S = s[i];
                        v = S.childAt(0), y = S.childAt(1), A.add(S), L[e] = S, Mn(v, {
                            shape: {
                                points: h,
                                stackedOnPoints: u
                            }
                        }, T), Mn(y, {
                            style: {
                                x: x.x - b,
                                y: x.y0 + x.y / 2
                            }
                        }, T);
                    }
                    var M = _.getModel("emphasis.itemStyle"), I = _.getModel("itemStyle");
                    vn(y.style, w, {
                        text: w.get("show") ? T.getFormattedLabel(c[d - 1], "normal") || D.getName(c[d - 1]) : null,
                        textVerticalAlign: "middle"
                    }), v.setStyle(P({
                        fill: l
                    }, I.getItemStyle([ "color" ]))), gn(v, M.getItemStyle());
                } else A.remove(s[e]);
            }
            var D = T.getData(), A = this.group, C = T.getLayerSeries(), a = D.getLayout("layoutInfo"), o = a.rect, r = a.boundaryGap;
            A.attr("position", [ 0, o.y + r[0] ]);
            var L = {};
            new tr(this._layersSeries || [], C, i, i).add(_(n, this, "add")).update(_(n, this, "update")).remove(_(n, this, "remove")).execute(), 
            this._layersSeries = C, this._layers = L;
        },
        dispose: function() {}
    }), Zo(function(t, e) {
        t.eachSeriesByType("themeRiver", function(t) {
            var e = t.getData(), i = t.coordinateSystem, n = {}, a = i.getRect();
            n.rect = a;
            var o = t.get("boundaryGap"), r = i.getAxis();
            n.boundaryGap = o, "horizontal" === r.orient ? (o[0] = zn(o[0], a.height), o[1] = zn(o[1], a.height), 
            Oc(e, t, a.height - o[0] - o[1])) : (o[0] = zn(o[0], a.width), o[1] = zn(o[1], a.width), 
            Oc(e, t, a.width - o[0] - o[1])), e.setLayout("layoutInfo", n);
        });
    }), Uo(function(t) {
        t.eachSeriesByType("themeRiver", function(a) {
            var o = a.getData(), r = a.getRawData(), s = a.get("color"), l = W();
            o.each(function(t) {
                l.set(o.getRawIndex(t), t);
            }), r.each(function(t) {
                var e = r.getName(t), i = s[(a.nameMap.get(e) - 1) % s.length];
                r.setItemVisual(t, "color", i);
                var n = l.get(t);
                null != n && o.setItemVisual(n, "color", i);
            });
        });
    }), Wo(pb("themeRiver")), px.extend({
        type: "series.sunburst",
        _viewRoot: null,
        getInitialData: function(t, e) {
            var i = {
                name: t.name,
                children: t.data
            };
            !function i(t) {
                var n = 0;
                R(t.children, function(t) {
                    i(t);
                    var e = t.value;
                    N(e) && (e = e[0]), n += e;
                });
                var e = t.value;
                N(e) && (e = e[0]), (null == e || isNaN(e)) && (e = n), e < 0 && (e = 0), N(t.value) ? t.value[0] = e : t.value = e;
            }(i);
            var n = t.levels || [], a = {};
            return a.levels = n, wl.createTree(i, this, a).data;
        },
        optionUpdated: function() {
            this.resetViewRoot();
        },
        getDataParams: function(t) {
            var e = px.prototype.getDataParams.apply(this, arguments), i = this.getData().tree.getNodeByDataIndex(t);
            return e.treePathInfo = Bl(i, this), e;
        },
        defaultOption: {
            zlevel: 0,
            z: 2,
            center: [ "50%", "50%" ],
            radius: [ 0, "75%" ],
            clockwise: !0,
            startAngle: 90,
            minAngle: 0,
            percentPrecision: 2,
            stillShowZeroSum: !0,
            highlightPolicy: "descendant",
            nodeClick: "rootToNode",
            renderLabelForZeroData: !1,
            label: {
                rotate: "radial",
                show: !0,
                opacity: 1,
                align: "center",
                position: "inside",
                distance: 5,
                silent: !0,
                emphasis: {}
            },
            itemStyle: {
                borderWidth: 1,
                borderColor: "white",
                opacity: 1,
                emphasis: {},
                highlight: {
                    opacity: 1
                },
                downplay: {
                    opacity: .9
                }
            },
            animationType: "expansion",
            animationDuration: 1e3,
            animationDurationUpdate: 500,
            animationEasing: "cubicOut",
            data: [],
            levels: [],
            sort: "desc"
        },
        getViewRoot: function() {
            return this._viewRoot;
        },
        resetViewRoot: function(t) {
            t ? this._viewRoot = t : t = this._viewRoot;
            var e = this.getRawData().tree.root;
            t && (t === e || e.contains(t)) || (this._viewRoot = e);
        }
    });
    var bI = "none", SI = 2, MI = 4, II = Ec.prototype;
    II.updateData = function(t, e, i, n, a) {
        (this.node = e).piece = this, n = n || this._seriesModel, a = a || this._ecModel;
        var o = this.childAt(0);
        o.dataIndex = e.dataIndex;
        var r = e.getModel(), s = e.getLayout(), l = P({}, s);
        l.label = null;
        var h, u = Rc(e, 0, a), c = r.getModel("itemStyle").getItemStyle();
        h = E({
            lineJoin: "bevel",
            fill: (h = "normal" === i ? c : g(r.getModel(i + ".itemStyle").getItemStyle(), c)).fill || u
        }, h), t ? (o.setShape(l), o.shape.r = s.r0, Mn(o, {
            shape: {
                r: s.r
            }
        }, n, e.dataIndex), o.useStyle(h)) : "object" == _typeof(h.fill) && h.fill.type || "object" == _typeof(o.style.fill) && o.style.fill.type ? (Mn(o, {
            shape: l
        }, n), o.useStyle(h)) : Mn(o, {
            shape: l,
            style: h
        }, n), this._updateLabel(n, u, i);
        var d = r.getShallow("cursor");
        if (d && o.attr("cursor", d), t) {
            var f = n.getShallow("highlightPolicy");
            this._initEvents(o, e, n, f);
        }
        this._seriesModel = n || this._seriesModel, this._ecModel = a || this._ecModel;
    }, II.onEmphasis = function(a) {
        var o = this;
        this.node.hostTree.root.eachNode(function(t) {
            var e, i, n;
            t.piece && (o.node === t ? t.piece.updateData(!1, t, "emphasis") : (e = t, i = o.node, 
            (n = a) !== LE.NONE && (n === LE.SELF ? e === i : n === LE.ANCESTOR ? e === i || e.isAncestorOf(i) : e === i || e.isDescendantOf(i)) ? t.piece.childAt(0).trigger("highlight") : a !== bI && t.piece.childAt(0).trigger("downplay")));
        });
    }, II.onNormal = function() {
        this.node.hostTree.root.eachNode(function(t) {
            t.piece && t.piece.updateData(!1, t, "normal");
        });
    }, II.onHighlight = function() {
        this.updateData(!1, this.node, "highlight");
    }, II.onDownplay = function() {
        this.updateData(!1, this.node, "downplay");
    }, II._updateLabel = function(t, e, i) {
        function n(t) {
            var e = r.get(t);
            return null == e ? o.get(t) : e;
        }
        var a = this.node.getModel(), o = a.getModel("label"), r = "normal" === i || "emphasis" === i ? o : a.getModel(i + ".label"), s = a.getModel("emphasis.label"), l = V(t.getFormattedLabel(this.node.dataIndex, "normal", null, null, "label"), this.node.name);
        !1 === n("show") && (l = "");
        var h = this.node.getLayout(), u = r.get("minAngle");
        null == u && (u = o.get("minAngle")), u = u / 180 * Math.PI;
        var c = h.endAngle - h.startAngle;
        null != u && Math.abs(c) < u && (l = "");
        var d = this.childAt(1);
        mn(d.style, d.hoverStyle || {}, o, s, {
            defaultText: r.getShallow("show") ? l : null,
            autoColor: e,
            useInsideStyle: !0
        });
        var f, p = (h.startAngle + h.endAngle) / 2, g = Math.cos(p), m = Math.sin(p), v = n("position"), y = n("distance") || 0, x = n("align");
        "outside" === v ? (f = h.r + y, x = p > Math.PI / 2 ? "right" : "left") : x && "center" !== x ? "left" === x ? (f = h.r0 + y, 
        p > Math.PI / 2 && (x = "right")) : "right" === x && (f = h.r - y, p > Math.PI / 2 && (x = "left")) : (f = (h.r + h.r0) / 2, 
        x = "center"), d.attr("style", {
            text: l,
            textAlign: x,
            textVerticalAlign: n("verticalAlign") || "middle",
            opacity: n("opacity")
        });
        var _ = f * g + h.cx, w = f * m + h.cy;
        d.attr("position", [ _, w ]);
        var b = n("rotate"), S = 0;
        "radial" === b ? (S = -p) < -Math.PI / 2 && (S += Math.PI) : "tangential" === b ? (S = Math.PI / 2 - p) > Math.PI / 2 ? S -= Math.PI : S < -Math.PI / 2 && (S += Math.PI) : "number" == typeof b && (S = b * Math.PI / 180), 
        d.attr("rotation", S);
    }, II._initEvents = function(t, e, i, n) {
        t.off("mouseover").off("mouseout").off("emphasis").off("normal");
        var a = this, o = function() {
            a.onEmphasis(n);
        }, r = function() {
            a.onNormal();
        };
        i.isAnimationEnabled() && t.on("mouseover", o).on("mouseout", r).on("emphasis", o).on("normal", r).on("downplay", function() {
            a.onDownplay();
        }).on("highlight", function() {
            a.onHighlight();
        });
    }, o(Ec, Dg), to.extend({
        type: "sunburst",
        init: function() {},
        render: function(a, o, t, e) {
            function r(t, e) {
                if (u || !t || t.getValue() || (t = null), t !== l && e !== l) if (e && e.piece) t ? (e.piece.updateData(!1, t, "normal", a, o), 
                s.setItemGraphicEl(t.dataIndex, e.piece)) : (n = e) && n.piece && (h.remove(n.piece), 
                n.piece = null); else if (t) {
                    var i = new Ec(t, a, o);
                    h.add(i), s.setItemGraphicEl(t.dataIndex, i);
                }
                var n;
            }
            var n = this;
            this.seriesModel = a, this.api = t, this.ecModel = o;
            var s = a.getData(), l = s.tree.root, i = a.getViewRoot(), h = this.group, u = a.get("renderLabelForZeroData"), c = [];
            i.eachNode(function(t) {
                c.push(t);
            });
            var d = this._oldChildren || [];
            if (function(i, n) {
                function t(t) {
                    return t.getId();
                }
                function e(t, e) {
                    r(null == t ? null : i[t], null == e ? null : n[e]);
                }
                0 === i.length && 0 === n.length || new tr(n, i, t, t).add(e).update(e).remove(z(e, null)).execute();
            }(c, d), function(t, e) {
                if (0 < e.depth) {
                    t.piece ? t.piece.updateData(!1, t, "normal", a, o) : (t.piece = new Ec(t, a, o), 
                    h.add(t.piece)), e.piece._onclickEvent && e.piece.off("click", e.piece._onclickEvent);
                    var i = function(t) {
                        n._rootToNode(e.parentNode);
                    };
                    e.piece._onclickEvent = i, t.piece.on("click", i);
                } else t.piece && (h.remove(t.piece), t.piece = null);
            }(l, i), e && e.highlight && e.highlight.piece) {
                var f = a.getShallow("highlightPolicy");
                e.highlight.piece.onEmphasis(f);
            } else if (e && e.unhighlight) {
                var p = l.piece;
                !p && l.children.length && (p = l.children[0].piece), p && p.onNormal();
            }
            this._initEvents(), this._oldChildren = c;
        },
        dispose: function() {},
        _initEvents: function() {
            var s = this, t = function(o) {
                var r = !1;
                s.seriesModel.getViewRoot().eachNode(function(t) {
                    if (!r && t.piece && t.piece.childAt(0) === o.target) {
                        var e = t.getModel().get("nodeClick");
                        if ("rootToNode" === e) s._rootToNode(t); else if ("link" === e) {
                            var i = t.getModel(), n = i.get("link");
                            if (n) {
                                var a = i.get("target", !0) || "_blank";
                                window.open(n, a);
                            }
                        }
                        r = !0;
                    }
                });
            };
            this.group._onclickEvent && this.group.off("click", this.group._onclickEvent), this.group.on("click", t), 
            this.group._onclickEvent = t;
        },
        _rootToNode: function(t) {
            t !== this.seriesModel.getViewRoot() && this.api.dispatchAction({
                type: "sunburstRootToNode",
                from: this.uid,
                seriesId: this.seriesModel.id,
                targetNode: t
            });
        },
        containPoint: function(t, e) {
            var i = e.getData().getItemLayout(0);
            if (i) {
                var n = t[0] - i.cx, a = t[1] - i.cy, o = Math.sqrt(n * n + a * a);
                return o <= i.r && o >= i.r0;
            }
        }
    });
    var TI = "sunburstRootToNode";
    Fo({
        type: TI,
        update: "updateView"
    }, function(a, t) {
        t.eachComponent({
            mainType: "series",
            subType: "sunburst",
            query: a
        }, function(t, e) {
            var i = El(a, [ TI ], t);
            if (i) {
                var n = t.getViewRoot();
                n && (a.direction = zl(n, i.node) ? "rollUp" : "drillDown"), t.resetViewRoot(i.node);
            }
        });
    });
    var DI = "sunburstHighlight";
    Fo({
        type: DI,
        update: "updateView"
    }, function(n, t) {
        t.eachComponent({
            mainType: "series",
            subType: "sunburst",
            query: n
        }, function(t, e) {
            var i = El(n, [ DI ], t);
            i && (n.highlight = i.node);
        });
    }), Fo({
        type: "sunburstUnhighlight",
        update: "updateView"
    }, function(i, t) {
        t.eachComponent({
            mainType: "series",
            subType: "sunburst",
            query: i
        }, function(t, e) {
            i.unhighlight = !0;
        });
    });
    var AI = Math.PI / 180;
    Uo(z(ub, "sunburst")), Zo(z(function(t, e, A, i) {
        e.eachSeriesByType(t, function(t) {
            var e = t.get("center"), i = t.get("radius");
            N(i) || (i = [ 0, i ]), N(e) || (e = [ e, e ]);
            var n = A.getWidth(), a = A.getHeight(), c = Math.min(n, a), d = zn(e[0], n), f = zn(e[1], a), p = zn(i[0], c / 2), o = zn(i[1], c / 2), r = -t.get("startAngle") * AI, g = t.get("minAngle") * AI, m = t.getData().tree.root, s = t.getViewRoot(), v = s.depth, l = t.get("sort");
            null != l && function e(t, i) {
                var n = t.children || [];
                t.children = function(t, e) {
                    if ("function" == typeof e) return t.sort(e);
                    var n = "asc" === e;
                    return t.sort(function(t, e) {
                        var i = (t.getValue() - e.getValue()) * (n ? 1 : -1);
                        return 0 === i ? (t.dataIndex - e.dataIndex) * (n ? -1 : 1) : i;
                    });
                }(n, i), n.length && R(t.children, function(t) {
                    e(t, i);
                });
            }(s, l);
            var h = 0;
            R(s.children, function(t) {
                !isNaN(t.getValue()) && h++;
            });
            var y = s.getValue(), x = Math.PI / (y || h) * 2, _ = 0 < s.depth, u = s.height - (_ ? -1 : 1), w = (o - p) / (u || 1), b = t.get("clockwise"), S = t.get("stillShowZeroSum"), M = b ? 1 : -1;
            if (_) {
                var I = p, T = p + w, D = 2 * Math.PI;
                m.setLayout({
                    angle: D,
                    startAngle: r,
                    endAngle: r + D,
                    clockwise: b,
                    cx: d,
                    cy: f,
                    r0: I,
                    r: T
                });
            }
            !function e(t, i) {
                if (t) {
                    var n = i;
                    if (t !== m) {
                        var a = t.getValue(), o = 0 === y && S ? x : a * x;
                        o < g && (o = g), n = i + M * o;
                        var r = t.depth - v - (_ ? -1 : 1), s = p + w * r, l = p + w * (r + 1), h = t.getModel();
                        null != h.get("r0") && (s = zn(h.get("r0"), c / 2)), null != h.get("r") && (l = zn(h.get("r"), c / 2)), 
                        t.setLayout({
                            angle: o,
                            startAngle: i,
                            endAngle: n,
                            clockwise: b,
                            cx: d,
                            cy: f,
                            r0: s,
                            r: l
                        });
                    }
                    if (t.children && t.children.length) {
                        var u = 0;
                        R(t.children, function(t) {
                            u += e(t, i + u);
                        });
                    }
                    return n - i;
                }
            }(s, r);
        });
    }, "sunburst")), Wo(z(pb, "sunburst"));
    var CI = [ "itemStyle" ], LI = [ "emphasis", "itemStyle" ], kI = [ "label" ], PI = [ "emphasis", "label" ], NI = "e\0\0", OI = {
        cartesian2d: function(e) {
            var t = e.grid.getRect();
            return {
                coordSys: {
                    type: "cartesian2d",
                    x: t.x,
                    y: t.y,
                    width: t.width,
                    height: t.height
                },
                api: {
                    coord: function(t) {
                        return e.dataToPoint(t);
                    },
                    size: _(zc, e)
                }
            };
        },
        geo: function(e) {
            var t = e.getBoundingRect();
            return {
                coordSys: {
                    type: "geo",
                    x: t.x,
                    y: t.y,
                    width: t.width,
                    height: t.height
                },
                api: {
                    coord: function(t) {
                        return e.dataToPoint(t);
                    },
                    size: _(Bc, e)
                }
            };
        },
        singleAxis: function(e) {
            var t = e.getRect();
            return {
                coordSys: {
                    type: "singleAxis",
                    x: t.x,
                    y: t.y,
                    width: t.width,
                    height: t.height
                },
                api: {
                    coord: function(t) {
                        return e.dataToPoint(t);
                    },
                    size: _(Vc, e)
                }
            };
        },
        polar: function(a) {
            var o = a.getRadiusAxis(), r = a.getAngleAxis(), t = o.getExtent();
            return t[0] > t[1] && t.reverse(), {
                coordSys: {
                    type: "polar",
                    cx: a.cx,
                    cy: a.cy,
                    r: t[1],
                    r0: t[0]
                },
                api: {
                    coord: _(function(t) {
                        var e = o.dataToRadius(t[0]), i = r.dataToAngle(t[1]), n = a.coordToPoint([ e, i ]);
                        return n.push(e, i * Math.PI / 180), n;
                    }),
                    size: _(Gc, a)
                }
            };
        },
        calendar: function(i) {
            var t = i.getRect(), e = i.getRangeInfo();
            return {
                coordSys: {
                    type: "calendar",
                    x: t.x,
                    y: t.y,
                    width: t.width,
                    height: t.height,
                    cellWidth: i.getCellWidth(),
                    cellHeight: i.getCellHeight(),
                    rangeInfo: {
                        start: e.start,
                        end: e.end,
                        weeks: e.weeks,
                        dayCount: e.allDay
                    }
                },
                api: {
                    coord: function(t, e) {
                        return i.dataToPoint(t, e);
                    }
                }
            };
        }
    };
    Ko({
        type: "series.custom",
        dependencies: [ "grid", "polar", "geo", "singleAxis", "calendar" ],
        defaultOption: {
            coordinateSystem: "cartesian2d",
            zlevel: 0,
            z: 2,
            legendHoverLink: !0
        },
        getInitialData: function(t, e) {
            return gr(this.getSource(), this);
        }
    }), $o({
        type: "custom",
        _data: null,
        render: function(i, t, e) {
            var n = this._data, a = i.getData(), o = this.group, r = Fc(i, a, t, e);
            this.group.removeAll(), a.diff(n).add(function(t) {
                Hc(null, t, r(t), i, o, a);
            }).update(function(t, e) {
                Hc(n.getItemGraphicEl(e), t, r(t), i, o, a);
            }).remove(function(t) {
                var e = n.getItemGraphicEl(t);
                e && o.remove(e);
            }).execute(), this._data = a;
        },
        incrementalPrepareRender: function(t, e, i) {
            this.group.removeAll(), this._data = null;
        },
        incrementalRender: function(t, e, i, n) {
            for (var a = e.getData(), o = Fc(e, a, i, n), r = t.start; r < t.end; r++) Hc(null, r, o(r), e, this.group, a).traverse(function(t) {
                t.isGroup || (t.incremental = !0, t.useHoverLayer = !0);
            });
        },
        dispose: S
    }), Go(function(t) {
        var e = t.graphic;
        N(e) ? e[0] && e[0].elements ? t.graphic = [ t.graphic[0] ] : t.graphic = [ {
            elements: e
        } ] : e && !e.elements && (t.graphic = [ {
            elements: [ e ]
        } ]);
    });
    var EI = Yo({
        type: "graphic",
        defaultOption: {
            elements: [],
            parentId: null
        },
        _elOptionsToUpdate: null,
        mergeOption: function(t) {
            var e = this.option.elements;
            this.option.elements = null, EI.superApply(this, "mergeOption", arguments), this.option.elements = e;
        },
        optionUpdated: function(t, e) {
            var i = this.option, n = (e ? i : t).elements, c = i.elements = e ? [] : i.elements, a = [];
            this._flatten(n, a);
            var o = ii(c, a);
            ni(o);
            var d = this._elOptionsToUpdate = [];
            R(o, function(t, e) {
                var i, n, a, o, r, s, l, h, u = t.option;
                u && (d.push(u), function(t, e) {
                    var i = t.exist;
                    if (e.id = t.keyInfo.id, !e.type && i && (e.type = i.type), null == e.parentId) {
                        var n = e.parentOption;
                        n ? e.parentId = n.id : i && (e.parentId = i.parentId);
                    }
                    e.parentOption = null;
                }(t, u), a = c, o = e, s = P({}, r = u), l = a[o], "merge" === (h = r.$action || "merge") ? l ? (g(l, s, !0), 
                ua(l, s, {
                    ignoreSize: !0
                }), da(r, l)) : a[o] = s : "replace" === h ? a[o] = s : "remove" === h && l && (a[o] = null), 
                i = c[e], n = u, i && (i.hv = n.hv = [ Kc(n, [ "left", "right" ]), Kc(n, [ "top", "bottom" ]) ], 
                "group" === i.type && (null == i.width && (i.width = n.width = 0), null == i.height && (i.height = n.height = 0))));
            }, this);
            for (var r = c.length - 1; 0 <= r; r--) null == c[r] ? c.splice(r, 1) : delete c[r].$action;
        },
        _flatten: function(t, i, n) {
            R(t, function(t) {
                if (t) {
                    n && (t.parentOption = n), i.push(t);
                    var e = t.children;
                    "group" === t.type && e && this._flatten(e, i, t), delete t.children;
                }
            }, this);
        },
        useElOptionsToUpdate: function() {
            var t = this._elOptionsToUpdate;
            return this._elOptionsToUpdate = null, t;
        }
    });
    qo({
        type: "graphic",
        init: function(t, e) {
            this._elMap = W(), this._lastGraphicModel;
        },
        render: function(t, e, i) {
            t !== this._lastGraphicModel && this._clear(), this._lastGraphicModel = t, this._updateElements(t, i), 
            this._relocate(t, i);
        },
        _updateElements: function(t, e) {
            var i = t.useElOptionsToUpdate();
            if (i) {
                var u = this._elMap, c = this.group;
                R(i, function(t) {
                    var e = t.$action, i = t.id, n = u.get(i), a = t.parentId, o = null != a ? u.get(a) : c;
                    if ("text" === t.type) {
                        var r = t.style;
                        t.hv && t.hv[1] && (r.textVerticalAlign = r.textBaseline = null), !r.hasOwnProperty("textFill") && r.fill && (r.textFill = r.fill), 
                        !r.hasOwnProperty("textStroke") && r.stroke && (r.textStroke = r.stroke);
                    }
                    var s, l = (s = P({}, s = t), R([ "id", "parentId", "$action", "hv", "bounding" ].concat(Iy), function(t) {
                        delete s[t];
                    }), s);
                    e && "merge" !== e ? "replace" === e ? (qc(n, u), Yc(i, o, l, u)) : "remove" === e && qc(n, u) : n ? n.attr(l) : Yc(i, o, l, u);
                    var h = u.get(i);
                    h && (h.__ecGraphicWidth = t.width, h.__ecGraphicHeight = t.height);
                });
            }
        },
        _relocate: function(t, e) {
            for (var i = t.option.elements, n = this.group, a = this._elMap, o = i.length - 1; 0 <= o; o--) {
                var r = i[o], s = a.get(r.id);
                if (s) {
                    var l = s.parent;
                    ha(s, r, l === n ? {
                        width: e.getWidth(),
                        height: e.getHeight()
                    } : {
                        width: l.__ecGraphicWidth || 0,
                        height: l.__ecGraphicHeight || 0
                    }, null, {
                        hv: r.hv,
                        boundingMode: r.bounding
                    });
                }
            }
        },
        _clear: function() {
            var e = this._elMap;
            e.each(function(t) {
                qc(t, e);
            }), this._elMap = W();
        },
        dispose: function() {
            this._clear();
        }
    });
    var RI = Yo({
        type: "legend.plain",
        dependencies: [ "series" ],
        layoutMode: {
            type: "box",
            ignoreSize: !0
        },
        init: function(t, e, i) {
            this.mergeDefaultAndTheme(t, i), t.selected = t.selected || {};
        },
        mergeOption: function(t) {
            RI.superCall(this, "mergeOption", t);
        },
        optionUpdated: function() {
            this._updateData(this.ecModel);
            var t = this._data;
            if (t[0] && "single" === this.get("selectedMode")) {
                for (var e = !1, i = 0; i < t.length; i++) {
                    var n = t[i].get("name");
                    if (this.isSelected(n)) {
                        this.select(n), e = !0;
                        break;
                    }
                }
                !e && this.select(t[0].get("name"));
            }
        },
        _updateData: function(o) {
            var r = [], s = [];
            o.eachRawSeries(function(t) {
                var e, i = t.name;
                if (s.push(i), t.legendDataProvider) {
                    var n = t.legendDataProvider(), a = n.mapArray(n.getName);
                    o.isSeriesFiltered(t) || (s = s.concat(a)), a.length ? r = r.concat(a) : e = !0;
                } else e = !0;
                e && ai(t) && r.push(t.name);
            }), this._availableNames = s;
            var t = L(this.get("data") || r, function(t) {
                return "string" != typeof t && "number" != typeof t || (t = {
                    name: t
                }), new Pn(t, this, this.ecModel);
            }, this);
            this._data = t;
        },
        getData: function() {
            return this._data;
        },
        select: function(t) {
            var e = this.option.selected;
            "single" === this.get("selectedMode") && R(this._data, function(t) {
                e[t.get("name")] = !1;
            }), e[t] = !0;
        },
        unSelect: function(t) {
            "single" !== this.get("selectedMode") && (this.option.selected[t] = !1);
        },
        toggleSelected: function(t) {
            var e = this.option.selected;
            e.hasOwnProperty(t) || (e[t] = !0), this[e[t] ? "unSelect" : "select"](t);
        },
        isSelected: function(t) {
            var e = this.option.selected;
            return !(e.hasOwnProperty(t) && !e[t]) && 0 <= C(this._availableNames, t);
        },
        defaultOption: {
            zlevel: 0,
            z: 4,
            show: !0,
            orient: "horizontal",
            left: "center",
            top: 0,
            align: "auto",
            backgroundColor: "rgba(0,0,0,0)",
            borderColor: "#ccc",
            borderRadius: 0,
            borderWidth: 0,
            padding: 5,
            itemGap: 10,
            itemWidth: 25,
            itemHeight: 14,
            inactiveColor: "#ccc",
            textStyle: {
                color: "#333"
            },
            selectedMode: !0,
            tooltip: {
                show: !1
            }
        }
    });
    Fo("legendToggleSelect", "legendselectchanged", z($c, "toggleSelected")), Fo("legendSelect", "legendselected", z($c, "select")), 
    Fo("legendUnSelect", "legendunselected", z($c, "unSelect"));
    var zI = z, BI = R, VI = Dg, GI = qo({
        type: "legend.plain",
        newlineDisabled: !1,
        init: function() {
            this.group.add(this._contentGroup = new VI()), this._backgroundEl;
        },
        getContentGroup: function() {
            return this._contentGroup;
        },
        render: function(t, e, i) {
            if (this.resetInner(), t.get("show", !0)) {
                var n = t.get("align");
                n && "auto" !== n || (n = "right" === t.get("left") && "vertical" === t.get("orient") ? "right" : "left"), 
                this.renderInner(n, t, e, i);
                var a = t.getBoxLayoutParams(), o = {
                    width: i.getWidth(),
                    height: i.getHeight()
                }, r = t.get("padding"), s = la(a, o, r), l = this.layoutInner(t, n, s), h = la(E({
                    width: l.width,
                    height: l.height
                }, a), o, r);
                this.group.attr("position", [ h.x - l.x, h.y - l.y ]), this.group.add(this._backgroundEl = Jc(l, t));
            }
        },
        resetInner: function() {
            this.getContentGroup().removeAll(), this._backgroundEl && this.group.remove(this._backgroundEl);
        },
        renderInner: function(l, h, u, c) {
            var d = this.getContentGroup(), f = W(), p = h.get("selectedMode");
            BI(h.getData(), function(a, o) {
                var r = a.get("name");
                if (this.newlineDisabled || "" !== r && "\n" !== r) {
                    var t = u.getSeriesByName(r)[0];
                    if (!f.get(r)) if (t) {
                        var e = t.getData(), i = e.getVisual("color");
                        "function" == typeof i && (i = i(t.getDataParams(0)));
                        var n = e.getVisual("legendSymbol") || "roundRect", s = e.getVisual("symbol");
                        this._createItem(r, o, a, h, n, s, l, i, p).on("click", zI(Qc, r, c)).on("mouseover", zI(td, t, null, c)).on("mouseout", zI(ed, t, null, c)), 
                        f.set(r, !0);
                    } else u.eachRawSeries(function(t) {
                        if (!f.get(r) && t.legendDataProvider) {
                            var e = t.legendDataProvider(), i = e.indexOfName(r);
                            if (i < 0) return;
                            var n = e.getItemVisual(i, "color");
                            this._createItem(r, o, a, h, "roundRect", null, l, n, p).on("click", zI(Qc, r, c)).on("mouseover", zI(td, t, r, c)).on("mouseout", zI(ed, t, r, c)), 
                            f.set(r, !0);
                        }
                    }, this);
                } else d.add(new VI({
                    newline: !0
                }));
            }, this);
        },
        _createItem: function(t, e, i, n, a, o, r, s, l) {
            var h = n.get("itemWidth"), u = n.get("itemHeight"), c = n.get("inactiveColor"), d = n.get("symbolKeepAspect"), f = n.isSelected(t), p = new VI(), g = i.getModel("textStyle"), m = i.get("icon"), v = i.getModel("tooltip"), y = v.parentModel;
            if (a = m || a, p.add(Rr(a, 0, 0, h, u, f ? s : c, null == d || d)), !m && o && (o !== a || "none" == o)) {
                var x = .8 * u;
                "none" === o && (o = "circle"), p.add(Rr(o, (h - x) / 2, (u - x) / 2, x, x, f ? s : c, null == d || d));
            }
            var _ = "left" === r ? h + 5 : -5, w = r, b = n.get("formatter"), S = t;
            "string" == typeof b && b ? S = b.replace("{name}", null != t ? t : "") : "function" == typeof b && (S = b(t)), 
            p.add(new Nv({
                style: vn({}, g, {
                    text: S,
                    x: _,
                    y: u / 2,
                    textFill: f ? g.getTextColor() : c,
                    textAlign: w,
                    textVerticalAlign: "middle"
                })
            }));
            var M = new Wv({
                shape: p.getBoundingRect(),
                invisible: !0,
                tooltip: v.get("show") ? P({
                    content: t,
                    formatter: y.get("formatter", !0) || function() {
                        return t;
                    },
                    formatterParams: {
                        componentType: "legend",
                        legendIndex: n.componentIndex,
                        name: t,
                        $vars: [ "name" ]
                    }
                }, v.option) : null
            });
            return p.add(M), p.eachChild(function(t) {
                t.silent = !0;
            }), M.silent = !l, this.getContentGroup().add(p), gn(p), p.__legendDataIndex = e, 
            p;
        },
        layoutInner: function(t, e, i) {
            var n = this.getContentGroup();
            Dy(t.get("orient"), n, t.get("itemGap"), i.width, i.height);
            var a = n.getBoundingRect();
            return n.attr("position", [ -a.x, -a.y ]), this.group.getBoundingRect();
        }
    });
    Wo(function(t) {
        var i = t.findComponents({
            mainType: "legend"
        });
        i && i.length && t.filterSeries(function(t) {
            for (var e = 0; e < i.length; e++) if (!i[e].isSelected(t.name)) return !1;
            return !0;
        });
    }), Cy.registerSubTypeDefaulter("legend", function() {
        return "plain";
    });
    var WI = RI.extend({
        type: "legend.scroll",
        setScrollDataIndex: function(t) {
            this.option.scrollDataIndex = t;
        },
        defaultOption: {
            scrollDataIndex: 0,
            pageButtonItemGap: 5,
            pageButtonGap: null,
            pageButtonPosition: "end",
            pageFormatter: "{current}/{total}",
            pageIcons: {
                horizontal: [ "M0,0L12,-10L12,10z", "M0,0L-12,-10L-12,10z" ],
                vertical: [ "M0,0L20,0L10,-20z", "M0,0L20,0L10,20z" ]
            },
            pageIconColor: "#2f4554",
            pageIconInactiveColor: "#aaa",
            pageIconSize: 15,
            pageTextStyle: {
                color: "#333"
            },
            animationDurationUpdate: 800
        },
        init: function(t, e, i, n) {
            var a = ca(t);
            WI.superCall(this, "init", t, e, i, n), id(this, t, a);
        },
        mergeOption: function(t, e) {
            WI.superCall(this, "mergeOption", t, e), id(this, this.option, t);
        },
        getOrient: function() {
            return "vertical" === this.get("orient") ? {
                index: 1,
                name: "vertical"
            } : {
                index: 0,
                name: "horizontal"
            };
        }
    }), FI = Dg, HI = [ "width", "height" ], ZI = [ "x", "y" ], UI = GI.extend({
        type: "legend.scroll",
        newlineDisabled: !0,
        init: function() {
            UI.superCall(this, "init"), this._currentIndex = 0, this.group.add(this._containerGroup = new FI()), 
            this._containerGroup.add(this.getContentGroup()), this.group.add(this._controllerGroup = new FI()), 
            this._showController;
        },
        resetInner: function() {
            UI.superCall(this, "resetInner"), this._controllerGroup.removeAll(), this._containerGroup.removeClipPath(), 
            this._containerGroup.__rectSize = null;
        },
        renderInner: function(t, a, e, o) {
            function i(t, e) {
                var i = t + "DataIndex", n = kn(a.get("pageIcons", !0)[a.getOrient().name][e], {
                    onclick: _(r._pageGo, r, i, a, o)
                }, {
                    x: -l[0] / 2,
                    y: -l[1] / 2,
                    width: l[0],
                    height: l[1]
                });
                n.name = t, s.add(n);
            }
            var r = this;
            UI.superCall(this, "renderInner", t, a, e, o);
            var s = this._controllerGroup, l = a.get("pageIconSize", !0);
            N(l) || (l = [ l, l ]), i("pagePrev", 0);
            var n = a.getModel("pageTextStyle");
            s.add(new Nv({
                name: "pageText",
                style: {
                    textFill: n.getTextColor(),
                    font: n.getFont(),
                    textVerticalAlign: "middle",
                    textAlign: "center"
                },
                silent: !0
            })), i("pageNext", 1);
        },
        layoutInner: function(t, e, i) {
            var n = this.getContentGroup(), a = this._containerGroup, o = this._controllerGroup, r = t.getOrient().index, s = HI[r], l = HI[1 - r], h = ZI[1 - r];
            Dy(t.get("orient"), n, t.get("itemGap"), r ? i.width : null, r ? null : i.height), 
            Dy("horizontal", o, t.get("pageButtonItemGap", !0));
            var u = n.getBoundingRect(), c = o.getBoundingRect(), d = this._showController = u[s] > i[s], f = [ -u.x, -u.y ];
            f[r] = n.position[r];
            var p = [ 0, 0 ], g = [ -c.x, -c.y ], m = k(t.get("pageButtonGap", !0), t.get("itemGap", !0));
            d && ("end" === t.get("pageButtonPosition", !0) ? g[r] += i[s] - c[s] : p[r] += c[s] + m), 
            g[1 - r] += u[l] / 2 - c[l] / 2, n.attr("position", f), a.attr("position", p), o.attr("position", g);
            var v = this.group.getBoundingRect();
            if ((v = {
                x: 0,
                y: 0
            })[s] = d ? i[s] : u[s], v[l] = Math.max(u[l], c[l]), v[h] = Math.min(0, c[h] + g[1 - r]), 
            a.__rectSize = i[s], d) {
                var y = {
                    x: 0,
                    y: 0
                };
                y[s] = Math.max(i[s] - c[s] - m, 0), y[l] = v[l], a.setClipPath(new Wv({
                    shape: y
                })), a.__rectSize = y[s];
            } else o.eachChild(function(t) {
                t.attr({
                    invisible: !0,
                    silent: !0
                });
            });
            var x = this._getPageInfo(t);
            return null != x.pageIndex && Mn(n, {
                position: x.contentPosition
            }, !!d && t), this._updatePageInfoView(t, x), v;
        },
        _pageGo: function(t, e, i) {
            var n = this._getPageInfo(e)[t];
            null != n && i.dispatchAction({
                type: "legendScroll",
                scrollDataIndex: n,
                legendId: e.id
            });
        },
        _updatePageInfoView: function(n, a) {
            var o = this._controllerGroup;
            R([ "pagePrev", "pageNext" ], function(t) {
                var e = null != a[t + "DataIndex"], i = o.childOfName(t);
                i && (i.setStyle("fill", e ? n.get("pageIconColor", !0) : n.get("pageIconInactiveColor", !0)), 
                i.cursor = e ? "pointer" : "default");
            });
            var t = o.childOfName("pageText"), e = n.get("pageFormatter"), i = a.pageIndex, r = null != i ? i + 1 : 0, s = a.pageCount;
            t && e && t.setStyle("text", b(e) ? e.replace("{current}", r).replace("{total}", s) : e({
                current: r,
                total: s
            }));
        },
        _getPageInfo: function(t) {
            function n(t) {
                var e = t.getBoundingRect().clone();
                return e[f] += t.position[u], e;
            }
            var e, i, a, o, r = t.get("scrollDataIndex", !0), s = this.getContentGroup(), l = s.getBoundingRect(), h = this._containerGroup.__rectSize, u = t.getOrient().index, c = HI[u], d = HI[1 - u], f = ZI[u], p = s.position.slice();
            this._showController ? s.eachChild(function(t) {
                t.__legendDataIndex === r && (o = t);
            }) : o = s.childAt(0);
            var g = h ? Math.ceil(l[c] / h) : 0;
            if (o) {
                var m = o.getBoundingRect(), v = o.position[u] + m[f];
                p[u] = -v - l[f], e = Math.floor(g * (v + m[f] + h / 2) / l[c]), e = l[c] && g ? Math.max(0, Math.min(g - 1, e)) : -1;
                var y = {
                    x: 0,
                    y: 0
                };
                y[c] = h, y[d] = l[d], y[f] = -p[u] - l[f];
                var x, _ = s.children();
                if (s.eachChild(function(t, e) {
                    var i = n(t);
                    i.intersect(y) && (null == x && (x = e), a = t.__legendDataIndex), e === _.length - 1 && i[f] + i[c] <= y[f] + y[c] && (a = null);
                }), null != x) {
                    var w = n(_[x]);
                    if (y[f] = w[f] + w[c] - y[c], x <= 0 && w[f] >= y[f]) i = null; else {
                        for (;0 < x && n(_[x - 1]).intersect(y); ) x--;
                        i = _[x].__legendDataIndex;
                    }
                }
            }
            return {
                contentPosition: p,
                pageIndex: e,
                pageCount: g,
                pagePrevDataIndex: i,
                pageNextDataIndex: a
            };
        }
    });
    Fo("legendScroll", "legendscroll", function(t, e) {
        var i = t.scrollDataIndex;
        null != i && e.eachComponent({
            mainType: "legend",
            subType: "scroll",
            query: t
        }, function(t) {
            t.setScrollDataIndex(i);
        });
    }), Yo({
        type: "tooltip",
        dependencies: [ "axisPointer" ],
        defaultOption: {
            zlevel: 0,
            z: 8,
            show: !0,
            showContent: !0,
            trigger: "item",
            triggerOn: "mousemove|click",
            alwaysShowContent: !1,
            displayMode: "single",
            confine: !1,
            showDelay: 0,
            hideDelay: 100,
            transitionDuration: .4,
            enterable: !1,
            backgroundColor: "rgba(50,50,50,0.7)",
            borderColor: "#333",
            borderRadius: 4,
            borderWidth: 0,
            padding: 5,
            extraCssText: "",
            axisPointer: {
                type: "line",
                axis: "auto",
                animation: "auto",
                animationDurationUpdate: 200,
                animationEasingUpdate: "exponentialOut",
                crossStyle: {
                    color: "#999",
                    width: 1,
                    type: "dashed",
                    textStyle: {}
                }
            },
            textStyle: {
                color: "#fff",
                fontSize: 14
            }
        }
    });
    var jI = R, XI = Qn, YI = [ "", "-webkit-", "-moz-", "-o-" ];
    ad.prototype = {
        constructor: ad,
        _enterable: !0,
        update: function() {
            var t = this._container, e = t.currentStyle || document.defaultView.getComputedStyle(t), i = t.style;
            "absolute" !== i.position && "absolute" !== e.position && (i.position = "relative");
        },
        show: function(t) {
            clearTimeout(this._hideTimeout);
            var e = this.el;
            e.style.cssText = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;" + nd(t) + ";left:" + this._x + "px;top:" + this._y + "px;" + (t.get("extraCssText") || ""), 
            e.style.display = e.innerHTML ? "block" : "none", this._show = !0;
        },
        setContent: function(t) {
            this.el.innerHTML = null == t ? "" : t;
        },
        setEnterable: function(t) {
            this._enterable = t;
        },
        getSize: function() {
            var t = this.el;
            return [ t.clientWidth, t.clientHeight ];
        },
        moveTo: function(t, e) {
            var i, n = this._zr;
            n && n.painter && (i = n.painter.getViewportRootOffset()) && (t += i.offsetLeft, 
            e += i.offsetTop);
            var a = this.el.style;
            a.left = t + "px", a.top = e + "px", this._x = t, this._y = e;
        },
        hide: function() {
            this.el.style.display = "none", this._show = !1;
        },
        hideLater: function(t) {
            !this._show || this._inContent && this._enterable || (t ? (this._hideDelay = t, 
            this._show = !1, this._hideTimeout = setTimeout(_(this.hide, this), t)) : this.hide());
        },
        isShow: function() {
            return this._show;
        }
    };
    var qI = _, KI = R, $I = zn, JI = new Wv({
        shape: {
            x: -1,
            y: -1,
            width: 2,
            height: 2
        }
    });
    qo({
        type: "tooltip",
        init: function(t, e) {
            if (!Sp.node) {
                var i = new ad(e.getDom(), e);
                this._tooltipContent = i;
            }
        },
        render: function(t, e, i) {
            if (!Sp.node && !Sp.wxa) {
                this.group.removeAll(), this._tooltipModel = t, this._ecModel = e, this._api = i, 
                this._lastDataByCoordSys = null, this._alwaysShowContent = t.get("alwaysShowContent");
                var n = this._tooltipContent;
                n.update(), n.setEnterable(t.get("enterable")), this._initGlobalListener(), this._keepShow();
            }
        },
        _initGlobalListener: function() {
            var n = this._tooltipModel.get("triggerOn");
            fc("itemTooltip", this._api, qI(function(t, e, i) {
                "none" !== n && (0 <= n.indexOf(t) ? this._tryShow(e, i) : "leave" === t && this._hide(i));
            }, this));
        },
        _keepShow: function() {
            var t = this._tooltipModel, e = this._ecModel, i = this._api;
            if (null != this._lastX && null != this._lastY && "none" !== t.get("triggerOn")) {
                var n = this;
                clearTimeout(this._refreshUpdateTimeout), this._refreshUpdateTimeout = setTimeout(function() {
                    n.manuallyShowTip(t, e, i, {
                        x: n._lastX,
                        y: n._lastY
                    });
                });
            }
        },
        manuallyShowTip: function(t, e, i, n) {
            if (n.from !== this.uid && !Sp.node) {
                var a = rd(n, i);
                this._ticket = "";
                var o = n.dataByCoordSys;
                if (n.tooltip && null != n.x && null != n.y) {
                    var r = JI;
                    r.position = [ n.x, n.y ], r.update(), r.tooltip = n.tooltip, this._tryShow({
                        offsetX: n.x,
                        offsetY: n.y,
                        target: r
                    }, a);
                } else if (o) this._tryShow({
                    offsetX: n.x,
                    offsetY: n.y,
                    position: n.position,
                    event: {},
                    dataByCoordSys: n.dataByCoordSys,
                    tooltipOption: n.tooltipOption
                }, a); else if (null != n.seriesIndex) {
                    if (this._manuallyAxisShowTip(t, e, i, n)) return;
                    var s = oI(n, e), l = s.point[0], h = s.point[1];
                    null != l && null != h && this._tryShow({
                        offsetX: l,
                        offsetY: h,
                        position: n.position,
                        target: s.el,
                        event: {}
                    }, a);
                } else null != n.x && null != n.y && (i.dispatchAction({
                    type: "updateAxisPointer",
                    x: n.x,
                    y: n.y
                }), this._tryShow({
                    offsetX: n.x,
                    offsetY: n.y,
                    position: n.position,
                    target: i.getZr().findHover(n.x, n.y).target,
                    event: {}
                }, a));
            }
        },
        manuallyHideTip: function(t, e, i, n) {
            var a = this._tooltipContent;
            !this._alwaysShowContent && this._tooltipModel && a.hideLater(this._tooltipModel.get("hideDelay")), 
            this._lastX = this._lastY = null, n.from !== this.uid && this._hide(rd(n, i));
        },
        _manuallyAxisShowTip: function(t, e, i, n) {
            var a = n.seriesIndex, o = n.dataIndex, r = e.getComponent("axisPointer").coordSysAxesInfo;
            if (null != a && null != o && null != r) {
                var s = e.getSeriesByIndex(a);
                if (s && "axis" === (t = od([ s.getData().getItemModel(o), s, (s.coordinateSystem || {}).model, t ])).get("trigger")) return i.dispatchAction({
                    type: "updateAxisPointer",
                    seriesIndex: a,
                    dataIndex: o,
                    position: n.position
                }), !0;
            }
        },
        _tryShow: function(t, e) {
            var i = t.target;
            if (this._tooltipModel) {
                this._lastX = t.offsetX, this._lastY = t.offsetY;
                var n = t.dataByCoordSys;
                n && n.length ? this._showAxisTooltip(n, t) : i && null != i.dataIndex ? (this._lastDataByCoordSys = null, 
                this._showSeriesItemTooltip(t, i, e)) : i && i.tooltip ? (this._lastDataByCoordSys = null, 
                this._showComponentItemTooltip(t, i, e)) : (this._lastDataByCoordSys = null, this._hide(e));
            }
        },
        _showOrMove: function(t, e) {
            var i = t.get("showDelay");
            e = _(e, this), clearTimeout(this._showTimout), 0 < i ? this._showTimout = setTimeout(e, i) : e();
        },
        _showAxisTooltip: function(t, e) {
            var h = this._ecModel, i = this._tooltipModel, n = [ e.offsetX, e.offsetY ], u = [], c = [], a = od([ e.tooltipOption, i ]);
            KI(t, function(t) {
                KI(t.dataByAxis, function(a) {
                    var o = h.getComponent(a.axisDim + "Axis", a.axisIndex), r = a.value, s = [];
                    if (o && null != r) {
                        var l = Mc(r, o.axis, h, a.seriesDataIndices, a.valueLabelOpt);
                        R(a.seriesDataIndices, function(t) {
                            var e = h.getSeriesByIndex(t.seriesIndex), i = t.dataIndexInside, n = e && e.getDataParams(i);
                            n.axisDim = a.axisDim, n.axisIndex = a.axisIndex, n.axisType = a.axisType, n.axisId = a.axisId, 
                            n.axisValue = Or(o.axis, r), n.axisValueLabel = l, n && (c.push(n), s.push(e.formatTooltip(i, !0)));
                        });
                        var t = l;
                        u.push((t ? ta(t) + "<br />" : "") + s.join("<br />"));
                    }
                });
            }, this), u.reverse(), u = u.join("<br /><br />");
            var o = e.position;
            this._showOrMove(a, function() {
                this._updateContentNotChangedOnAxis(t) ? this._updatePosition(a, o, n[0], n[1], this._tooltipContent, c) : this._showTooltipContent(a, u, c, Math.random(), n[0], n[1], o);
            });
        },
        _showSeriesItemTooltip: function(t, e, i) {
            var n = this._ecModel, a = e.seriesIndex, o = n.getSeriesByIndex(a), r = e.dataModel || o, s = e.dataIndex, l = e.dataType, h = r.getData(), u = od([ h.getItemModel(s), r, o && (o.coordinateSystem || {}).model, this._tooltipModel ]), c = u.get("trigger");
            if (null == c || "item" === c) {
                var d = r.getDataParams(s, l), f = r.formatTooltip(s, !1, l), p = "item_" + r.name + "_" + s;
                this._showOrMove(u, function() {
                    this._showTooltipContent(u, f, d, p, t.offsetX, t.offsetY, t.position, t.target);
                }), i({
                    type: "showTip",
                    dataIndexInside: s,
                    dataIndex: h.getRawIndex(s),
                    seriesIndex: a,
                    from: this.uid
                });
            }
        },
        _showComponentItemTooltip: function(t, e, i) {
            var n = e.tooltip;
            if ("string" == typeof n) {
                n = {
                    content: n,
                    formatter: n
                };
            }
            var a = new Pn(n, this._tooltipModel, this._ecModel), o = a.get("content"), r = Math.random();
            this._showOrMove(a, function() {
                this._showTooltipContent(a, o, a.get("formatterParams") || {}, r, t.offsetX, t.offsetY, t.position, e);
            }), i({
                type: "showTip",
                from: this.uid
            });
        },
        _showTooltipContent: function(i, t, n, e, a, o, r, s) {
            if (this._ticket = "", i.get("showContent") && i.get("show")) {
                var l = this._tooltipContent, h = i.get("formatter");
                r = r || i.get("position");
                var u = t;
                if (h && "string" == typeof h) u = ea(h, n, !0); else if ("function" == typeof h) {
                    var c = qI(function(t, e) {
                        t === this._ticket && (l.setContent(e), this._updatePosition(i, r, a, o, l, n, s));
                    }, this);
                    this._ticket = e, u = h(n, e, c);
                }
                l.setContent(u), l.show(i), this._updatePosition(i, r, a, o, l, n, s);
            }
        },
        _updatePosition: function(t, e, i, n, a, o, r) {
            var s = this._api.getWidth(), l = this._api.getHeight();
            e = e || t.get("position");
            var h, u, c, d, f, p, g, m, v, y, x, _, w, b, S, M, I, T, D = a.getSize(), A = t.get("align"), C = t.get("verticalAlign"), L = r && r.getBoundingRect().clone();
            if (r && L.applyTransform(r.transform), "function" == typeof e && (e = e([ i, n ], o, a.el, L, {
                viewSize: [ s, l ],
                contentSize: D.slice()
            })), N(e)) i = $I(e[0], s), n = $I(e[1], l); else if (B(e)) {
                e.width = D[0], e.height = D[1];
                var k = la(e, {
                    width: s,
                    height: l
                });
                i = k.x, n = k.y, C = A = null;
            } else i = "string" == typeof e && r ? (P = function(t, e, i) {
                var n = i[0], a = i[1], o = 0, r = 0, s = e.width, l = e.height;
                switch (t) {
                  case "inside":
                    o = e.x + s / 2 - n / 2, r = e.y + l / 2 - a / 2;
                    break;

                  case "top":
                    o = e.x + s / 2 - n / 2, r = e.y - a - 5;
                    break;

                  case "bottom":
                    o = e.x + s / 2 - n / 2, r = e.y + l + 5;
                    break;

                  case "left":
                    o = e.x - n - 5, r = e.y + l / 2 - a / 2;
                    break;

                  case "right":
                    o = e.x + s + 5, r = e.y + l / 2 - a / 2;
                }
                return [ o, r ];
            }(e, L, D))[0] : (h = i, u = n, c = a.el, d = s, f = l, p = A ? null : 20, g = C ? null : 20, 
            m = sd(c), v = m.width, y = m.height, null != p && (d < h + v + p ? h -= v + p : h += p), 
            null != g && (f < u + y + g ? u -= y + g : u += g), P = [ h, u ])[0], n = P[1];
            if (A && (i -= ld(A) ? D[0] / 2 : "right" === A ? D[0] : 0), C && (n -= ld(C) ? D[1] / 2 : "bottom" === C ? D[1] : 0), 
            t.get("confine")) {
                var P = (x = i, _ = n, w = a.el, b = s, S = l, M = sd(w), I = M.width, T = M.height, 
                x = Math.min(x + I, b) - I, _ = Math.min(_ + T, S) - T, [ x = Math.max(x, 0), _ = Math.max(_, 0) ]);
                i = P[0], n = P[1];
            }
            a.moveTo(i, n);
        },
        _updateContentNotChangedOnAxis: function(n) {
            var t = this._lastDataByCoordSys, r = !!t && t.length === n.length;
            return r && KI(t, function(t, e) {
                var i = t.dataByAxis || {}, o = (n[e] || {}).dataByAxis || [];
                (r &= i.length === o.length) && KI(i, function(t, e) {
                    var i = o[e] || {}, n = t.seriesDataIndices || [], a = i.seriesDataIndices || [];
                    (r &= t.value === i.value && t.axisType === i.axisType && t.axisId === i.axisId && n.length === a.length) && KI(n, function(t, e) {
                        var i = a[e];
                        r &= t.seriesIndex === i.seriesIndex && t.dataIndex === i.dataIndex;
                    });
                });
            }), this._lastDataByCoordSys = n, !!r;
        },
        _hide: function(t) {
            this._lastDataByCoordSys = null, t({
                type: "hideTip",
                from: this.uid
            });
        },
        dispose: function(t, e) {
            Sp.node || Sp.wxa || (this._tooltipContent.hide(), mc("itemTooltip", e));
        }
    }), Fo({
        type: "showTip",
        event: "showTip",
        update: "tooltip:manuallyShowTip"
    }, function() {}), Fo({
        type: "hideTip",
        event: "hideTip",
        update: "tooltip:manuallyHideTip"
    }, function() {}), cd.prototype = {
        constructor: cd,
        pointToData: function(t, e) {
            return this.polar.pointToData(t, e)["radius" === this.dim ? 0 : 1];
        },
        dataToRadius: aw.prototype.dataToCoord,
        radiusToData: aw.prototype.coordToData
    }, o(cd, aw), dd.prototype = {
        constructor: dd,
        pointToData: function(t, e) {
            return this.polar.pointToData(t, e)["radius" === this.dim ? 0 : 1];
        },
        dataToAngle: aw.prototype.dataToCoord,
        angleToData: aw.prototype.coordToData
    }, o(dd, aw);
    var QI = function(t) {
        this.name = t || "", this.cx = 0, this.cy = 0, this._radiusAxis = new cd(), this._angleAxis = new dd(), 
        this._radiusAxis.polar = this._angleAxis.polar = this;
    };
    QI.prototype = {
        type: "polar",
        axisPointerEnabled: !0,
        constructor: QI,
        dimensions: [ "radius", "angle" ],
        model: null,
        containPoint: function(t) {
            var e = this.pointToCoord(t);
            return this._radiusAxis.contain(e[0]) && this._angleAxis.contain(e[1]);
        },
        containData: function(t) {
            return this._radiusAxis.containData(t[0]) && this._angleAxis.containData(t[1]);
        },
        getAxis: function(t) {
            return this["_" + t + "Axis"];
        },
        getAxes: function() {
            return [ this._radiusAxis, this._angleAxis ];
        },
        getAxesByScale: function(t) {
            var e = [], i = this._angleAxis, n = this._radiusAxis;
            return i.scale.type === t && e.push(i), n.scale.type === t && e.push(n), e;
        },
        getAngleAxis: function() {
            return this._angleAxis;
        },
        getRadiusAxis: function() {
            return this._radiusAxis;
        },
        getOtherAxis: function(t) {
            var e = this._angleAxis;
            return t === e ? this._radiusAxis : e;
        },
        getBaseAxis: function() {
            return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAngleAxis();
        },
        getTooltipAxes: function(t) {
            var e = null != t && "auto" !== t ? this.getAxis(t) : this.getBaseAxis();
            return {
                baseAxes: [ e ],
                otherAxes: [ this.getOtherAxis(e) ]
            };
        },
        dataToPoint: function(t, e) {
            return this.coordToPoint([ this._radiusAxis.dataToRadius(t[0], e), this._angleAxis.dataToAngle(t[1], e) ]);
        },
        pointToData: function(t, e) {
            var i = this.pointToCoord(t);
            return [ this._radiusAxis.radiusToData(i[0], e), this._angleAxis.angleToData(i[1], e) ];
        },
        pointToCoord: function(t) {
            var e = t[0] - this.cx, i = t[1] - this.cy, n = this.getAngleAxis(), a = n.getExtent(), o = Math.min(a[0], a[1]), r = Math.max(a[0], a[1]);
            n.inverse ? o = r - 360 : r = o + 360;
            var s = Math.sqrt(e * e + i * i);
            e /= s, i /= s;
            for (var l = Math.atan2(-i, e) / Math.PI * 180, h = l < o ? 1 : -1; l < o || r < l; ) l += 360 * h;
            return [ s, l ];
        },
        coordToPoint: function(t) {
            var e = t[0], i = t[1] / 180 * Math.PI;
            return [ Math.cos(i) * e + this.cx, -Math.sin(i) * e + this.cy ];
        }
    };
    var tT = Cy.extend({
        type: "polarAxis",
        axis: null,
        getCoordSysModel: function() {
            return this.ecModel.queryComponents({
                mainType: "polar",
                index: this.option.polarIndex,
                id: this.option.polarId
            })[0];
        }
    });
    g(tT.prototype, Z_);
    var eT = {
        splitNumber: 5
    };
    kw("angle", tT, fd, {
        startAngle: 90,
        clockwise: !0,
        splitNumber: 12,
        axisLabel: {
            rotate: !1
        }
    }), kw("radius", tT, fd, eT), Yo({
        type: "polar",
        dependencies: [ "polarAxis", "angleAxis" ],
        coordinateSystem: null,
        findAxisModel: function(t) {
            var e;
            return this.ecModel.eachComponent(t, function(t) {
                t.getCoordSysModel() === this && (e = t);
            }, this), e;
        },
        defaultOption: {
            zlevel: 0,
            z: 0,
            center: [ "50%", "50%" ],
            radius: "80%"
        }
    }), Ma.register("polar", {
        dimensions: QI.prototype.dimensions,
        create: function(i, s) {
            var l = [];
            return i.eachComponent("polar", function(t, e) {
                var i = new QI(e);
                i.update = pd;
                var n = i.getRadiusAxis(), a = i.getAngleAxis(), o = t.findAxisModel("radiusAxis"), r = t.findAxisModel("angleAxis");
                gd(n, o), gd(a, r), function(t, e, i) {
                    var n = e.get("center"), a = i.getWidth(), o = i.getHeight();
                    t.cx = zn(n[0], a), t.cy = zn(n[1], o);
                    var r = t.getRadiusAxis(), s = Math.min(a, o) / 2, l = zn(e.get("radius"), s);
                    r.inverse ? r.setExtent(l, 0) : r.setExtent(0, l);
                }(i, t, s), l.push(i), (t.coordinateSystem = i).model = t;
            }), i.eachSeries(function(t) {
                if ("polar" === t.get("coordinateSystem")) {
                    var e = i.queryComponents({
                        mainType: "polar",
                        index: t.get("polarIndex"),
                        id: t.get("polarId")
                    })[0];
                    t.coordinateSystem = e.coordinateSystem;
                }
            }), l;
        }
    });
    var iT = [ "axisLine", "axisLabel", "axisTick", "splitLine", "splitArea" ];
    Xw.extend({
        type: "angleAxis",
        axisPointerClass: "PolarAxisPointer",
        render: function(e, t) {
            if (this.group.removeAll(), e.get("show")) {
                var i = e.axis, n = i.polar, a = n.getRadiusAxis().getExtent(), o = i.getTicksCoords();
                "category" !== i.type && o.pop(), R(iT, function(t) {
                    !e.get(t + ".show") || i.scale.isBlank() && "axisLine" !== t || this["_" + t](e, n, o, a);
                }, this);
            }
        },
        _axisLine: function(t, e, i, n) {
            var a = t.getModel("axisLine.lineStyle"), o = new Ov({
                shape: {
                    cx: e.cx,
                    cy: e.cy,
                    r: n[vd(e)]
                },
                style: a.getLineStyle(),
                z2: 1,
                silent: !0
            });
            o.style.fill = null, this.group.add(o);
        },
        _axisTick: function(t, e, i, n) {
            var a = t.getModel("axisTick"), o = (a.get("inside") ? -1 : 1) * a.get("length"), r = n[vd(e)], s = L(i, function(t) {
                return new Fv({
                    shape: md(e, [ r, r + o ], t)
                });
            });
            this.group.add(ey(s, {
                style: E(a.getModel("lineStyle").getLineStyle(), {
                    stroke: t.get("axisLine.lineStyle.color")
                })
            }));
        },
        _axisLabel: function(t, e, i, n) {
            for (var a = t.axis, o = t.getCategories(!0), r = t.getModel("axisLabel"), s = t.getFormattedLabels(), l = r.get("margin"), h = a.getLabelsCoords(), u = a.scale.getTicks(), c = 0; c < u.length; c++) {
                var d = r, f = u[c], p = n[vd(e)], g = e.coordToPoint([ p + l, h[c] ]), m = e.cx, v = e.cy, y = Math.abs(g[0] - m) / p < .3 ? "center" : g[0] > m ? "left" : "right", x = Math.abs(g[1] - v) / p < .3 ? "middle" : g[1] > v ? "top" : "bottom";
                o && o[f] && o[f].textStyle && (d = new Pn(o[f].textStyle, r, r.ecModel));
                var _ = new Nv({
                    silent: !0
                });
                this.group.add(_), vn(_.style, d, {
                    x: g[0],
                    y: g[1],
                    textFill: d.getTextColor() || t.get("axisLine.lineStyle.color"),
                    text: s[c],
                    textAlign: y,
                    textVerticalAlign: x
                });
            }
        },
        _splitLine: function(t, e, i, n) {
            var a = t.getModel("splitLine").getModel("lineStyle"), o = a.get("color"), r = 0;
            o = o instanceof Array ? o : [ o ];
            for (var s = [], l = 0; l < i.length; l++) {
                var h = r++ % o.length;
                s[h] = s[h] || [], s[h].push(new Fv({
                    shape: md(e, n, i[l])
                }));
            }
            for (l = 0; l < s.length; l++) this.group.add(ey(s[l], {
                style: E({
                    stroke: o[l % o.length]
                }, a.getLineStyle()),
                silent: !0,
                z: t.get("z")
            }));
        },
        _splitArea: function(t, e, i, n) {
            var a = t.getModel("splitArea").getModel("areaStyle"), o = a.get("color"), r = 0;
            o = o instanceof Array ? o : [ o ];
            for (var s = [], l = Math.PI / 180, h = -i[0] * l, u = Math.min(n[0], n[1]), c = Math.max(n[0], n[1]), d = t.get("clockwise"), f = 1; f < i.length; f++) {
                var p = r++ % o.length;
                s[p] = s[p] || [], s[p].push(new zv({
                    shape: {
                        cx: e.cx,
                        cy: e.cy,
                        r0: u,
                        r: c,
                        startAngle: h,
                        endAngle: -i[f] * l,
                        clockwise: d
                    },
                    silent: !0
                })), h = -i[f] * l;
            }
            for (f = 0; f < s.length; f++) this.group.add(ey(s[f], {
                style: E({
                    fill: o[f % o.length]
                }, a.getAreaStyle()),
                silent: !0
            }));
        }
    });
    var nT = [ "axisLine", "axisTickLabel", "axisName" ], aT = [ "splitLine", "splitArea" ];
    Xw.extend({
        type: "radiusAxis",
        axisPointerClass: "PolarAxisPointer",
        render: function(e, t) {
            if (this.group.removeAll(), e.get("show")) {
                var i = e.axis, n = i.polar, a = n.getAngleAxis(), o = i.getTicksCoords(), r = a.getExtent()[0], s = i.getExtent(), l = (c = e, 
                d = r, {
                    position: [ (u = n).cx, u.cy ],
                    rotation: d / 180 * Math.PI,
                    labelDirection: -1,
                    tickDirection: -1,
                    nameDirection: 1,
                    labelRotate: c.getModel("axisLabel").get("rotate"),
                    z2: 1
                }), h = new Gw(e, l);
                R(nT, h.add, h), this.group.add(h.getGroup()), R(aT, function(t) {
                    e.get(t + ".show") && !i.scale.isBlank() && this["_" + t](e, n, r, s, o);
                }, this);
            }
            var u, c, d;
        },
        _splitLine: function(t, e, i, n, a) {
            var o = t.getModel("splitLine").getModel("lineStyle"), r = o.get("color"), s = 0;
            r = r instanceof Array ? r : [ r ];
            for (var l = [], h = 0; h < a.length; h++) {
                var u = s++ % r.length;
                l[u] = l[u] || [], l[u].push(new Ov({
                    shape: {
                        cx: e.cx,
                        cy: e.cy,
                        r: a[h]
                    },
                    silent: !0
                }));
            }
            for (h = 0; h < l.length; h++) this.group.add(ey(l[h], {
                style: E({
                    stroke: r[h % r.length],
                    fill: null
                }, o.getLineStyle()),
                silent: !0
            }));
        },
        _splitArea: function(t, e, i, n, a) {
            var o = t.getModel("splitArea").getModel("areaStyle"), r = o.get("color"), s = 0;
            r = r instanceof Array ? r : [ r ];
            for (var l = [], h = a[0], u = 1; u < a.length; u++) {
                var c = s++ % r.length;
                l[c] = l[c] || [], l[c].push(new zv({
                    shape: {
                        cx: e.cx,
                        cy: e.cy,
                        r0: h,
                        r: a[u],
                        startAngle: 0,
                        endAngle: 2 * Math.PI
                    },
                    silent: !0
                })), h = a[u];
            }
            for (u = 0; u < l.length; u++) this.group.add(ey(l[u], {
                style: E({
                    fill: r[u % r.length]
                }, o.getAreaStyle()),
                silent: !0
            }));
        }
    });
    var oT = vc.extend({
        makeElOption: function(t, e, i, n, a) {
            var o = i.axis;
            "angle" === o.dim && (this.animationThreshold = Math.PI / 18);
            var r, s = o.polar, l = s.getOtherAxis(o).getExtent();
            r = o["dataTo" + ra(o.dim)](e);
            var h = n.get("type");
            if (h && "none" !== h) {
                var u = bc(n), c = rT[h](o, s, r, l, u);
                c.style = u, t.graphicKey = c.type, t.pointer = c;
            }
            Sc(t, i, n, a, function(t, e, i, n, a) {
                var o = e.axis, r = o.dataToCoord(t), s = n.getAngleAxis().getExtent()[0];
                s = s / 180 * Math.PI;
                var l, h, u, c = n.getRadiusAxis().getExtent();
                if ("radius" === o.dim) {
                    var d = rt();
                    ct(d, d, s), ut(d, d, [ n.cx, n.cy ]), l = Dn([ r, -a ], d);
                    var f = e.getModel("axisLabel").get("rotate") || 0, p = Gw.innerTextLayout(s, f * Math.PI / 180, -1);
                    h = p.textAlign, u = p.textVerticalAlign;
                } else {
                    var g = c[1];
                    l = n.coordToPoint([ g + a, r ]);
                    var m = n.cx, v = n.cy;
                    h = Math.abs(l[0] - m) / g < .3 ? "center" : l[0] > m ? "left" : "right", u = Math.abs(l[1] - v) / g < .3 ? "middle" : l[1] > v ? "top" : "bottom";
                }
                return {
                    position: l,
                    align: h,
                    verticalAlign: u
                };
            }(e, i, 0, s, n.get("label.margin")));
        }
    }), rT = {
        line: function(t, e, i, n, a) {
            return "angle" === t.dim ? {
                type: "Line",
                shape: Dc(e.coordToPoint([ n[0], i ]), e.coordToPoint([ n[1], i ]))
            } : {
                type: "Circle",
                shape: {
                    cx: e.cx,
                    cy: e.cy,
                    r: i
                }
            };
        },
        shadow: function(t, e, i, n, a) {
            var o = t.getBandWidth(), r = Math.PI / 180;
            return "angle" === t.dim ? {
                type: "Sector",
                shape: Cc(e.cx, e.cy, n[0], n[1], (-i - o / 2) * r, (o / 2 - i) * r)
            } : {
                type: "Sector",
                shape: Cc(e.cx, e.cy, i - o / 2, i + o / 2, 0, 2 * Math.PI)
            };
        }
    };
    Xw.registerAxisPointerClass("PolarAxisPointer", oT), Zo(z(function(t, e, i) {
        var P = i.getWidth(), N = i.getHeight(), O = {}, E = function(t, e) {
            var f = {};
            R(t, function(t, e) {
                var i = t.getData(), n = t.coordinateSystem.getBaseAxis(), a = n.getExtent(), o = "category" === n.type ? n.getBandWidth() : Math.abs(a[1] - a[0]) / i.count(), r = f[ud(n)] || {
                    bandWidth: o,
                    remainedWidth: o,
                    autoWidthCount: 0,
                    categoryGap: "20%",
                    gap: "30%",
                    stacks: {}
                }, s = r.stacks;
                f[ud(n)] = r;
                var l = hd(t);
                s[l] || r.autoWidthCount++, s[l] = s[l] || {
                    width: 0,
                    maxWidth: 0
                };
                var h = zn(t.get("barWidth"), o), u = zn(t.get("barMaxWidth"), o), c = t.get("barGap"), d = t.get("barCategoryGap");
                h && !s[l].width && (h = Math.min(r.remainedWidth, h), s[l].width = h, r.remainedWidth -= h), 
                u && (s[l].maxWidth = u), null != c && (r.gap = c), null != d && (r.categoryGap = d);
            });
            var d = {};
            return R(f, function(t, i) {
                d[i] = {};
                var e = t.stacks, n = t.bandWidth, a = zn(t.categoryGap, n), o = zn(t.gap, 1), r = t.remainedWidth, s = t.autoWidthCount, l = (r - a) / (s + (s - 1) * o);
                l = Math.max(l, 0), R(e, function(t, e) {
                    var i = t.maxWidth;
                    i && i < l && (i = Math.min(i, r), t.width && (i = Math.min(i, t.width)), r -= i, 
                    t.width = i, s--);
                }), l = (r - a) / (s + (s - 1) * o), l = Math.max(l, 0);
                var h, u = 0;
                R(e, function(t, e) {
                    t.width || (t.width = l), u += (h = t).width * (1 + o);
                }), h && (u -= h.width * o);
                var c = -u / 2;
                R(e, function(t, e) {
                    d[i][e] = d[i][e] || {
                        offset: c,
                        width: t.width
                    }, c += t.width * (1 + o);
                });
            }), d;
        }(I(e.getSeriesByType(t), function(t) {
            return !e.isSeriesFiltered(t) && t.coordinateSystem && "polar" === t.coordinateSystem.type;
        }));
        e.eachSeriesByType(t, function(t) {
            if ("polar" === t.coordinateSystem.type) {
                var e = t.getData(), i = t.coordinateSystem, n = i.getBaseAxis(), a = hd(t), o = E[ud(n)][a], r = o.offset, s = o.width, l = i.getOtherAxis(n), h = t.get("center") || [ "50%", "50%" ], u = zn(h[0], P), c = zn(h[1], N), d = t.get("barMinHeight") || 0, f = t.get("barMinAngle") || 0;
                O[a] = O[a] || [];
                for (var p = e.mapDimension(l.dim), g = e.mapDimension(n.dim), m = pr(e, p, g), v = l.getExtent()[0], y = 0, x = e.count(); y < x; y++) {
                    var _ = e.get(p, y), w = e.get(g, y);
                    if (!isNaN(_)) {
                        var b, S, M, I, T = 0 <= _ ? "p" : "n", D = v;
                        if (m && (O[a][w] || (O[a][w] = {
                            p: v,
                            n: v
                        }), D = O[a][w][T]), "radius" === l.dim) {
                            var A = l.dataToRadius(_) - v, C = n.dataToAngle(w);
                            Math.abs(A) < d && (A = (A < 0 ? -1 : 1) * d), S = (b = D) + A, I = (M = C - r) - s, 
                            m && (O[a][w][T] = S);
                        } else {
                            var L = l.dataToAngle(_, !0) - v, k = n.dataToRadius(w);
                            Math.abs(L) < f && (L = (L < 0 ? -1 : 1) * f), S = (b = k + r) + s, I = (M = D) + L, 
                            m && (O[a][w][T] = I);
                        }
                        e.setItemLayout(y, {
                            cx: u,
                            cy: c,
                            r0: b,
                            r: S,
                            startAngle: -M * Math.PI / 180,
                            endAngle: -I * Math.PI / 180
                        });
                    }
                }
            }
        }, this);
    }, "bar")), qo({
        type: "polar"
    }), a(Cy.extend({
        type: "geo",
        coordinateSystem: null,
        layoutMode: "box",
        init: function(t) {
            Cy.prototype.init.apply(this, arguments), ti(t, "label", [ "show" ]);
        },
        optionUpdated: function() {
            var t = this.option, i = this;
            t.regions = Cb.getFilledRegions(t.regions, t.map, t.nameMap), this._optionModelMap = p(t.regions || [], function(t, e) {
                return e.name && t.set(e.name, new Pn(e, i)), t;
            }, W()), this.updateSelectedMap(t.regions);
        },
        defaultOption: {
            zlevel: 0,
            z: 0,
            show: !0,
            left: "center",
            top: "center",
            aspectScale: .75,
            silent: !1,
            map: "",
            boundingCoords: null,
            center: null,
            zoom: 1,
            scaleLimit: null,
            label: {
                show: !1,
                color: "#000"
            },
            itemStyle: {
                borderWidth: .5,
                borderColor: "#444",
                color: "#eee"
            },
            emphasis: {
                label: {
                    show: !0,
                    color: "rgb(100,0,0)"
                },
                itemStyle: {
                    color: "rgba(255,215,0,0.8)"
                }
            },
            regions: []
        },
        getRegionModel: function(t) {
            return this._optionModelMap.get(t) || new Pn(null, this, this.ecModel);
        },
        getFormattedLabel: function(t, e) {
            var i = this.getRegionModel(t).get("label." + e + ".formatter"), n = {
                name: t
            };
            return "function" == typeof i ? (n.status = e, i(n)) : "string" == typeof i ? i.replace("{a}", null != t ? t : "") : void 0;
        },
        setZoom: function(t) {
            this.option.zoom = t;
        },
        setCenter: function(t) {
            this.option.center = t;
        }
    }), rb), qo({
        type: "geo",
        init: function(t, e) {
            var i = new dl(e, !0);
            this._mapDraw = i, this.group.add(i.group);
        },
        render: function(t, e, i, n) {
            if (!n || "geoToggleSelect" !== n.type || n.from !== this.uid) {
                var a = this._mapDraw;
                t.get("show") ? a.draw(t, e, i, this, n) : this._mapDraw.group.removeAll(), this.group.silent = t.get("silent");
            }
        },
        dispose: function() {
            this._mapDraw && this._mapDraw.remove();
        }
    }), yd("toggleSelected", {
        type: "geoToggleSelect",
        event: "geoselectchanged"
    }), yd("select", {
        type: "geoSelect",
        event: "geoselected"
    }), yd("unSelect", {
        type: "geoUnSelect",
        event: "geounselected"
    });
    var sT = [ "rect", "polygon", "keep", "clear" ], lT = R, hT = {
        lineX: bd(0),
        lineY: bd(1),
        rect: {
            point: function(t, e, i) {
                return t && i.boundingRect.contain(t[0], t[1]);
            },
            rect: function(t, e, i) {
                return t && i.boundingRect.intersect(t);
            }
        },
        polygon: {
            point: function(t, e, i) {
                return t && i.boundingRect.contain(t[0], t[1]) && Br(i.range, t[0], t[1]);
            },
            rect: function(t, e, i) {
                var n = i.range;
                if (!t || n.length <= 1) return !1;
                var a = t.x, o = t.y, r = t.width, s = t.height, l = n[0];
                return !!(Br(n, a, o) || Br(n, a + r, o) || Br(n, a, o + s) || Br(n, a + r, o + s) || Xt.create(t).contain(l[0], l[1]) || Md(a, o, a + r, o, n) || Md(a, o, a, o + s, n) || Md(a + r, o, a + r, o + s, n) || Md(a, o + s, a + r, o + s, n)) || void 0;
            }
        }
    }, uT = R, cT = C, dT = z, fT = [ "dataToPoint", "pointToData" ], pT = [ "grid", "xAxis", "yAxis", "geo", "graph", "polar", "radiusAxis", "angleAxis", "bmap" ], gT = Dd.prototype;
    gT.setOutputRanges = function(t, e) {
        this.matchOutputRanges(t, e, function(t, e, i) {
            if ((t.coordRanges || (t.coordRanges = [])).push(e), !t.coordRange) {
                t.coordRange = e;
                var n = xT[t.brushType](0, i, e);
                t.__rangeOffset = {
                    offset: _T[t.brushType](n.values, t.range, [ 1, 1 ]),
                    xyMinMax: n.xyMinMax
                };
            }
        });
    }, gT.matchOutputRanges = function(t, n, a) {
        uT(t, function(i) {
            var t = this.findTargetInfo(i, n);
            t && !0 !== t && R(t.coordSyses, function(t) {
                var e = xT[i.brushType](1, t, i.range);
                a(i, e.values, t, n);
            });
        }, this);
    }, gT.setInputRanges = function(t, h) {
        uT(t, function(t) {
            var e, i, n, a, o, r = this.findTargetInfo(t, h);
            if (t.range = t.range || [], r && !0 !== r) {
                t.panelId = r.panelId;
                var s = xT[t.brushType](0, r.coordSys, t.coordRange), l = t.__rangeOffset;
                t.range = l ? _T[t.brushType](s.values, l.offset, (e = s.xyMinMax, i = l.xyMinMax, 
                n = Pd(e), a = Pd(i), o = [ n[0] / a[0], n[1] / a[1] ], isNaN(o[0]) && (o[0] = 1), 
                isNaN(o[1]) && (o[1] = 1), o)) : s.values;
            }
        }, this);
    }, gT.makePanelOpts = function(i, n) {
        return L(this._targetInfoList, function(t) {
            var e = t.getPanelRect();
            return {
                panelId: t.panelId,
                defaultBrushType: n && n(t),
                clipPath: su(e),
                isTargetByCursor: hu(e, i, t.coordSysModel),
                getLinearBrushOtherExtent: lu(e)
            };
        });
    }, gT.controlSeries = function(t, e, i) {
        var n = this.findTargetInfo(t, i);
        return !0 === n || n && 0 <= cT(n.coordSyses, e.coordinateSystem);
    }, gT.findTargetInfo = function(t, e) {
        for (var i = this._targetInfoList, n = Cd(e, t), a = 0; a < i.length; a++) {
            var o = i[a], r = t.panelId;
            if (r) {
                if (o.panelId === r) return o;
            } else for (a = 0; a < vT.length; a++) if (vT[a](n, o)) return o;
        }
        return !0;
    };
    var mT = {
        grid: function(t, n) {
            var a = t.xAxisModels, o = t.yAxisModels, e = t.gridModels, i = W(), r = {}, s = {};
            (a || o || e) && (uT(a, function(t) {
                var e = t.axis.grid.model;
                i.set(e.id, e), r[e.id] = !0;
            }), uT(o, function(t) {
                var e = t.axis.grid.model;
                i.set(e.id, e), s[e.id] = !0;
            }), uT(e, function(t) {
                i.set(t.id, t), r[t.id] = !0, s[t.id] = !0;
            }), i.each(function(t) {
                var e = t.coordinateSystem, i = [];
                uT(e.getCartesians(), function(t, e) {
                    (0 <= cT(a, t.getAxis("x").model) || 0 <= cT(o, t.getAxis("y").model)) && i.push(t);
                }), n.push({
                    panelId: "grid--" + t.id,
                    gridModel: t,
                    coordSysModel: t,
                    coordSys: i[0],
                    coordSyses: i,
                    getPanelRect: yT.grid,
                    xAxisDeclared: r[t.id],
                    yAxisDeclared: s[t.id]
                });
            }));
        },
        geo: function(t, i) {
            uT(t.geoModels, function(t) {
                var e = t.coordinateSystem;
                i.push({
                    panelId: "geo--" + t.id,
                    geoModel: t,
                    coordSysModel: t,
                    coordSys: e,
                    coordSyses: [ e ],
                    getPanelRect: yT.geo
                });
            });
        }
    }, vT = [ function(t, e) {
        var i = t.xAxisModel, n = t.yAxisModel, a = t.gridModel;
        return !a && i && (a = i.axis.grid.model), !a && n && (a = n.axis.grid.model), a && a === e.gridModel;
    }, function(t, e) {
        var i = t.geoModel;
        return i && i === e.geoModel;
    } ], yT = {
        grid: function() {
            return this.coordSys.grid.getRect().clone();
        },
        geo: function() {
            var t = this.coordSys, e = t.getBoundingRect().clone();
            return e.applyTransform(Tn(t)), e;
        }
    }, xT = {
        lineX: dT(Ld, 0),
        lineY: dT(Ld, 1),
        rect: function(t, e, i) {
            var n = e[fT[t]]([ i[0][0], i[1][0] ]), a = e[fT[t]]([ i[0][1], i[1][1] ]), o = [ Ad([ n[0], a[0] ]), Ad([ n[1], a[1] ]) ];
            return {
                values: o,
                xyMinMax: o
            };
        },
        polygon: function(i, n, t) {
            var a = [ [ 1 / 0, -1 / 0 ], [ 1 / 0, -1 / 0 ] ];
            return {
                values: L(t, function(t) {
                    var e = n[fT[i]](t);
                    return a[0][0] = Math.min(a[0][0], e[0]), a[1][0] = Math.min(a[1][0], e[1]), a[0][1] = Math.max(a[0][1], e[0]), 
                    a[1][1] = Math.max(a[1][1], e[1]), e;
                }),
                xyMinMax: a
            };
        }
    }, _T = {
        lineX: dT(kd, 0),
        lineY: dT(kd, 1),
        rect: function(t, e, i) {
            return [ [ t[0][0] - i[0] * e[0][0], t[0][1] - i[0] * e[0][1] ], [ t[1][0] - i[1] * e[1][0], t[1][1] - i[1] * e[1][1] ] ];
        },
        polygon: function(t, i, n) {
            return L(t, function(t, e) {
                return [ t[0] - n[0] * i[e][0], t[1] - n[1] * i[e][1] ];
            });
        }
    }, wT = [ "inBrush", "outOfBrush" ], bT = "__ecBrushSelect", ST = "__ecInBrushSelectEvent", MT = Zx.VISUAL.BRUSH;
    Zo(MT, function(e, t, i) {
        e.eachComponent({
            mainType: "brush"
        }, function(t) {
            i && "takeGlobalCursor" === i.type && t.setBrushOption("brush" === i.key ? i.brushOption : {
                brushType: !1
            }), (t.brushTargetManager = new Dd(t.option, e)).setInputRanges(t.areas, e);
        });
    }), Uo(MT, function(m, t, e) {
        var a, o, v = [];
        m.eachComponent({
            mainType: "brush"
        }, function(s, t) {
            function l(t) {
                return "all" === i || n[t];
            }
            function h(t) {
                return !!t.length;
            }
            function r(e, t, i) {
                var n, a, o = Ed(e);
                if (o && (n = t, null == (a = s.option.seriesIndex) || "all" === a || !(N(a) ? C(a, n) < 0 : n !== a)) && (R(p, function(t) {
                    o[t.brushType] && s.brushTargetManager.controlSeries(t, e, m) && i.push(t), f |= h(i);
                }), l(t) && h(i))) {
                    var r = e.getData();
                    r.each(function(t) {
                        Od(o, i, r, t) && (c[t] = 1);
                    });
                }
            }
            var u = {
                brushId: s.id,
                brushIndex: t,
                brushName: s.name,
                areas: A(s.areas),
                selected: []
            };
            v.push(u);
            var e = s.option, i = e.brushLink, n = [], c = [], d = [], f = 0;
            t || (a = e.throttleType, o = e.throttleDelay);
            var p = L(s.areas, function(t) {
                return i = E({
                    boundingRect: IT[t.brushType](t)
                }, t), n = i.selectors = {}, R(hT[i.brushType], function(e, t) {
                    n[t] = function(t) {
                        return e(t, n, i);
                    };
                }), i;
                var i, n;
            }), g = _d(s.option, wT, function(t) {
                t.mappingMethod = "fixed";
            });
            N(i) && R(i, function(t) {
                n[t] = 1;
            }), m.eachSeries(function(t, e) {
                var i, n, a, o = d[e] = [];
                "parallel" === t.subType ? (n = e, a = (i = t).coordinateSystem, f |= a.hasAxisBrushed(), 
                l(n) && a.eachActiveState(i.getData(), function(t, e) {
                    "active" === t && (c[e] = 1);
                })) : r(t, e, o);
            }), m.eachSeries(function(t, e) {
                var i = {
                    seriesId: t.id,
                    seriesIndex: e,
                    seriesName: t.name,
                    dataIndex: []
                };
                u.selected.push(i);
                var n = Ed(t), a = d[e], o = t.getData(), r = l(e) ? function(t) {
                    return c[t] ? (i.dataIndex.push(o.getRawIndex(t)), "inBrush") : "outOfBrush";
                } : function(t) {
                    return Od(n, a, o, t) ? (i.dataIndex.push(o.getRawIndex(t)), "inBrush") : "outOfBrush";
                };
                (l(e) ? f : h(a)) && function(t, h, u, c, d, f) {
                    function p(t) {
                        return u.getItemVisual(m, t);
                    }
                    function g(t, e) {
                        u.setItemVisual(m, t, e);
                    }
                    function e(t, e) {
                        m = null == f ? t : e;
                        var i = u.getRawDataItem(m);
                        if (!i || !1 !== i.visualMap) for (var n = c.call(d, t), a = h[n], o = v[n], r = 0, s = o.length; r < s; r++) {
                            var l = o[r];
                            a[l] && a[l].applyVisual(t, p, g);
                        }
                    }
                    var m, v = {};
                    R(t, function(t) {
                        var e = eS.prepareVisualTypes(h[t]);
                        v[t] = e;
                    }), null == f ? u.each(e) : u.each([ f ], e);
                }(wT, g, o, r);
            });
        }), function(t, e, i, n, a) {
            if (a) {
                var o = t.getZr();
                o[ST] || (o[bT] || (o[bT] = Nd), ro(o, bT, i, e)(t, n));
            }
        }(t, a, o, v, e);
    });
    var IT = {
        lineX: S,
        lineY: S,
        rect: function(t) {
            return Rd(t.range);
        },
        polygon: function(t) {
            for (var e, i = t.range, n = 0, a = i.length; n < a; n++) {
                e = e || [ [ 1 / 0, -1 / 0 ], [ 1 / 0, -1 / 0 ] ];
                var o = i[n];
                o[0] < e[0][0] && (e[0][0] = o[0]), o[0] > e[0][1] && (e[0][1] = o[0]), o[1] < e[1][0] && (e[1][0] = o[1]), 
                o[1] > e[1][1] && (e[1][1] = o[1]);
            }
            return e && Rd(e);
        }
    }, TT = [ "#ddd" ];
    Yo({
        type: "brush",
        dependencies: [ "geo", "grid", "xAxis", "yAxis", "parallel", "series" ],
        defaultOption: {
            toolbox: null,
            brushLink: null,
            seriesIndex: "all",
            geoIndex: null,
            xAxisIndex: null,
            yAxisIndex: null,
            brushType: "rect",
            brushMode: "single",
            transformable: !0,
            brushStyle: {
                borderWidth: 1,
                color: "rgba(120,140,180,0.3)",
                borderColor: "rgba(120,140,180,0.8)"
            },
            throttleType: "fixRate",
            throttleDelay: 0,
            removeOnClick: !0,
            z: 1e4
        },
        areas: [],
        brushType: null,
        brushOption: {},
        coordInfoList: [],
        optionUpdated: function(t, e) {
            var i = this.option;
            !e && wd(i, t, [ "inBrush", "outOfBrush" ]), i.inBrush = i.inBrush || {}, i.outOfBrush = i.outOfBrush || {
                color: TT
            };
        },
        setAreas: function(t) {
            t && (this.areas = L(t, function(t) {
                return zd(this.option, t);
            }, this));
        },
        setBrushOption: function(t) {
            this.brushOption = zd(this.option, t), this.brushType = this.brushOption.brushType;
        }
    }), qo({
        type: "brush",
        init: function(t, e) {
            this.ecModel = t, this.api = e, this.model, (this._brushController = new kh(e.getZr())).on("brush", _(this._onBrush, this)).mount();
        },
        render: function(t) {
            return this.model = t, Bd.apply(this, arguments);
        },
        updateTransform: Bd,
        updateView: Bd,
        dispose: function() {
            this._brushController.dispose();
        },
        _onBrush: function(t, e) {
            var i = this.model.id;
            this.model.brushTargetManager.setOutputRanges(t, this.ecModel), (!e.isEnd || e.removeOnClick) && this.api.dispatchAction({
                type: "brush",
                brushId: i,
                areas: A(t),
                $from: i
            });
        }
    }), Fo({
        type: "brush",
        event: "brush"
    }, function(e, t) {
        t.eachComponent({
            mainType: "brush",
            query: e
        }, function(t) {
            t.setAreas(e.areas);
        });
    }), Fo({
        type: "brushSelect",
        event: "brushSelected",
        update: "none"
    }, function() {});
    var DT = {}, AT = Dx.toolbox.brush;
    Wd.defaultOption = {
        show: !0,
        type: [ "rect", "polygon", "lineX", "lineY", "keep", "clear" ],
        icon: {
            rect: "M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13",
            polygon: "M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2",
            lineX: "M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4",
            lineY: "M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4",
            keep: "M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z",
            clear: "M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2"
        },
        title: A(AT.title)
    };
    var CT = Wd.prototype;
    CT.render = CT.updateView = function(e, t, i) {
        var n, a, o;
        t.eachComponent({
            mainType: "brush"
        }, function(t) {
            n = t.brushType, a = t.brushOption.brushMode || "single", o |= t.areas.length;
        }), this._brushType = n, this._brushMode = a, R(e.get("type", !0), function(t) {
            e.setIconStatus(t, ("keep" === t ? "multiple" === a : "clear" === t ? o : t === n) ? "emphasis" : "normal");
        });
    }, CT.getIcons = function() {
        var t = this.model, e = t.get("icon", !0), i = {};
        return R(t.get("type", !0), function(t) {
            e[t] && (i[t] = e[t]);
        }), i;
    }, CT.onclick = function(t, e, i) {
        var n = this._brushType, a = this._brushMode;
        "clear" === i ? (e.dispatchAction({
            type: "axisAreaSelect",
            intervals: []
        }), e.dispatchAction({
            type: "brush",
            command: "clear",
            areas: []
        })) : e.dispatchAction({
            type: "takeGlobalCursor",
            key: "brush",
            brushOption: {
                brushType: "keep" === i ? n : n !== i && i,
                brushMode: "keep" === i ? "multiple" === a ? "single" : "multiple" : a
            }
        });
    }, Vd("brush", Wd), Go(function(t, e) {
        var i, n, a = t && t.brush;
        if (N(a) || (a = a ? [ a ] : []), a.length) {
            var o = [];
            R(a, function(t) {
                var e = t.hasOwnProperty("toolbox") ? t.toolbox : [];
                e instanceof Array && (o = o.concat(e));
            });
            var r = t && t.toolbox;
            N(r) && (r = r[0]), r || (r = {
                feature: {}
            }, t.toolbox = [ r ]);
            var s = r.feature || (r.feature = {}), l = s.brush || (s.brush = {}), h = l.type || (l.type = []);
            h.push.apply(h, o), n = {}, R(i = h, function(t) {
                n[t] = 1;
            }), i.length = 0, R(n, function(t, e) {
                i.push(e);
            }), e && !h.length && h.push.apply(h, sT);
        }
    }), Fd.prototype = {
        constructor: Fd,
        type: "calendar",
        dimensions: [ "time", "value" ],
        getDimensionsInfo: function() {
            return [ {
                name: "time",
                type: "time"
            }, "value" ];
        },
        getRangeInfo: function() {
            return this._rangeInfo;
        },
        getModel: function() {
            return this._model;
        },
        getRect: function() {
            return this._rect;
        },
        getCellWidth: function() {
            return this._sw;
        },
        getCellHeight: function() {
            return this._sh;
        },
        getOrient: function() {
            return this._orient;
        },
        getFirstDayOfWeek: function() {
            return this._firstDayOfWeek;
        },
        getDateInfo: function(t) {
            var e = (t = jn(t)).getFullYear(), i = t.getMonth() + 1;
            i = i < 10 ? "0" + i : i;
            var n = t.getDate();
            n = n < 10 ? "0" + n : n;
            var a = t.getDay();
            return {
                y: e,
                m: i,
                d: n,
                day: a = Math.abs((a + 7 - this.getFirstDayOfWeek()) % 7),
                time: t.getTime(),
                formatedDate: e + "-" + i + "-" + n,
                date: t
            };
        },
        getNextNDay: function(t, e) {
            return 0 === (e = e || 0) || (t = new Date(this.getDateInfo(t).time)).setDate(t.getDate() + e), 
            this.getDateInfo(t);
        },
        update: function(t, e) {
            function i(t, e) {
                return null != t[e] && "auto" !== t[e];
            }
            this._firstDayOfWeek = +this._model.getModel("dayLabel").get("firstDay"), this._orient = this._model.get("orient"), 
            this._lineWidth = this._model.getModel("itemStyle").getItemStyle().lineWidth || 0, 
            this._rangeInfo = this._getRangeInfo(this._initRangeOption());
            var n = this._rangeInfo.weeks || 1, a = [ "width", "height" ], o = this._model.get("cellSize").slice(), r = this._model.getBoxLayoutParams(), s = "horizontal" === this._orient ? [ n, 7 ] : [ 7, n ];
            R([ 0, 1 ], function(t) {
                i(o, t) && (r[a[t]] = o[t] * s[t]);
            });
            var l = {
                width: e.getWidth(),
                height: e.getHeight()
            }, h = this._rect = la(r, l);
            R([ 0, 1 ], function(t) {
                i(o, t) || (o[t] = h[a[t]] / s[t]);
            }), this._sw = o[0], this._sh = o[1];
        },
        dataToPoint: function(t, e) {
            N(t) && (t = t[0]), null == e && (e = !0);
            var i = this.getDateInfo(t), n = this._rangeInfo, a = i.formatedDate;
            if (e && !(i.time >= n.start.time && i.time <= n.end.time)) return [ NaN, NaN ];
            var o = i.day, r = this._getRangeInfo([ n.start.time, a ]).nthWeek;
            return "vertical" === this._orient ? [ this._rect.x + o * this._sw + this._sw / 2, this._rect.y + r * this._sh + this._sh / 2 ] : [ this._rect.x + r * this._sw + this._sw / 2, this._rect.y + o * this._sh + this._sh / 2 ];
        },
        pointToData: function(t) {
            var e = this.pointToDate(t);
            return e && e.time;
        },
        dataToRect: function(t, e) {
            var i = this.dataToPoint(t, e);
            return {
                contentShape: {
                    x: i[0] - (this._sw - this._lineWidth) / 2,
                    y: i[1] - (this._sh - this._lineWidth) / 2,
                    width: this._sw - this._lineWidth,
                    height: this._sh - this._lineWidth
                },
                center: i,
                tl: [ i[0] - this._sw / 2, i[1] - this._sh / 2 ],
                tr: [ i[0] + this._sw / 2, i[1] - this._sh / 2 ],
                br: [ i[0] + this._sw / 2, i[1] + this._sh / 2 ],
                bl: [ i[0] - this._sw / 2, i[1] + this._sh / 2 ]
            };
        },
        pointToDate: function(t) {
            var e = Math.floor((t[0] - this._rect.x) / this._sw) + 1, i = Math.floor((t[1] - this._rect.y) / this._sh) + 1, n = this._rangeInfo.range;
            return "vertical" === this._orient ? this._getDateByWeeksAndDay(i, e - 1, n) : this._getDateByWeeksAndDay(e, i - 1, n);
        },
        convertToPixel: z(Hd, "dataToPoint"),
        convertFromPixel: z(Hd, "pointToData"),
        _initRangeOption: function() {
            var t = this._model.get("range"), e = t;
            if (N(e) && 1 === e.length && (e = e[0]), /^\d{4}$/.test(e) && (t = [ e + "-01-01", e + "-12-31" ]), 
            /^\d{4}[\/|-]\d{1,2}$/.test(e)) {
                var i = this.getDateInfo(e), n = i.date;
                n.setMonth(n.getMonth() + 1);
                var a = this.getNextNDay(n, -1);
                t = [ i.formatedDate, a.formatedDate ];
            }
            /^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(e) && (t = [ e, e ]);
            var o = this._getRangeInfo(t);
            return o.start.time > o.end.time && t.reverse(), t;
        },
        _getRangeInfo: function(t) {
            var e;
            (t = [ this.getDateInfo(t[0]), this.getDateInfo(t[1]) ])[0].time > t[1].time && (e = !0, 
            t.reverse());
            var i = Math.floor(t[1].time / 864e5) - Math.floor(t[0].time / 864e5) + 1, n = new Date(t[0].time), a = n.getDate(), o = t[1].date.getDate();
            if (n.setDate(a + i - 1), n.getDate() !== o) for (var r = 0 < n.getTime() - t[1].time ? 1 : -1; n.getDate() !== o && 0 < (n.getTime() - t[1].time) * r; ) i -= r, 
            n.setDate(a + i - 1);
            var s = Math.floor((i + t[0].day + 6) / 7), l = e ? 1 - s : s - 1;
            return e && t.reverse(), {
                range: [ t[0].formatedDate, t[1].formatedDate ],
                start: t[0],
                end: t[1],
                allDay: i,
                weeks: s,
                nthWeek: l,
                fweek: t[0].day,
                lweek: t[1].day
            };
        },
        _getDateByWeeksAndDay: function(t, e, i) {
            var n = this._getRangeInfo(i);
            if (t > n.weeks || 0 === t && e < n.fweek || t === n.weeks && e > n.lweek) return !1;
            var a = 7 * (t - 1) - n.fweek + e, o = new Date(n.start.time);
            return o.setDate(n.start.d + a), this.getDateInfo(o);
        }
    }, Fd.dimensions = Fd.prototype.dimensions, Fd.getDimensionsInfo = Fd.prototype.getDimensionsInfo, 
    Fd.create = function(i, n) {
        var a = [];
        return i.eachComponent("calendar", function(t) {
            var e = new Fd(t, i, n);
            a.push(e), t.coordinateSystem = e;
        }), i.eachSeries(function(t) {
            "calendar" === t.get("coordinateSystem") && (t.coordinateSystem = a[t.get("calendarIndex") || 0]);
        }), a;
    }, Ma.register("calendar", Fd);
    var LT = Cy.extend({
        type: "calendar",
        coordinateSystem: null,
        defaultOption: {
            zlevel: 0,
            z: 2,
            left: 80,
            top: 60,
            cellSize: 20,
            orient: "horizontal",
            splitLine: {
                show: !0,
                lineStyle: {
                    color: "#000",
                    width: 1,
                    type: "solid"
                }
            },
            itemStyle: {
                color: "#fff",
                borderWidth: 1,
                borderColor: "#ccc"
            },
            dayLabel: {
                show: !0,
                firstDay: 0,
                position: "start",
                margin: "50%",
                nameMap: "en",
                color: "#000"
            },
            monthLabel: {
                show: !0,
                position: "start",
                margin: 5,
                align: "center",
                nameMap: "en",
                formatter: null,
                color: "#000"
            },
            yearLabel: {
                show: !0,
                position: null,
                margin: 30,
                formatter: null,
                color: "#ccc",
                fontFamily: "sans-serif",
                fontWeight: "bolder",
                fontSize: 20
            }
        },
        init: function(t, e, i, n) {
            var a = ca(t);
            LT.superApply(this, "init", arguments), Zd(t, a);
        },
        mergeOption: function(t, e) {
            LT.superApply(this, "mergeOption", arguments), Zd(this.option, t);
        }
    }), kT = {
        EN: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ],
        CN: [ "一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月" ]
    }, PT = {
        EN: [ "S", "M", "T", "W", "T", "F", "S" ],
        CN: [ "日", "一", "二", "三", "四", "五", "六" ]
    };
    qo({
        type: "calendar",
        _tlpoints: null,
        _blpoints: null,
        _firstDayOfMonth: null,
        _firstDayPoints: null,
        render: function(t, e, i) {
            var n = this.group;
            n.removeAll();
            var a = t.coordinateSystem, o = a.getRangeInfo(), r = a.getOrient();
            this._renderDayRect(t, o, n), this._renderLines(t, o, r, n), this._renderYearText(t, o, r, n), 
            this._renderMonthText(t, r, n), this._renderWeekText(t, o, r, n);
        },
        _renderDayRect: function(t, e, i) {
            for (var n = t.coordinateSystem, a = t.getModel("itemStyle").getItemStyle(), o = n.getCellWidth(), r = n.getCellHeight(), s = e.start.time; s <= e.end.time; s = n.getNextNDay(s, 1).time) {
                var l = n.dataToRect([ s ], !1).tl, h = new Wv({
                    shape: {
                        x: l[0],
                        y: l[1],
                        width: o,
                        height: r
                    },
                    cursor: "default",
                    style: a
                });
                i.add(h);
            }
        },
        _renderLines: function(i, t, n, a) {
            function e(t) {
                o._firstDayOfMonth.push(r.getDateInfo(t)), o._firstDayPoints.push(r.dataToRect([ t ], !1).tl);
                var e = o._getLinePointsOfOneWeek(i, t, n);
                o._tlpoints.push(e[0]), o._blpoints.push(e[e.length - 1]), l && o._drawSplitline(e, s, a);
            }
            var o = this, r = i.coordinateSystem, s = i.getModel("splitLine.lineStyle").getLineStyle(), l = i.get("splitLine.show"), h = s.lineWidth;
            this._tlpoints = [], this._blpoints = [], this._firstDayOfMonth = [], this._firstDayPoints = [];
            for (var u = t.start, c = 0; u.time <= t.end.time; c++) {
                e(u.formatedDate), 0 === c && (u = r.getDateInfo(t.start.y + "-" + t.start.m));
                var d = u.date;
                d.setMonth(d.getMonth() + 1), u = r.getDateInfo(d);
            }
            e(r.getNextNDay(t.end.time, 1).formatedDate), l && this._drawSplitline(o._getEdgesPoints(o._tlpoints, h, n), s, a), 
            l && this._drawSplitline(o._getEdgesPoints(o._blpoints, h, n), s, a);
        },
        _getEdgesPoints: function(t, e, i) {
            var n = [ t[0].slice(), t[t.length - 1].slice() ], a = "horizontal" === i ? 0 : 1;
            return n[0][a] = n[0][a] - e / 2, n[1][a] = n[1][a] + e / 2, n;
        },
        _drawSplitline: function(t, e, i) {
            var n = new Gv({
                z2: 20,
                shape: {
                    points: t
                },
                style: e
            });
            i.add(n);
        },
        _getLinePointsOfOneWeek: function(t, e, i) {
            var n = t.coordinateSystem;
            e = n.getDateInfo(e);
            for (var a = [], o = 0; o < 7; o++) {
                var r = n.getNextNDay(e.time, o), s = n.dataToRect([ r.time ], !1);
                a[2 * r.day] = s.tl, a[2 * r.day + 1] = s["horizontal" === i ? "bl" : "tr"];
            }
            return a;
        },
        _formatterLabel: function(t, e) {
            return "string" == typeof t && t ? ia(t, e) : "function" == typeof t ? t(e) : e.nameMap;
        },
        _yearTextPositionControl: function(t, e, i, n, a) {
            e = e.slice();
            var o = [ "center", "bottom" ];
            "bottom" === n ? (e[1] += a, o = [ "center", "top" ]) : "left" === n ? e[0] -= a : "right" === n ? (e[0] += a, 
            o = [ "center", "top" ]) : e[1] -= a;
            var r = 0;
            return "left" !== n && "right" !== n || (r = Math.PI / 2), {
                rotation: r,
                position: e,
                style: {
                    textAlign: o[0],
                    textVerticalAlign: o[1]
                }
            };
        },
        _renderYearText: function(t, e, i, n) {
            var a = t.getModel("yearLabel");
            if (a.get("show")) {
                var o = a.get("margin"), r = a.get("position");
                r || (r = "horizontal" !== i ? "top" : "left");
                var s = [ this._tlpoints[this._tlpoints.length - 1], this._blpoints[0] ], l = (s[0][0] + s[1][0]) / 2, h = (s[0][1] + s[1][1]) / 2, u = "horizontal" === i ? 0 : 1, c = {
                    top: [ l, s[u][1] ],
                    bottom: [ l, s[1 - u][1] ],
                    left: [ s[1 - u][0], h ],
                    right: [ s[u][0], h ]
                }, d = e.start.y;
                +e.end.y > +e.start.y && (d = d + "-" + e.end.y);
                var f = a.get("formatter"), p = {
                    start: e.start.y,
                    end: e.end.y,
                    nameMap: d
                }, g = this._formatterLabel(f, p), m = new Nv({
                    z2: 30
                });
                vn(m.style, a, {
                    text: g
                }), m.attr(this._yearTextPositionControl(m, c[r], i, r, o)), n.add(m);
            }
        },
        _monthTextPositionControl: function(t, e, i, n, a) {
            var o = "left", r = "top", s = t[0], l = t[1];
            return "horizontal" === i ? (l += a, e && (o = "center"), "start" === n && (r = "bottom")) : (s += a, 
            e && (r = "middle"), "start" === n && (o = "right")), {
                x: s,
                y: l,
                textAlign: o,
                textVerticalAlign: r
            };
        },
        _renderMonthText: function(t, e, i) {
            var n = t.getModel("monthLabel");
            if (n.get("show")) {
                var a = n.get("nameMap"), o = n.get("margin"), r = n.get("position"), s = n.get("align"), l = [ this._tlpoints, this._blpoints ];
                b(a) && (a = kT[a.toUpperCase()] || []);
                var h = "start" === r ? 0 : 1, u = "horizontal" === e ? 0 : 1;
                o = "start" === r ? -o : o;
                for (var c = "center" === s, d = 0; d < l[h].length - 1; d++) {
                    var f = l[h][d].slice(), p = this._firstDayOfMonth[d];
                    if (c) {
                        var g = this._firstDayPoints[d];
                        f[u] = (g[u] + l[0][d + 1][u]) / 2;
                    }
                    var m = n.get("formatter"), v = a[+p.m - 1], y = {
                        yyyy: p.y,
                        yy: (p.y + "").slice(2),
                        MM: p.m,
                        M: +p.m,
                        nameMap: v
                    }, x = this._formatterLabel(m, y), _ = new Nv({
                        z2: 30
                    });
                    P(vn(_.style, n, {
                        text: x
                    }), this._monthTextPositionControl(f, c, e, r, o)), i.add(_);
                }
            }
        },
        _weekTextPositionControl: function(t, e, i, n, a) {
            var o = "center", r = "middle", s = t[0], l = t[1], h = "start" === i;
            return "horizontal" === e ? (s = s + n + (h ? 1 : -1) * a[0] / 2, o = h ? "right" : "left") : (l = l + n + (h ? 1 : -1) * a[1] / 2, 
            r = h ? "bottom" : "top"), {
                x: s,
                y: l,
                textAlign: o,
                textVerticalAlign: r
            };
        },
        _renderWeekText: function(t, e, i, n) {
            var a = t.getModel("dayLabel");
            if (a.get("show")) {
                var o = t.coordinateSystem, r = a.get("position"), s = a.get("nameMap"), l = a.get("margin"), h = o.getFirstDayOfWeek();
                b(s) && (s = PT[s.toUpperCase()] || []);
                var u = o.getNextNDay(e.end.time, 7 - e.lweek).time, c = [ o.getCellWidth(), o.getCellHeight() ];
                l = zn(l, c["horizontal" === i ? 0 : 1]), "start" === r && (u = o.getNextNDay(e.start.time, -(7 + e.fweek)).time, 
                l = -l);
                for (var d = 0; d < 7; d++) {
                    var f, p = o.getNextNDay(u, d), g = o.dataToRect([ p.time ], !1).center;
                    f = Math.abs((d + h) % 7);
                    var m = new Nv({
                        z2: 30
                    });
                    P(vn(m.style, a, {
                        text: s[f]
                    }), this._weekTextPositionControl(g, i, r, l, c)), n.add(m);
                }
            }
        }
    }), Yo({
        type: "title",
        layoutMode: {
            type: "box",
            ignoreSize: !0
        },
        defaultOption: {
            zlevel: 0,
            z: 6,
            show: !0,
            text: "",
            target: "blank",
            subtext: "",
            subtarget: "blank",
            left: 0,
            top: 0,
            backgroundColor: "rgba(0,0,0,0)",
            borderColor: "#ccc",
            borderWidth: 0,
            padding: 5,
            itemGap: 10,
            textStyle: {
                fontSize: 18,
                fontWeight: "bolder",
                color: "#333"
            },
            subtextStyle: {
                color: "#aaa"
            }
        }
    }), qo({
        type: "title",
        render: function(t, e, i) {
            if (this.group.removeAll(), t.get("show")) {
                var n = this.group, a = t.getModel("textStyle"), o = t.getModel("subtextStyle"), r = t.get("textAlign"), s = t.get("textBaseline"), l = new Nv({
                    style: vn({}, a, {
                        text: t.get("text"),
                        textFill: a.getTextColor()
                    }, {
                        disableBox: !0
                    }),
                    z2: 10
                }), h = l.getBoundingRect(), u = t.get("subtext"), c = new Nv({
                    style: vn({}, o, {
                        text: u,
                        textFill: o.getTextColor(),
                        y: h.height + t.get("itemGap"),
                        textVerticalAlign: "top"
                    }, {
                        disableBox: !0
                    }),
                    z2: 10
                }), d = t.get("link"), f = t.get("sublink");
                l.silent = !d, c.silent = !f, d && l.on("click", function() {
                    window.open(d, "_" + t.get("target"));
                }), f && c.on("click", function() {
                    window.open(f, "_" + t.get("subtarget"));
                }), n.add(l), u && n.add(c);
                var p = n.getBoundingRect(), g = t.getBoxLayoutParams();
                g.width = p.width, g.height = p.height;
                var m = la(g, {
                    width: i.getWidth(),
                    height: i.getHeight()
                }, t.get("padding"));
                r || ("middle" === (r = t.get("left") || t.get("right")) && (r = "center"), "right" === r ? m.x += m.width : "center" === r && (m.x += m.width / 2)), 
                s || ("center" === (s = t.get("top") || t.get("bottom")) && (s = "middle"), "bottom" === s ? m.y += m.height : "middle" === s && (m.y += m.height / 2), 
                s = s || "top"), n.attr("position", [ m.x, m.y ]);
                var v = {
                    textAlign: r,
                    textVerticalAlign: s
                };
                l.setStyle(v), c.setStyle(v), p = n.getBoundingRect();
                var y = m.margin, x = t.getItemStyle([ "color", "opacity" ]);
                x.fill = t.get("backgroundColor");
                var _ = new Wv({
                    shape: {
                        x: p.x - y[3],
                        y: p.y - y[0],
                        width: p.width + y[1] + y[3],
                        height: p.height + y[0] + y[2],
                        r: t.get("borderRadius")
                    },
                    style: x,
                    silent: !0
                });
                tn(_), n.add(_);
            }
        }
    }), Cy.registerSubTypeDefaulter("dataZoom", function() {
        return "slider";
    });
    var NT, OT, ET, RT, zT = [ "cartesian2d", "polar", "singleAxis" ], BT = (OT = [ "axisIndex", "axis", "index", "id" ], 
    ET = L(NT = (NT = [ "x", "y", "z", "radius", "angle", "single" ]).slice(), ra), 
    RT = L(OT = (OT || []).slice(), ra), function(a, o) {
        R(NT, function(t, e) {
            for (var i = {
                name: t,
                capital: ET[e]
            }, n = 0; n < OT.length; n++) i[OT[n]] = t + RT[n];
            a.call(o, i);
        });
    }), VT = R, GT = Vn, WT = function(t, e, i, n) {
        this._dimName = t, this._axisIndex = e, this._valueWindow, this._percentWindow, 
        this._dataExtent, this._minMaxSpan, this.ecModel = n, this._dataZoomModel = i;
    };
    WT.prototype = {
        constructor: WT,
        hostedBy: function(t) {
            return this._dataZoomModel === t;
        },
        getDataValueWindow: function() {
            return this._valueWindow.slice();
        },
        getDataPercentWindow: function() {
            return this._percentWindow.slice();
        },
        getTargetSeriesModels: function() {
            var a = [], o = this.ecModel;
            return o.eachSeries(function(t) {
                if (n = t.get("coordinateSystem"), 0 <= C(zT, n)) {
                    var e = this._dimName, i = o.queryComponents({
                        mainType: e + "Axis",
                        index: t.get(e + "AxisIndex"),
                        id: t.get(e + "AxisId")
                    })[0];
                    this._axisIndex === (i && i.componentIndex) && a.push(t);
                }
                var n;
            }, this), a;
        },
        getAxisModel: function() {
            return this.ecModel.getComponent(this._dimName + "Axis", this._axisIndex);
        },
        getOtherAxisModel: function() {
            var t, e, i, n = this._dimName, a = this.ecModel, o = this.getAxisModel();
            return "x" === n || "y" === n ? (e = "gridIndex", t = "x" === n ? "y" : "x") : (e = "polarIndex", 
            t = "angle" === n ? "radius" : "angle"), a.eachComponent(t + "Axis", function(t) {
                (t.get(e) || 0) === (o.get(e) || 0) && (i = t);
            }), i;
        },
        getMinMaxSpan: function() {
            return A(this._minMaxSpan);
        },
        calculateDataWindow: function(e) {
            var n = this._dataExtent, a = this.getAxisModel().axis.scale, o = this._dataZoomModel.getRangePropMode(), r = [ 0, 100 ], s = [ e.start, e.end ], l = [];
            return VT([ "startValue", "endValue" ], function(t) {
                l.push(null != e[t] ? a.parse(e[t]) : null);
            }), VT([ 0, 1 ], function(t) {
                var e = l[t], i = s[t];
                "percent" === o[t] ? (null == i && (i = r[t]), e = a.parse(Rn(i, r, n, !0))) : i = Rn(e, n, r, !0), 
                l[t] = e, s[t] = i;
            }), {
                valueWindow: GT(l),
                percentWindow: GT(s)
            };
        },
        reset: function(t) {
            if (t === this._dataZoomModel) {
                var e = this.getTargetSeriesModels();
                this._dataExtent = Ud(this, this._dimName, e);
                var i = this.calculateDataWindow(t.option);
                this._valueWindow = i.valueWindow, this._percentWindow = i.percentWindow, a = (n = this)._minMaxSpan = {}, 
                o = n._dataZoomModel, VT([ "min", "max" ], function(t) {
                    a[t + "Span"] = o.get(t + "Span");
                    var e = o.get(t + "ValueSpan");
                    if (null != e && (a[t + "ValueSpan"] = e, null != (e = n.getAxisModel().axis.scale.parse(e)))) {
                        var i = n._dataExtent;
                        a[t + "Span"] = Rn(i[0] + e, i, [ 0, 100 ], !0);
                    }
                }), jd(this);
            }
            var n, a, o;
        },
        restore: function(t) {
            t === this._dataZoomModel && (this._valueWindow = this._percentWindow = null, jd(this, !0));
        },
        filterData: function(t, e) {
            if (t === this._dataZoomModel) {
                var n = this._dimName, i = this.getTargetSeriesModels(), a = t.get("filterMode"), c = this._valueWindow;
                "none" !== a && VT(i, function(i) {
                    var h = i.getData(), u = h.mapDimension(n, !0);
                    "weakFilter" === a ? h.filterSelf(function(t) {
                        for (var e, i, n, a = 0; a < u.length; a++) {
                            var o = h.get(u[a], t), r = !isNaN(o), s = o < c[0], l = o > c[1];
                            if (r && !s && !l) return !0;
                            r && (n = !0), s && (e = !0), l && (i = !0);
                        }
                        return n && e && i;
                    }) : VT(u, function(t) {
                        if ("empty" === a) i.setData(h.map(t, function(t) {
                            return (e = t) >= c[0] && e <= c[1] ? t : NaN;
                            var e;
                        })); else {
                            var e = {};
                            e[t] = c, h.selectRange(e);
                        }
                    }), VT(u, function(t) {
                        h.setApproximateExtent(c, t);
                    });
                });
            }
        }
    };
    var FT = R, HT = BT, ZT = Yo({
        type: "dataZoom",
        dependencies: [ "xAxis", "yAxis", "zAxis", "radiusAxis", "angleAxis", "singleAxis", "series" ],
        defaultOption: {
            zlevel: 0,
            z: 4,
            orient: null,
            xAxisIndex: null,
            yAxisIndex: null,
            filterMode: "filter",
            throttle: null,
            start: 0,
            end: 100,
            startValue: null,
            endValue: null,
            minSpan: null,
            maxSpan: null,
            minValueSpan: null,
            maxValueSpan: null,
            rangeMode: null
        },
        init: function(t, e, i) {
            this._dataIntervalByAxis = {}, this._dataInfo = {}, this._axisProxies = {}, this.textStyleModel, 
            this._autoThrottle = !0, this._rangePropMode = [ "percent", "percent" ];
            var n = Xd(t);
            this.mergeDefaultAndTheme(t, i), this.doInit(n);
        },
        mergeOption: function(t) {
            var e = Xd(t);
            g(this.option, t, !0), this.doInit(e);
        },
        doInit: function(t) {
            var i = this.option;
            Sp.canvasSupported || (i.realtime = !1), this._setDefaultThrottle(t), Yd(this, t), 
            FT([ [ "start", "startValue" ], [ "end", "endValue" ] ], function(t, e) {
                "value" === this._rangePropMode[e] && (i[t[0]] = null);
            }, this), this.textStyleModel = this.getModel("textStyle"), this._resetTarget(), 
            this._giveAxisProxies();
        },
        _giveAxisProxies: function() {
            var r = this._axisProxies;
            this.eachTargetAxis(function(t, e, i, n) {
                var a = this.dependentModels[t.axis][e], o = a.__dzAxisProxy || (a.__dzAxisProxy = new WT(t.name, e, this, n));
                r[t.name + "_" + e] = o;
            }, this);
        },
        _resetTarget: function() {
            var i = this.option, t = this._judgeAutoMode();
            HT(function(t) {
                var e = t.axisIndex;
                i[e] = Qe(i[e]);
            }, this), "axisIndex" === t ? this._autoSetAxisIndex() : "orient" === t && this._autoSetOrient();
        },
        _judgeAutoMode: function() {
            var e = this.option, i = !1;
            HT(function(t) {
                null != e[t.axisIndex] && (i = !0);
            }, this);
            var t = e.orient;
            return null == t && i ? "orient" : i ? void 0 : (null == t && (e.orient = "horizontal"), 
            "axisIndex");
        },
        _autoSetAxisIndex: function() {
            var o = !0, e = this.get("orient", !0), r = this.option, t = this.dependentModels;
            if (o) {
                var i = "vertical" === e ? "y" : "x";
                t[i + "Axis"].length ? (r[i + "AxisIndex"] = [ 0 ], o = !1) : FT(t.singleAxis, function(t) {
                    o && t.get("orient", !0) === e && (r.singleAxisIndex = [ t.componentIndex ], o = !1);
                });
            }
            o && HT(function(t) {
                if (o) {
                    var e = [], i = this.dependentModels[t.axis];
                    if (i.length && !e.length) for (var n = 0, a = i.length; n < a; n++) "category" === i[n].get("type") && e.push(n);
                    (r[t.axisIndex] = e).length && (o = !1);
                }
            }, this), o && this.ecModel.eachSeries(function(a) {
                this._isSeriesHasAllAxesTypeOf(a, "value") && HT(function(t) {
                    var e = r[t.axisIndex], i = a.get(t.axisIndex), n = a.get(t.axisId);
                    C(e, i = a.ecModel.queryComponents({
                        mainType: t.axis,
                        index: i,
                        id: n
                    })[0].componentIndex) < 0 && e.push(i);
                });
            }, this);
        },
        _autoSetOrient: function() {
            var e;
            this.eachTargetAxis(function(t) {
                !e && (e = t.name);
            }, this), this.option.orient = "y" === e ? "vertical" : "horizontal";
        },
        _isSeriesHasAllAxesTypeOf: function(n, a) {
            var o = !0;
            return HT(function(t) {
                var e = n.get(t.axisIndex), i = this.dependentModels[t.axis][e];
                i && i.get("type") === a || (o = !1);
            }, this), o;
        },
        _setDefaultThrottle: function(t) {
            if (t.hasOwnProperty("throttle") && (this._autoThrottle = !1), this._autoThrottle) {
                var e = this.ecModel.option;
                this.option.throttle = e.animation && 0 < e.animationDurationUpdate ? 100 : 20;
            }
        },
        getFirstTargetAxisModel: function() {
            var i;
            return HT(function(t) {
                if (null == i) {
                    var e = this.get(t.axisIndex);
                    e.length && (i = this.dependentModels[t.axis][e[0]]);
                }
            }, this), i;
        },
        eachTargetAxis: function(i, n) {
            var a = this.ecModel;
            HT(function(e) {
                FT(this.get(e.axisIndex), function(t) {
                    i.call(n, e, t, this, a);
                }, this);
            }, this);
        },
        getAxisProxy: function(t, e) {
            return this._axisProxies[t + "_" + e];
        },
        getAxisModel: function(t, e) {
            var i = this.getAxisProxy(t, e);
            return i && i.getAxisModel();
        },
        setRawRange: function(e, t) {
            var i = this.option;
            FT([ [ "start", "startValue" ], [ "end", "endValue" ] ], function(t) {
                null == e[t[0]] && null == e[t[1]] || (i[t[0]] = e[t[0]], i[t[1]] = e[t[1]]);
            }, this), !t && Yd(this, e);
        },
        getPercentRange: function() {
            var t = this.findRepresentativeAxisProxy();
            if (t) return t.getDataPercentWindow();
        },
        getValueRange: function(t, e) {
            if (null != t || null != e) return this.getAxisProxy(t, e).getDataValueWindow();
            var i = this.findRepresentativeAxisProxy();
            return i ? i.getDataValueWindow() : void 0;
        },
        findRepresentativeAxisProxy: function(t) {
            if (t) return t.__dzAxisProxy;
            var e = this._axisProxies;
            for (var i in e) if (e.hasOwnProperty(i) && e[i].hostedBy(this)) return e[i];
            for (var i in e) if (e.hasOwnProperty(i) && !e[i].hostedBy(this)) return e[i];
        },
        getRangePropMode: function() {
            return this._rangePropMode.slice();
        }
    }), UT = gx.extend({
        type: "dataZoom",
        render: function(t, e, i, n) {
            this.dataZoomModel = t, this.ecModel = e, this.api = i;
        },
        getTargetCoordInfo: function() {
            var t = this.dataZoomModel, a = this.ecModel, o = {};
            return t.eachTargetAxis(function(t, e) {
                var i = a.getComponent(t.axis, e);
                if (i) {
                    var n = i.getCoordSysModel();
                    n && function(t, e, i, n) {
                        for (var a, o = 0; o < i.length; o++) if (i[o].model === t) {
                            a = i[o];
                            break;
                        }
                        a || i.push(a = {
                            model: t,
                            axisModels: [],
                            coordIndex: n
                        }), a.axisModels.push(e);
                    }(n, i, o[n.mainType] || (o[n.mainType] = []), n.componentIndex);
                }
            }, this), o;
        }
    }), jT = (ZT.extend({
        type: "dataZoom.slider",
        layoutMode: "box",
        defaultOption: {
            show: !0,
            right: "ph",
            top: "ph",
            width: "ph",
            height: "ph",
            left: null,
            bottom: null,
            backgroundColor: "rgba(47,69,84,0)",
            dataBackground: {
                lineStyle: {
                    color: "#2f4554",
                    width: .5,
                    opacity: .3
                },
                areaStyle: {
                    color: "rgba(47,69,84,0.3)",
                    opacity: .3
                }
            },
            borderColor: "#ddd",
            fillerColor: "rgba(167,183,204,0.4)",
            handleIcon: "M8.2,13.6V3.9H6.3v9.7H3.1v14.9h3.3v9.7h1.8v-9.7h3.3V13.6H8.2z M9.7,24.4H4.8v-1.4h4.9V24.4z M9.7,19.1H4.8v-1.4h4.9V19.1z",
            handleSize: "100%",
            handleStyle: {
                color: "#a7b7cc"
            },
            labelPrecision: null,
            labelFormatter: null,
            showDetail: !0,
            showDataShadow: "auto",
            realtime: !0,
            zoomLock: !1,
            textStyle: {
                color: "#333"
            }
        }
    }), Wv), XT = Rn, YT = Vn, qT = _, KT = R, $T = "horizontal", JT = [ "line", "bar", "candlestick", "scatter" ], QT = UT.extend({
        type: "dataZoom.slider",
        init: function(t, e) {
            this._displayables = {}, this._orient, this._range, this._handleEnds, this._size, 
            this._handleWidth, this._handleHeight, this._location, this._dragging, this._dataShadowInfo, 
            this.api = e;
        },
        render: function(t, e, i, n) {
            QT.superApply(this, "render", arguments), ro(this, "_dispatchZoomAction", this.dataZoomModel.get("throttle"), "fixRate"), 
            this._orient = t.get("orient"), !1 !== this.dataZoomModel.get("show") ? (n && "dataZoom" === n.type && n.from === this.uid || this._buildView(), 
            this._updateView()) : this.group.removeAll();
        },
        remove: function() {
            QT.superApply(this, "remove", arguments), so(this, "_dispatchZoomAction");
        },
        dispose: function() {
            QT.superApply(this, "dispose", arguments), so(this, "_dispatchZoomAction");
        },
        _buildView: function() {
            var t = this.group;
            t.removeAll(), this._resetLocation(), this._resetInterval();
            var e = this._displayables.barGroup = new Dg();
            this._renderBackground(), this._renderHandle(), this._renderDataShadow(), t.add(e), 
            this._positionGroup();
        },
        _resetLocation: function() {
            var t = this.dataZoomModel, e = this.api, i = this._findCoordRect(), n = {
                width: e.getWidth(),
                height: e.getHeight()
            }, a = this._orient === $T ? {
                right: n.width - i.x - i.width,
                top: n.height - 30 - 7,
                width: i.width,
                height: 30
            } : {
                right: 7,
                top: i.y,
                width: 30,
                height: i.height
            }, o = ca(t.option);
            R([ "right", "top", "width", "height" ], function(t) {
                "ph" === o[t] && (o[t] = a[t]);
            });
            var r = la(o, n, t.padding);
            this._location = {
                x: r.x,
                y: r.y
            }, this._size = [ r.width, r.height ], "vertical" === this._orient && this._size.reverse();
        },
        _positionGroup: function() {
            var t = this.group, e = this._location, i = this._orient, n = this.dataZoomModel.getFirstTargetAxisModel(), a = n && n.get("inverse"), o = this._displayables.barGroup, r = (this._dataShadowInfo || {}).otherAxisInverse;
            o.attr(i !== $T || a ? i === $T && a ? {
                scale: r ? [ -1, 1 ] : [ -1, -1 ]
            } : "vertical" !== i || a ? {
                scale: r ? [ -1, -1 ] : [ -1, 1 ],
                rotation: Math.PI / 2
            } : {
                scale: r ? [ 1, -1 ] : [ 1, 1 ],
                rotation: Math.PI / 2
            } : {
                scale: r ? [ 1, 1 ] : [ 1, -1 ]
            });
            var s = t.getBoundingRect([ o ]);
            t.attr("position", [ e.x - s.x, e.y - s.y ]);
        },
        _getViewExtent: function() {
            return [ 0, this._size[0] ];
        },
        _renderBackground: function() {
            var t = this.dataZoomModel, e = this._size, i = this._displayables.barGroup;
            i.add(new jT({
                silent: !0,
                shape: {
                    x: 0,
                    y: 0,
                    width: e[0],
                    height: e[1]
                },
                style: {
                    fill: t.get("backgroundColor")
                },
                z2: -40
            })), i.add(new jT({
                shape: {
                    x: 0,
                    y: 0,
                    width: e[0],
                    height: e[1]
                },
                style: {
                    fill: "transparent"
                },
                z2: 0,
                onclick: _(this._onClickPanelClick, this)
            }));
        },
        _renderDataShadow: function() {
            var t = this._dataShadowInfo = this._prepareDataShadowInfo();
            if (t) {
                var e = this._size, i = t.series, n = i.getRawData(), a = i.getShadowDim ? i.getShadowDim() : t.otherDim;
                if (null != a) {
                    var o = n.getDataExtent(a), r = .3 * (o[1] - o[0]);
                    o = [ o[0] - r, o[1] + r ];
                    var s, l = [ 0, e[1] ], h = [ 0, e[0] ], u = [ [ e[0], 0 ], [ 0, 0 ] ], c = [], d = h[1] / (n.count() - 1), f = 0, p = Math.round(n.count() / e[0]);
                    n.each([ a ], function(t, e) {
                        if (0 < p && e % p) f += d; else {
                            var i = null == t || isNaN(t) || "" === t, n = i ? 0 : XT(t, o, l, !0);
                            i && !s && e ? (u.push([ u[u.length - 1][0], 0 ]), c.push([ c[c.length - 1][0], 0 ])) : !i && s && (u.push([ f, 0 ]), 
                            c.push([ f, 0 ])), u.push([ f, n ]), c.push([ f, n ]), f += d, s = i;
                        }
                    });
                    var g = this.dataZoomModel;
                    this._displayables.barGroup.add(new Vv({
                        shape: {
                            points: u
                        },
                        style: E({
                            fill: g.get("dataBackgroundColor")
                        }, g.getModel("dataBackground.areaStyle").getAreaStyle()),
                        silent: !0,
                        z2: -20
                    })), this._displayables.barGroup.add(new Gv({
                        shape: {
                            points: c
                        },
                        style: g.getModel("dataBackground.lineStyle").getLineStyle(),
                        silent: !0,
                        z2: -19
                    }));
                }
            }
        },
        _prepareDataShadowInfo: function() {
            var t = this.dataZoomModel, s = t.get("showDataShadow");
            if (!1 !== s) {
                var l, h = this.ecModel;
                return t.eachTargetAxis(function(o, r) {
                    R(t.getAxisProxy(o.name, r).getTargetSeriesModels(), function(t) {
                        if (!(l || !0 !== s && C(JT, t.get("type")) < 0)) {
                            var e, i = h.getComponent(o.axis, r).axis, n = {
                                x: "y",
                                y: "x",
                                radius: "angle",
                                angle: "radius"
                            }[o.name], a = t.coordinateSystem;
                            null != n && a.getOtherAxis && (e = a.getOtherAxis(i).inverse), n = t.getData().mapDimension(n), 
                            l = {
                                thisAxis: i,
                                series: t,
                                thisDim: o.name,
                                otherDim: n,
                                otherAxisInverse: e
                            };
                        }
                    }, this);
                }, this), l;
            }
        },
        _renderHandle: function() {
            var t = this._displayables, o = t.handles = [], r = t.handleLabels = [], s = this._displayables.barGroup, e = this._size, l = this.dataZoomModel;
            s.add(t.filler = new jT({
                draggable: !0,
                cursor: qd(this._orient),
                drift: qT(this._onDragMove, this, "all"),
                onmousemove: function(t) {
                    nm(t.event);
                },
                ondragstart: qT(this._showDataInfo, this, !0),
                ondragend: qT(this._onDragEnd, this),
                onmouseover: qT(this._showDataInfo, this, !0),
                onmouseout: qT(this._showDataInfo, this, !1),
                style: {
                    fill: l.get("fillerColor"),
                    textPosition: "inside"
                }
            })), s.add(new jT(tn({
                silent: !0,
                shape: {
                    x: 0,
                    y: 0,
                    width: e[0],
                    height: e[1]
                },
                style: {
                    stroke: l.get("dataBackgroundColor") || l.get("borderColor"),
                    lineWidth: 1,
                    fill: "rgba(0,0,0,0)"
                }
            }))), KT([ 0, 1 ], function(t) {
                var e = kn(l.get("handleIcon"), {
                    cursor: qd(this._orient),
                    draggable: !0,
                    drift: qT(this._onDragMove, this, t),
                    onmousemove: function(t) {
                        nm(t.event);
                    },
                    ondragend: qT(this._onDragEnd, this),
                    onmouseover: qT(this._showDataInfo, this, !0),
                    onmouseout: qT(this._showDataInfo, this, !1)
                }, {
                    x: -1,
                    y: 0,
                    width: 2,
                    height: 2
                }), i = e.getBoundingRect();
                this._handleHeight = zn(l.get("handleSize"), this._size[1]), this._handleWidth = i.width / i.height * this._handleHeight, 
                e.setStyle(l.getModel("handleStyle").getItemStyle());
                var n = l.get("handleColor");
                null != n && (e.style.fill = n), s.add(o[t] = e);
                var a = l.textStyleModel;
                this.group.add(r[t] = new Nv({
                    silent: !0,
                    invisible: !0,
                    style: {
                        x: 0,
                        y: 0,
                        text: "",
                        textVerticalAlign: "middle",
                        textAlign: "center",
                        textFill: a.getTextColor(),
                        textFont: a.getFont()
                    },
                    z2: 10
                }));
            }, this);
        },
        _resetInterval: function() {
            var t = this._range = this.dataZoomModel.getPercentRange(), e = this._getViewExtent();
            this._handleEnds = [ XT(t[0], [ 0, 100 ], e, !0), XT(t[1], [ 0, 100 ], e, !0) ];
        },
        _updateInterval: function(t, e) {
            var i = this.dataZoomModel, n = this._handleEnds, a = this._getViewExtent(), o = i.findRepresentativeAxisProxy().getMinMaxSpan(), r = [ 0, 100 ];
            HS(e, n, a, i.get("zoomLock") ? "all" : t, null != o.minSpan ? XT(o.minSpan, r, a, !0) : null, null != o.maxSpan ? XT(o.maxSpan, r, a, !0) : null), 
            this._range = YT([ XT(n[0], a, r, !0), XT(n[1], a, r, !0) ]);
        },
        _updateView: function(t) {
            var n = this._displayables, a = this._handleEnds, e = YT(a.slice()), o = this._size;
            KT([ 0, 1 ], function(t) {
                var e = n.handles[t], i = this._handleHeight;
                e.attr({
                    scale: [ i / 2, i / 2 ],
                    position: [ a[t], o[1] / 2 - i / 2 ]
                });
            }, this), n.filler.setShape({
                x: e[0],
                y: 0,
                width: e[1] - e[0],
                height: o[1]
            }), this._updateDataInfo(t);
        },
        _updateDataInfo: function(t) {
            function e(t) {
                var e = Tn(o.handles[t].parent, this.group), i = An(0 === t ? "right" : "left", e), n = this._handleWidth / 2 + 5, a = Dn([ c[t] + (0 === t ? -n : n), this._size[1] / 2 ], e);
                r[t].setStyle({
                    x: a[0],
                    y: a[1],
                    textVerticalAlign: s === $T ? "middle" : i,
                    textAlign: s === $T ? i : "center",
                    text: l[t]
                });
            }
            var i = this.dataZoomModel, o = this._displayables, r = o.handleLabels, s = this._orient, l = [ "", "" ];
            if (i.get("showDetail")) {
                var n = i.findRepresentativeAxisProxy();
                if (n) {
                    var a = n.getAxisModel().axis, h = this._range, u = t ? n.calculateDataWindow({
                        start: h[0],
                        end: h[1]
                    }).valueWindow : n.getDataValueWindow();
                    l = [ this._formatLabel(u[0], a), this._formatLabel(u[1], a) ];
                }
            }
            var c = YT(this._handleEnds.slice());
            e.call(this, 0), e.call(this, 1);
        },
        _formatLabel: function(t, e) {
            var i = this.dataZoomModel, n = i.get("labelFormatter"), a = i.get("labelPrecision");
            null != a && "auto" !== a || (a = e.getPixelPrecision());
            var o = null == t || isNaN(t) ? "" : "category" === e.type || "time" === e.type ? e.scale.getLabel(Math.round(t)) : t.toFixed(Math.min(a, 20));
            return m(n) ? n(t, o) : b(n) ? n.replace("{value}", o) : o;
        },
        _showDataInfo: function(t) {
            t = this._dragging || t;
            var e = this._displayables.handleLabels;
            e[0].attr("invisible", !t), e[1].attr("invisible", !t);
        },
        _onDragMove: function(t, e, i) {
            this._dragging = !0;
            var n = Dn([ e, i ], this._displayables.barGroup.getLocalTransform(), !0);
            this._updateInterval(t, n[0]);
            var a = this.dataZoomModel.get("realtime");
            this._updateView(!a), a && this._dispatchZoomAction();
        },
        _onDragEnd: function() {
            this._dragging = !1, this._showDataInfo(!1), !this.dataZoomModel.get("realtime") && this._dispatchZoomAction();
        },
        _onClickPanelClick: function(t) {
            var e = this._size, i = this._displayables.barGroup.transformCoordToLocal(t.offsetX, t.offsetY);
            if (!(i[0] < 0 || i[0] > e[0] || i[1] < 0 || i[1] > e[1])) {
                var n = this._handleEnds, a = (n[0] + n[1]) / 2;
                this._updateInterval("all", i[0] - a), this._updateView(), this._dispatchZoomAction();
            }
        },
        _dispatchZoomAction: function() {
            var t = this._range;
            this.api.dispatchAction({
                type: "dataZoom",
                from: this.uid,
                dataZoomId: this.dataZoomModel.id,
                start: t[0],
                end: t[1]
            });
        },
        _findCoordRect: function() {
            var i;
            if (KT(this.getTargetCoordInfo(), function(t) {
                if (!i && t.length) {
                    var e = t[0].model.coordinateSystem;
                    i = e.getRect && e.getRect();
                }
            }), !i) {
                var t = this.api.getWidth(), e = this.api.getHeight();
                i = {
                    x: .2 * t,
                    y: .2 * e,
                    width: .6 * t,
                    height: .6 * e
                };
            }
            return i;
        }
    });
    ZT.extend({
        type: "dataZoom.inside",
        defaultOption: {
            disabled: !1,
            zoomLock: !1,
            zoomOnMouseWheel: !0,
            moveOnMouseMove: !0,
            preventDefaultMouseMove: !0
        }
    });
    var tD = z, eD = "\0_ec_dataZoom_roams", iD = _, nD = UT.extend({
        type: "dataZoom.inside",
        init: function(t, e) {
            this._range;
        },
        render: function(o, t, r, e) {
            nD.superApply(this, "render", arguments), function(t, e) {
                if (t && "dataZoom" === t.type && t.batch) for (var i = 0, n = t.batch.length; i < n; i++) if (t.batch[i].dataZoomId === e) return !1;
                return !0;
            }(e, o.id) && (this._range = o.getPercentRange()), R(this.getTargetCoordInfo(), function(t, i) {
                var a = L(t, function(t) {
                    return $d(t.model);
                });
                R(t, function(t) {
                    var n = t.model, e = o.option;
                    Kd(r, {
                        coordId: $d(n),
                        allCoordIds: a,
                        containsPoint: function(t, e, i) {
                            return n.coordinateSystem.containPoint([ e, i ]);
                        },
                        dataZoomId: o.id,
                        throttleRate: o.get("throttle", !0),
                        panGetRange: iD(this._onPan, this, t, i),
                        zoomGetRange: iD(this._onZoom, this, t, i),
                        zoomLock: e.zoomLock,
                        disabled: e.disabled,
                        roamControllerOpt: {
                            zoomOnMouseWheel: e.zoomOnMouseWheel,
                            moveOnMouseMove: e.moveOnMouseMove,
                            preventDefaultMouseMove: e.preventDefaultMouseMove
                        }
                    });
                }, this);
            }, this);
        },
        dispose: function() {
            var t, i, e;
            t = this.api, i = this.dataZoomModel.id, R(e = Jd(t), function(t) {
                t.controller.dispose();
                var e = t.dataZoomInfos;
                e[i] && (delete e[i], t.count--);
            }), Qd(e), nD.superApply(this, "dispose", arguments), this._range = null;
        },
        _onPan: function(t, e, i, n, a, o, r, s, l) {
            var h = this._range.slice(), u = t.axisModels[0];
            if (u) {
                var c = aD[e]([ o, r ], [ s, l ], u, i, t), d = c.signal * (h[1] - h[0]) * c.pixel / c.pixelLength;
                return HS(d, h, [ 0, 100 ], "all"), this._range = h;
            }
        },
        _onZoom: function(t, e, i, n, a, o) {
            var r = this._range.slice(), s = t.axisModels[0];
            if (s) {
                var l = aD[e](null, [ a, o ], s, i, t), h = (0 < l.signal ? l.pixelStart + l.pixelLength - l.pixel : l.pixel - l.pixelStart) / l.pixelLength * (r[1] - r[0]) + r[0];
                n = Math.max(1 / n, 0), r[0] = (r[0] - h) * n + h, r[1] = (r[1] - h) * n + h;
                var u = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
                return HS(0, r, [ 0, 100 ], 0, u.minSpan, u.maxSpan), this._range = r;
            }
        }
    }), aD = {
        grid: function(t, e, i, n, a) {
            var o = i.axis, r = {}, s = a.model.coordinateSystem.getRect();
            return t = t || [ 0, 0 ], "x" === o.dim ? (r.pixel = e[0] - t[0], r.pixelLength = s.width, 
            r.pixelStart = s.x, r.signal = o.inverse ? 1 : -1) : (r.pixel = e[1] - t[1], r.pixelLength = s.height, 
            r.pixelStart = s.y, r.signal = o.inverse ? -1 : 1), r;
        },
        polar: function(t, e, i, n, a) {
            var o = i.axis, r = {}, s = a.model.coordinateSystem, l = s.getRadiusAxis().getExtent(), h = s.getAngleAxis().getExtent();
            return t = t ? s.pointToCoord(t) : [ 0, 0 ], e = s.pointToCoord(e), "radiusAxis" === i.mainType ? (r.pixel = e[0] - t[0], 
            r.pixelLength = l[1] - l[0], r.pixelStart = l[0], r.signal = o.inverse ? 1 : -1) : (r.pixel = e[1] - t[1], 
            r.pixelLength = h[1] - h[0], r.pixelStart = h[0], r.signal = o.inverse ? -1 : 1), 
            r;
        },
        singleAxis: function(t, e, i, n, a) {
            var o = i.axis, r = a.model.coordinateSystem.getRect(), s = {};
            return t = t || [ 0, 0 ], "horizontal" === o.orient ? (s.pixel = e[0] - t[0], s.pixelLength = r.width, 
            s.pixelStart = r.x, s.signal = o.inverse ? 1 : -1) : (s.pixel = e[1] - t[1], s.pixelLength = r.height, 
            s.pixelStart = r.y, s.signal = o.inverse ? -1 : 1), s;
        }
    };
    Wo({
        getTargetSeries: function(t) {
            var n = W();
            return t.eachComponent("dataZoom", function(t) {
                t.eachTargetAxis(function(t, e, i) {
                    R(i.getAxisProxy(t.name, e).getTargetSeriesModels(), function(t) {
                        n.set(t.uid, t);
                    });
                });
            }), n;
        },
        isOverallFilter: !0,
        overallReset: function(t, n) {
            t.eachComponent("dataZoom", function(t) {
                t.eachTargetAxis(function(t, e, i) {
                    i.getAxisProxy(t.name, e).reset(i, n);
                }), t.eachTargetAxis(function(t, e, i) {
                    i.getAxisProxy(t.name, e).filterData(i, n);
                });
            }), t.eachComponent("dataZoom", function(t) {
                var e = t.findRepresentativeAxisProxy(), i = e.getDataPercentWindow(), n = e.getDataValueWindow();
                t.setRawRange({
                    start: i[0],
                    end: i[1],
                    startValue: n[0],
                    endValue: n[1]
                }, !0);
            });
        }
    }), Fo("dataZoom", function(i, t) {
        var n = function(e, s, l) {
            function h(t, i) {
                i.nodes.push(t), s(function(e) {
                    R(l(t, e) || [], function(t) {
                        i.records[e.name][t] = !0;
                    });
                });
            }
            return function(t) {
                var o, r = {
                    nodes: [],
                    records: {}
                };
                if (s(function(t) {
                    r.records[t.name] = {};
                }), !t) return r;
                for (h(t, r); o = !1, e(function(t) {
                    var i, n, a, e;
                    e = t, !(0 <= C(r.nodes, e)) && (i = t, n = r, a = !1, s(function(e) {
                        R(l(i, e) || [], function(t) {
                            n.records[e.name][t] && (a = !0);
                        });
                    }), a) && (h(t, r), o = !0);
                }), o; ) ;
                return r;
            };
        }(_(t.eachComponent, t, "dataZoom"), BT, function(t, e) {
            return t.get(e.axisIndex);
        }), a = [];
        t.eachComponent({
            mainType: "dataZoom",
            query: i
        }, function(t, e) {
            a.push.apply(a, n(t).nodes);
        }), R(a, function(t, e) {
            t.setRawRange({
                start: i.start,
                end: i.end,
                startValue: i.startValue,
                endValue: i.endValue
            });
        });
    });
    var oD = R, rD = function(t) {
        var e = t && t.visualMap;
        N(e) || (e = e ? [ e ] : []), oD(e, function(t) {
            if (t) {
                of(t, "splitList") && !of(t, "pieces") && (t.pieces = t.splitList, delete t.splitList);
                var e = t.pieces;
                e && N(e) && oD(e, function(t) {
                    B(t) && (of(t, "start") && !of(t, "min") && (t.min = t.start), of(t, "end") && !of(t, "max") && (t.max = t.end));
                });
            }
        });
    };
    Cy.registerSubTypeDefaulter("visualMap", function(t) {
        return t.categories || (t.pieces ? 0 < t.pieces.length : 0 < t.splitNumber) && !t.calculable ? "piecewise" : "continuous";
    });
    var sD = Zx.VISUAL.COMPONENT;
    Uo(sD, {
        createOnAllSeries: !0,
        reset: function(i, t) {
            var n = [];
            return t.eachComponent("visualMap", function(t) {
                var e, c, d, f, p;
                t.isTargetSeries(i) && n.push((e = t.stateList, c = t.targetVisuals, d = _(t.getValueState, t), 
                f = t.getDataDimension(i.getData()), p = {}, R(e, function(t) {
                    var e = eS.prepareVisualTypes(c[t]);
                    p[t] = e;
                }), {
                    progress: function(t, i) {
                        null != f && (f = i.getDimension(f));
                        for (var n = t.start; n < t.end; n++) {
                            var e = i.getRawDataItem(n);
                            if (e && !1 === e.visualMap) return;
                            for (var a = null != f ? i.get(f, n, !0) : n, o = d(a), r = c[o], s = p[o], l = 0, h = s.length; l < h; l++) {
                                var u = s[l];
                                r[u] && r[u].applyVisual(a, function(t) {
                                    return i.getItemVisual(n, t);
                                }, function(t, e) {
                                    i.setItemVisual(n, t, e);
                                });
                            }
                        }
                    }
                }));
            }), n;
        }
    }), Uo(sD, {
        createOnAllSeries: !0,
        reset: function(a, t) {
            var o = a.getData(), r = [];
            t.eachComponent("visualMap", function(t) {
                if (t.isTargetSeries(a)) {
                    var e = t.getVisualMeta(_(rf, null, a, t)) || {
                        stops: [],
                        outerColors: []
                    }, i = t.getDataDimension(o), n = o.getDimensionInfo(i);
                    null != n && (e.dimension = n.index, r.push(e));
                }
            }), a.getData().setVisual("visualMeta", r);
        }
    });
    var lD = function(t, e, i) {
        var n = A((hD[t] || {})[e]);
        return i && N(n) ? n[n.length - 1] : n;
    }, hD = {
        color: {
            active: [ "#006edd", "#e0ffff" ],
            inactive: [ "rgba(0,0,0,0)" ]
        },
        colorHue: {
            active: [ 0, 360 ],
            inactive: [ 0, 0 ]
        },
        colorSaturation: {
            active: [ .3, 1 ],
            inactive: [ 0, 0 ]
        },
        colorLightness: {
            active: [ .9, .5 ],
            inactive: [ 0, 0 ]
        },
        colorAlpha: {
            active: [ .3, 1 ],
            inactive: [ 0, 0 ]
        },
        opacity: {
            active: [ .3, 1 ],
            inactive: [ 0, 0 ]
        },
        symbol: {
            active: [ "circle", "roundRect", "diamond" ],
            inactive: [ "none" ]
        },
        symbolSize: {
            active: [ 10, 50 ],
            inactive: [ 0, 0 ]
        }
    }, uD = eS.mapVisual, cD = eS.eachVisual, dD = N, fD = R, pD = Vn, gD = Rn, mD = Yo({
        type: "visualMap",
        dependencies: [ "series" ],
        stateList: [ "inRange", "outOfRange" ],
        replacableOptionKeys: [ "inRange", "outOfRange", "target", "controller", "color" ],
        dataBound: [ -1 / 0, 1 / 0 ],
        layoutMode: {
            type: "box",
            ignoreSize: !0
        },
        defaultOption: {
            show: !0,
            zlevel: 0,
            z: 4,
            seriesIndex: "all",
            min: 0,
            max: 200,
            dimension: null,
            inRange: null,
            outOfRange: null,
            left: 0,
            right: null,
            top: null,
            bottom: 0,
            itemWidth: null,
            itemHeight: null,
            inverse: !1,
            orient: "vertical",
            backgroundColor: "rgba(0,0,0,0)",
            borderColor: "#ccc",
            contentColor: "#5793f3",
            inactiveColor: "#aaa",
            borderWidth: 0,
            padding: 5,
            textGap: 10,
            precision: 0,
            color: null,
            formatter: null,
            text: null,
            textStyle: {
                color: "#333"
            }
        },
        init: function(t, e, i) {
            this._dataExtent, this.targetVisuals = {}, this.controllerVisuals = {}, this.textStyleModel, 
            this.itemSize, this.mergeDefaultAndTheme(t, i);
        },
        optionUpdated: function(t, e) {
            var i = this.option;
            Sp.canvasSupported || (i.realtime = !1), !e && wd(i, t, this.replacableOptionKeys), 
            this.textStyleModel = this.getModel("textStyle"), this.resetItemSize(), this.completeVisualOption();
        },
        resetVisual: function(t) {
            var e = this.stateList;
            t = _(t, this), this.controllerVisuals = _d(this.option.controller, e, t), this.targetVisuals = _d(this.option.target, e, t);
        },
        getTargetSeriesIndices: function() {
            var t = this.option.seriesIndex, i = [];
            return null == t || "all" === t ? this.ecModel.eachSeries(function(t, e) {
                i.push(e);
            }) : i = Qe(t), i;
        },
        eachTargetSeries: function(e, i) {
            R(this.getTargetSeriesIndices(), function(t) {
                e.call(i, this.ecModel.getSeriesByIndex(t));
            }, this);
        },
        isTargetSeries: function(e) {
            var i = !1;
            return this.eachTargetSeries(function(t) {
                t === e && (i = !0);
            }), i;
        },
        formatValueText: function(t, e, i) {
            function n(t) {
                return t === l[0] ? "min" : t === l[1] ? "max" : (+t).toFixed(Math.min(s, 20));
            }
            var a, o, r = this.option, s = r.precision, l = this.dataBound, h = r.formatter;
            return i = i || [ "<", ">" ], N(t) && (t = t.slice(), a = !0), o = e ? t : a ? [ n(t[0]), n(t[1]) ] : n(t), 
            b(h) ? h.replace("{value}", a ? o[0] : o).replace("{value2}", a ? o[1] : o) : m(h) ? a ? h(t[0], t[1]) : h(t) : a ? t[0] === l[0] ? i[0] + " " + o[1] : t[1] === l[1] ? i[1] + " " + o[0] : o[0] + " - " + o[1] : o;
        },
        resetExtent: function() {
            var t = this.option, e = pD([ t.min, t.max ]);
            this._dataExtent = e;
        },
        getDataDimension: function(t) {
            var e = this.option.dimension, i = t.dimensions;
            if (null != e || i.length) {
                if (null != e) return t.getDimension(e);
                for (var n = t.dimensions, a = n.length - 1; 0 <= a; a--) {
                    var o = n[a];
                    if (!t.getDimensionInfo(o).isCalculationCoord) return o;
                }
            }
        },
        getExtent: function() {
            return this._dataExtent.slice();
        },
        completeVisualOption: function() {
            function t(n) {
                dD(i.color) && !n.inRange && (n.inRange = {
                    color: i.color.slice().reverse()
                }), n.inRange = n.inRange || {
                    color: e.get("gradientColor")
                }, fD(this.stateList, function(t) {
                    var e = n[t];
                    if (b(e)) {
                        var i = lD(e, "active", h);
                        i ? (n[t] = {}, n[t][e] = i) : delete n[t];
                    }
                }, this);
            }
            var e = this.ecModel, i = this.option, n = {
                inRange: i.inRange,
                outOfRange: i.outOfRange
            }, a = i.target || (i.target = {}), o = i.controller || (i.controller = {});
            g(a, n), g(o, n);
            var h = this.isCategory();
            t.call(this, a), t.call(this, o), function(t, e, i) {
                var n = t[e], a = t[i];
                n && !a && (a = t[i] = {}, fD(n, function(t, e) {
                    if (eS.isValidType(e)) {
                        var i = lD(e, "inactive", h);
                        null != i && (a[e] = i, "color" !== e || a.hasOwnProperty("opacity") || a.hasOwnProperty("colorAlpha") || (a.opacity = [ 0, 0 ]));
                    }
                }));
            }.call(this, a, "inRange", "outOfRange"), function(o) {
                var r = (o.inRange || {}).symbol || (o.outOfRange || {}).symbol, s = (o.inRange || {}).symbolSize || (o.outOfRange || {}).symbolSize, l = this.get("inactiveColor");
                fD(this.stateList, function(t) {
                    var e = this.itemSize, i = o[t];
                    i || (i = o[t] = {
                        color: h ? l : [ l ]
                    }), null == i.symbol && (i.symbol = r && A(r) || (h ? "roundRect" : [ "roundRect" ])), 
                    null == i.symbolSize && (i.symbolSize = s && A(s) || (h ? e[0] : [ e[0], e[0] ])), 
                    i.symbol = uD(i.symbol, function(t) {
                        return "none" === t || "square" === t ? "roundRect" : t;
                    });
                    var n = i.symbolSize;
                    if (null != n) {
                        var a = -1 / 0;
                        cD(n, function(t) {
                            a < t && (a = t);
                        }), i.symbolSize = uD(n, function(t) {
                            return gD(t, [ 0, a ], [ 0, e[0] ], !0);
                        });
                    }
                }, this);
            }.call(this, o);
        },
        resetItemSize: function() {
            this.itemSize = [ parseFloat(this.get("itemWidth")), parseFloat(this.get("itemHeight")) ];
        },
        isCategory: function() {
            return !!this.option.categories;
        },
        setSelected: S,
        getValueState: S,
        getVisualMeta: S
    }), vD = [ 20, 140 ], yD = mD.extend({
        type: "visualMap.continuous",
        defaultOption: {
            align: "auto",
            calculable: !1,
            range: null,
            realtime: !0,
            itemHeight: null,
            itemWidth: null,
            hoverLink: !0,
            hoverLinkDataSize: null,
            hoverLinkOnHandle: null
        },
        optionUpdated: function(t, e) {
            yD.superApply(this, "optionUpdated", arguments), this.resetExtent(), this.resetVisual(function(t) {
                t.mappingMethod = "linear", t.dataExtent = this.getExtent();
            }), this._resetRange();
        },
        resetItemSize: function() {
            yD.superApply(this, "resetItemSize", arguments);
            var t = this.itemSize;
            "horizontal" === this._orient && t.reverse(), (null == t[0] || isNaN(t[0])) && (t[0] = vD[0]), 
            (null == t[1] || isNaN(t[1])) && (t[1] = vD[1]);
        },
        _resetRange: function() {
            var t = this.getExtent(), e = this.option.range;
            !e || e.auto ? (t.auto = 1, this.option.range = t) : N(e) && (e[0] > e[1] && e.reverse(), 
            e[0] = Math.max(e[0], t[0]), e[1] = Math.min(e[1], t[1]));
        },
        completeVisualOption: function() {
            mD.prototype.completeVisualOption.apply(this, arguments), R(this.stateList, function(t) {
                var e = this.option.controller[t].symbolSize;
                e && e[0] !== e[1] && (e[0] = 0);
            }, this);
        },
        setSelected: function(t) {
            this.option.range = t.slice(), this._resetRange();
        },
        getSelected: function() {
            var t = this.getExtent(), e = Vn((this.get("range") || []).slice());
            return e[0] > t[1] && (e[0] = t[1]), e[1] > t[1] && (e[1] = t[1]), e[0] < t[0] && (e[0] = t[0]), 
            e[1] < t[0] && (e[1] = t[0]), e;
        },
        getValueState: function(t) {
            var e = this.option.range, i = this.getExtent();
            return (e[0] <= i[0] || e[0] <= t) && (e[1] >= i[1] || t <= e[1]) ? "inRange" : "outOfRange";
        },
        findTargetDataIndices: function(n) {
            var a = [];
            return this.eachTargetSeries(function(t) {
                var i = [], e = t.getData();
                e.each(this.getDataDimension(e), function(t, e) {
                    n[0] <= t && t <= n[1] && i.push(e);
                }, this), a.push({
                    seriesId: t.id,
                    dataIndex: i
                });
            }, this), a;
        },
        getVisualMeta: function(i) {
            function t(t, e) {
                a.push({
                    value: t,
                    color: i(t, e)
                });
            }
            for (var e = sf(0, 0, this.getExtent()), n = sf(0, 0, this.option.range.slice()), a = [], o = 0, r = 0, s = n.length, l = e.length; r < l && (!n.length || e[r] <= n[0]); r++) e[r] < n[o] && t(e[r], "outOfRange");
            for (h = 1; o < s; o++, h = 0) h && a.length && t(n[o], "outOfRange"), t(n[o], "inRange");
            for (var h = 1; r < l; r++) (!n.length || n[n.length - 1] < e[r]) && (h && (a.length && t(a[a.length - 1].value, "outOfRange"), 
            h = 0), t(e[r], "outOfRange"));
            var u = a.length;
            return {
                stops: a,
                outerColors: [ u ? a[0].color : "transparent", u ? a[u - 1].color : "transparent" ]
            };
        }
    }), xD = qo({
        type: "visualMap",
        autoPositionValues: {
            left: 1,
            right: 1,
            top: 1,
            bottom: 1
        },
        init: function(t, e) {
            this.ecModel = t, this.api = e, this.visualMapModel;
        },
        render: function(t, e, i, n) {
            !1 !== (this.visualMapModel = t).get("show") ? this.doRender.apply(this, arguments) : this.group.removeAll();
        },
        renderBackground: function(t) {
            var e = this.visualMapModel, i = my(e.get("padding") || 0), n = t.getBoundingRect();
            t.add(new Wv({
                z2: -1,
                silent: !0,
                shape: {
                    x: n.x - i[3],
                    y: n.y - i[0],
                    width: n.width + i[3] + i[1],
                    height: n.height + i[0] + i[2]
                },
                style: {
                    fill: e.get("backgroundColor"),
                    stroke: e.get("borderColor"),
                    lineWidth: e.get("borderWidth")
                }
            }));
        },
        getControllerVisual: function(i, n, a) {
            function o(t) {
                return s[t];
            }
            function r(t, e) {
                s[t] = e;
            }
            var t = (a = a || {}).forceState, e = this.visualMapModel, s = {};
            if ("symbol" === n && (s.symbol = e.get("itemSymbol")), "color" === n) {
                var l = e.get("contentColor");
                s.color = l;
            }
            var h = e.controllerVisuals[t || e.getValueState(i)];
            return R(eS.prepareVisualTypes(h), function(t) {
                var e = h[t];
                a.convertOpacityToAlpha && "opacity" === t && (t = "colorAlpha", e = h.__alphaForOpacity), 
                eS.dependsOn(t, n) && e && e.applyVisual(i, o, r);
            }), s[n];
        },
        positionGroup: function(t) {
            var e = this.visualMapModel, i = this.api;
            ha(t, e.getBoxLayoutParams(), {
                width: i.getWidth(),
                height: i.getHeight()
            });
        },
        doRender: S
    }), _D = Rn, wD = R, bD = Math.min, SD = Math.max, MD = xD.extend({
        type: "visualMap.continuous",
        init: function() {
            MD.superApply(this, "init", arguments), this._shapes = {}, this._dataInterval = [], 
            this._handleEnds = [], this._orient, this._useHandle, this._hoverLinkDataIndices = [], 
            this._dragging, this._hovering;
        },
        doRender: function(t, e, i, n) {
            n && "selectDataRange" === n.type && n.from === this.uid || this._buildView();
        },
        _buildView: function() {
            this.group.removeAll();
            var t = this.visualMapModel, e = this.group;
            this._orient = t.get("orient"), this._useHandle = t.get("calculable"), this._resetInterval(), 
            this._renderBar(e);
            var i = t.get("text");
            this._renderEndsText(e, i, 0), this._renderEndsText(e, i, 1), this._updateView(!0), 
            this.renderBackground(e), this._updateView(), this._enableHoverLinkToSeries(), this._enableHoverLinkFromSeries(), 
            this.positionGroup(e);
        },
        _renderEndsText: function(t, e, i) {
            if (e) {
                var n = e[1 - i];
                n = null != n ? n + "" : "";
                var a = this.visualMapModel, o = a.get("textGap"), r = a.itemSize, s = this._shapes.barGroup, l = this._applyTransform([ r[0] / 2, 0 === i ? -o : r[1] + o ], s), h = this._applyTransform(0 === i ? "bottom" : "top", s), u = this._orient, c = this.visualMapModel.textStyleModel;
                this.group.add(new Nv({
                    style: {
                        x: l[0],
                        y: l[1],
                        textVerticalAlign: "horizontal" === u ? "middle" : h,
                        textAlign: "horizontal" === u ? h : "center",
                        text: n,
                        textFont: c.getFont(),
                        textFill: c.getTextColor()
                    }
                }));
            }
        },
        _renderBar: function(t) {
            var e = this.visualMapModel, i = this._shapes, n = e.itemSize, a = this._orient, o = this._useHandle, r = lf(e, this.api, n), s = i.barGroup = this._createBarGroup(r);
            s.add(i.outOfRange = uf()), s.add(i.inRange = uf(null, o ? df(this._orient) : null, _(this._dragHandle, this, "all", !1), _(this._dragHandle, this, "all", !0)));
            var l = e.textStyleModel.getTextRect("国"), h = SD(l.width, l.height);
            o && (i.handleThumbs = [], i.handleLabels = [], i.handleLabelPoints = [], this._createHandle(s, 0, n, h, a, r), 
            this._createHandle(s, 1, n, h, a, r)), this._createIndicator(s, n, h, a), t.add(s);
        },
        _createHandle: function(t, e, i, n, a) {
            var o, r = _(this._dragHandle, this, e, !1), s = _(this._dragHandle, this, e, !0), l = uf((o = n, 
            0 === e ? [ [ 0, 0 ], [ o, 0 ], [ o, -o ] ] : [ [ 0, 0 ], [ o, 0 ], [ o, o ] ]), df(this._orient), r, s);
            l.position[0] = i[0], t.add(l);
            var h = this.visualMapModel.textStyleModel, u = new Nv({
                draggable: !0,
                drift: r,
                onmousemove: function(t) {
                    nm(t.event);
                },
                ondragend: s,
                style: {
                    x: 0,
                    y: 0,
                    text: "",
                    textFont: h.getFont(),
                    textFill: h.getTextColor()
                }
            });
            this.group.add(u);
            var c = [ "horizontal" === a ? n / 2 : 1.5 * n, "horizontal" === a ? 0 === e ? -1.5 * n : 1.5 * n : 0 === e ? -n / 2 : n / 2 ], d = this._shapes;
            d.handleThumbs[e] = l, d.handleLabelPoints[e] = c, d.handleLabels[e] = u;
        },
        _createIndicator: function(t, e, i, n) {
            var a = uf([ [ 0, 0 ] ], "move");
            a.position[0] = e[0], a.attr({
                invisible: !0,
                silent: !0
            }), t.add(a);
            var o = this.visualMapModel.textStyleModel, r = new Nv({
                silent: !0,
                invisible: !0,
                style: {
                    x: 0,
                    y: 0,
                    text: "",
                    textFont: o.getFont(),
                    textFill: o.getTextColor()
                }
            });
            this.group.add(r);
            var s = [ "horizontal" === n ? i / 2 : 9, 0 ], l = this._shapes;
            l.indicator = a, l.indicatorLabel = r, l.indicatorLabelPoint = s;
        },
        _dragHandle: function(t, e, i, n) {
            if (this._useHandle) {
                if (this._dragging = !e, !e) {
                    var a = this._applyTransform([ i, n ], this._shapes.barGroup, !0);
                    this._updateInterval(t, a[1]), this._updateView();
                }
                e === !this.visualMapModel.get("realtime") && this.api.dispatchAction({
                    type: "selectDataRange",
                    from: this.uid,
                    visualMapId: this.visualMapModel.id,
                    selected: this._dataInterval.slice()
                }), e ? !this._hovering && this._clearHoverLinkToSeries() : cf(this.visualMapModel) && this._doHoverLinkToSeries(this._handleEnds[t], !1);
            }
        },
        _resetInterval: function() {
            var t = this.visualMapModel, e = this._dataInterval = t.getSelected(), i = t.getExtent(), n = [ 0, t.itemSize[1] ];
            this._handleEnds = [ _D(e[0], i, n, !0), _D(e[1], i, n, !0) ];
        },
        _updateInterval: function(t, e) {
            e = e || 0;
            var i = this.visualMapModel, n = this._handleEnds, a = [ 0, i.itemSize[1] ];
            HS(e, n, a, t, 0);
            var o = i.getExtent();
            this._dataInterval = [ _D(n[0], a, o, !0), _D(n[1], a, o, !0) ];
        },
        _updateView: function(t) {
            var e = this.visualMapModel, i = e.getExtent(), n = this._shapes, a = [ 0, e.itemSize[1] ], o = t ? a : this._handleEnds, r = this._createBarVisual(this._dataInterval, i, o, "inRange"), s = this._createBarVisual(i, i, a, "outOfRange");
            n.inRange.setStyle({
                fill: r.barColor,
                opacity: r.opacity
            }).setShape("points", r.barPoints), n.outOfRange.setStyle({
                fill: s.barColor,
                opacity: s.opacity
            }).setShape("points", s.barPoints), this._updateHandle(o, r);
        },
        _createBarVisual: function(t, e, i, n) {
            var a = {
                forceState: n,
                convertOpacityToAlpha: !0
            }, o = this._makeColorGradient(t, a), r = [ this.getControllerVisual(t[0], "symbolSize", a), this.getControllerVisual(t[1], "symbolSize", a) ], s = this._createBarPoints(i, r);
            return {
                barColor: new Yv(0, 0, 0, 1, o),
                barPoints: s,
                handlesColor: [ o[0].color, o[o.length - 1].color ]
            };
        },
        _makeColorGradient: function(t, e) {
            var i = [], n = (t[1] - t[0]) / 100;
            i.push({
                color: this.getControllerVisual(t[0], "color", e),
                offset: 0
            });
            for (var a = 1; a < 100; a++) {
                var o = t[0] + n * a;
                if (o > t[1]) break;
                i.push({
                    color: this.getControllerVisual(o, "color", e),
                    offset: a / 100
                });
            }
            return i.push({
                color: this.getControllerVisual(t[1], "color", e),
                offset: 1
            }), i;
        },
        _createBarPoints: function(t, e) {
            var i = this.visualMapModel.itemSize;
            return [ [ i[0] - e[0], t[0] ], [ i[0], t[0] ], [ i[0], t[1] ], [ i[0] - e[1], t[1] ] ];
        },
        _createBarGroup: function(t) {
            var e = this._orient, i = this.visualMapModel.get("inverse");
            return new Dg("horizontal" !== e || i ? "horizontal" === e && i ? {
                scale: "bottom" === t ? [ -1, 1 ] : [ 1, 1 ],
                rotation: -Math.PI / 2
            } : "vertical" !== e || i ? {
                scale: "left" === t ? [ 1, 1 ] : [ -1, 1 ]
            } : {
                scale: "left" === t ? [ 1, -1 ] : [ -1, -1 ]
            } : {
                scale: "bottom" === t ? [ 1, 1 ] : [ -1, 1 ],
                rotation: Math.PI / 2
            });
        },
        _updateHandle: function(n, a) {
            if (this._useHandle) {
                var o = this._shapes, r = this.visualMapModel, s = o.handleThumbs, l = o.handleLabels;
                wD([ 0, 1 ], function(t) {
                    var e = s[t];
                    e.setStyle("fill", a.handlesColor[t]), e.position[1] = n[t];
                    var i = Dn(o.handleLabelPoints[t], Tn(e, this.group));
                    l[t].setStyle({
                        x: i[0],
                        y: i[1],
                        text: r.formatValueText(this._dataInterval[t]),
                        textVerticalAlign: "middle",
                        textAlign: this._applyTransform("horizontal" === this._orient ? 0 === t ? "bottom" : "top" : "left", o.barGroup)
                    });
                }, this);
            }
        },
        _showIndicator: function(t, e, i, n) {
            var a, o, r, s, l = this.visualMapModel, h = l.getExtent(), u = l.itemSize, c = [ 0, u[1] ], d = _D(t, h, c, !0), f = this._shapes, p = f.indicator;
            if (p) {
                p.position[1] = d, p.attr("invisible", !1), p.setShape("points", (a = !!i, o = n, 
                r = d, s = u[1], a ? [ [ 0, -bD(o, SD(r, 0)) ], [ 6, 0 ], [ 0, bD(o, SD(s - r, 0)) ] ] : [ [ 0, 0 ], [ 5, -5 ], [ 5, 5 ] ]));
                var g = this.getControllerVisual(t, "color", {
                    convertOpacityToAlpha: !0
                });
                p.setStyle("fill", g);
                var m = Dn(f.indicatorLabelPoint, Tn(p, this.group)), v = f.indicatorLabel;
                v.attr("invisible", !1);
                var y = this._applyTransform("left", f.barGroup), x = this._orient;
                v.setStyle({
                    text: (i || "") + l.formatValueText(e),
                    textVerticalAlign: "horizontal" === x ? y : "middle",
                    textAlign: "horizontal" === x ? "center" : y,
                    x: m[0],
                    y: m[1]
                });
            }
        },
        _enableHoverLinkToSeries: function() {
            var n = this;
            this._shapes.barGroup.on("mousemove", function(t) {
                if (n._hovering = !0, !n._dragging) {
                    var e = n.visualMapModel.itemSize, i = n._applyTransform([ t.offsetX, t.offsetY ], n._shapes.barGroup, !0, !0);
                    i[1] = bD(SD(0, i[1]), e[1]), n._doHoverLinkToSeries(i[1], 0 <= i[0] && i[0] <= e[0]);
                }
            }).on("mouseout", function() {
                n._hovering = !1, !n._dragging && n._clearHoverLinkToSeries();
            });
        },
        _enableHoverLinkFromSeries: function() {
            var t = this.api.getZr();
            this.visualMapModel.option.hoverLink ? (t.on("mouseover", this._hoverLinkFromSeriesMouseOver, this), 
            t.on("mouseout", this._hideIndicator, this)) : this._clearHoverLinkFromSeries();
        },
        _doHoverLinkToSeries: function(t, e) {
            var i, n, a, o, r = this.visualMapModel, s = r.itemSize;
            if (r.option.hoverLink) {
                var l = [ 0, s[1] ], h = r.getExtent();
                t = bD(SD(l[0], t), l[1]);
                var u = (i = h, n = l, a = 6, (o = r.get("hoverLinkDataSize")) && (a = _D(o, i, n, !0) / 2), 
                a), c = [ t - u, t + u ], d = _D(t, l, h, !0), f = [ _D(c[0], l, h, !0), _D(c[1], l, h, !0) ];
                c[0] < l[0] && (f[0] = -1 / 0), l[1] < c[1] && (f[1] = 1 / 0), e && (f[0] === -1 / 0 ? this._showIndicator(d, f[1], "< ", u) : f[1] === 1 / 0 ? this._showIndicator(d, f[0], "> ", u) : this._showIndicator(d, d, "≈ ", u));
                var p = this._hoverLinkDataIndices, g = [];
                (e || cf(r)) && (g = this._hoverLinkDataIndices = r.findTargetDataIndices(f));
                var m = function(t, e) {
                    function i(t, e, i) {
                        for (var n = 0, a = t.length; n < a; n++) for (var o = t[n].seriesId, r = Qe(t[n].dataIndex), s = i && i[o], l = 0, h = r.length; l < h; l++) {
                            var u = r[l];
                            s && s[u] ? s[u] = null : (e[o] || (e[o] = {}))[u] = 1;
                        }
                    }
                    function o(t, e) {
                        var i = [];
                        for (var n in t) if (t.hasOwnProperty(n) && null != t[n]) if (e) i.push(+n); else {
                            var a = o(t[n], !0);
                            a.length && i.push({
                                seriesId: n,
                                dataIndex: a
                            });
                        }
                        return i;
                    }
                    var n = {}, a = {};
                    return i(t || [], n), i(e || [], a, n), [ o(n), o(a) ];
                }(p, g);
                this._dispatchHighDown("downplay", hf(m[0])), this._dispatchHighDown("highlight", hf(m[1]));
            }
        },
        _hoverLinkFromSeriesMouseOver: function(t) {
            var e = t.target, i = this.visualMapModel;
            if (e && null != e.dataIndex) {
                var n = this.ecModel.getSeriesByIndex(e.seriesIndex);
                if (i.isTargetSeries(n)) {
                    var a = n.getData(e.dataType), o = a.get(i.getDataDimension(a), e.dataIndex, !0);
                    isNaN(o) || this._showIndicator(o, o);
                }
            }
        },
        _hideIndicator: function() {
            var t = this._shapes;
            t.indicator && t.indicator.attr("invisible", !0), t.indicatorLabel && t.indicatorLabel.attr("invisible", !0);
        },
        _clearHoverLinkToSeries: function() {
            this._hideIndicator();
            var t = this._hoverLinkDataIndices;
            this._dispatchHighDown("downplay", hf(t)), t.length = 0;
        },
        _clearHoverLinkFromSeries: function() {
            this._hideIndicator();
            var t = this.api.getZr();
            t.off("mouseover", this._hoverLinkFromSeriesMouseOver), t.off("mouseout", this._hideIndicator);
        },
        _applyTransform: function(t, e, i, n) {
            var a = Tn(e, n ? null : this.group);
            return iy[N(t) ? "applyTransform" : "transformDirection"](t, a, i);
        },
        _dispatchHighDown: function(t, e) {
            e && e.length && this.api.dispatchAction({
                type: t,
                batch: e
            });
        },
        dispose: function() {
            this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries();
        },
        remove: function() {
            this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries();
        }
    });
    Fo({
        type: "selectDataRange",
        event: "dataRangeSelected",
        update: "update"
    }, function(e, t) {
        t.eachComponent({
            mainType: "visualMap",
            query: e
        }, function(t) {
            t.setSelected(e.selected);
        });
    }), Go(rD);
    var ID = mD.extend({
        type: "visualMap.piecewise",
        defaultOption: {
            selected: null,
            minOpen: !1,
            maxOpen: !1,
            align: "auto",
            itemWidth: 20,
            itemHeight: 14,
            itemSymbol: "roundRect",
            pieceList: null,
            categories: null,
            splitNumber: 5,
            selectedMode: "multiple",
            itemGap: 10,
            hoverLink: !0,
            showLabel: null
        },
        optionUpdated: function(t, e) {
            ID.superApply(this, "optionUpdated", arguments), this._pieceList = [], this.resetExtent();
            var i = this._mode = this._determineMode();
            TD[this._mode].call(this), this._resetSelected(t, e);
            var n = this.option.categories;
            this.resetVisual(function(t, e) {
                "categories" === i ? (t.mappingMethod = "category", t.categories = A(n)) : (t.dataExtent = this.getExtent(), 
                t.mappingMethod = "piecewise", t.pieceList = L(this._pieceList, function(t) {
                    t = A(t);
                    return "inRange" !== e && (t.visual = null), t;
                }));
            });
        },
        completeVisualOption: function() {
            function n(t, e, i) {
                return t && t[e] && (B(t[e]) ? t[e].hasOwnProperty(i) : t[e] === i);
            }
            var a = this.option, i = {}, t = eS.listVisualTypes(), o = this.isCategory();
            R(a.pieces, function(e) {
                R(t, function(t) {
                    e.hasOwnProperty(t) && (i[t] = 1);
                });
            }), R(i, function(t, e) {
                var i = 0;
                R(this.stateList, function(t) {
                    i |= n(a, t, e) || n(a.target, t, e);
                }, this), !i && R(this.stateList, function(t) {
                    (a[t] || (a[t] = {}))[e] = lD(e, "inRange" === t ? "active" : "inactive", o);
                });
            }, this), mD.prototype.completeVisualOption.apply(this, arguments);
        },
        _resetSelected: function(t, e) {
            var i = this.option, n = this._pieceList, a = (e ? i : t).selected || {};
            if (i.selected = a, R(n, function(t, e) {
                var i = this.getSelectedMapKey(t);
                a.hasOwnProperty(i) || (a[i] = !0);
            }, this), "single" === i.selectedMode) {
                var o = !1;
                R(n, function(t, e) {
                    var i = this.getSelectedMapKey(t);
                    a[i] && (o ? a[i] = !1 : o = !0);
                }, this);
            }
        },
        getSelectedMapKey: function(t) {
            return "categories" === this._mode ? t.value + "" : t.index + "";
        },
        getPieceList: function() {
            return this._pieceList;
        },
        _determineMode: function() {
            var t = this.option;
            return t.pieces && 0 < t.pieces.length ? "pieces" : this.option.categories ? "categories" : "splitNumber";
        },
        setSelected: function(t) {
            this.option.selected = A(t);
        },
        getValueState: function(t) {
            var e = eS.findPieceIndex(t, this._pieceList);
            return null != e && this.option.selected[this.getSelectedMapKey(this._pieceList[e])] ? "inRange" : "outOfRange";
        },
        findTargetDataIndices: function(n) {
            var a = [];
            return this.eachTargetSeries(function(t) {
                var i = [], e = t.getData();
                e.each(this.getDataDimension(e), function(t, e) {
                    eS.findPieceIndex(t, this._pieceList) === n && i.push(e);
                }, this), a.push({
                    seriesId: t.id,
                    dataIndex: i
                });
            }, this), a;
        },
        getRepresentValue: function(t) {
            var e;
            if (this.isCategory()) e = t.value; else if (null != t.value) e = t.value; else {
                var i = t.interval || [];
                e = i[0] === -1 / 0 && i[1] === 1 / 0 ? 0 : (i[0] + i[1]) / 2;
            }
            return e;
        },
        getVisualMeta: function(a) {
            function i(t, e) {
                var i = s.getRepresentValue({
                    interval: t
                });
                e || (e = s.getValueState(i));
                var n = a(i, e);
                t[0] === -1 / 0 ? r[0] = n : t[1] === 1 / 0 ? r[1] = n : o.push({
                    value: t[0],
                    color: n
                }, {
                    value: t[1],
                    color: n
                });
            }
            if (!this.isCategory()) {
                var o = [], r = [], s = this, t = this._pieceList.slice();
                if (t.length) {
                    var e = t[0].interval[0];
                    e !== -1 / 0 && t.unshift({
                        interval: [ -1 / 0, e ]
                    }), (e = t[t.length - 1].interval[1]) !== 1 / 0 && t.push({
                        interval: [ e, 1 / 0 ]
                    });
                } else t.push({
                    interval: [ -1 / 0, 1 / 0 ]
                });
                var n = -1 / 0;
                return R(t, function(t) {
                    var e = t.interval;
                    e && (e[0] > n && i([ n, e[0] ], "outOfRange"), i(e.slice()), n = e[1]);
                }, this), {
                    stops: o,
                    outerColors: r
                };
            }
        }
    }), TD = {
        splitNumber: function() {
            var t = this.option, e = this._pieceList, i = Math.min(t.precision, 20), n = this.getExtent(), a = t.splitNumber;
            a = Math.max(parseInt(a, 10), 1), t.splitNumber = a;
            for (var o = (n[1] - n[0]) / a; +o.toFixed(i) !== o && i < 5; ) i++;
            t.precision = i, o = +o.toFixed(i);
            var r = 0;
            t.minOpen && e.push({
                index: r++,
                interval: [ -1 / 0, n[0] ],
                close: [ 0, 0 ]
            });
            for (var s = n[0], l = r + a; r < l; s += o) {
                var h = r === a - 1 ? n[1] : s + o;
                e.push({
                    index: r++,
                    interval: [ s, h ],
                    close: [ 1, 1 ]
                });
            }
            t.maxOpen && e.push({
                index: r++,
                interval: [ n[1], 1 / 0 ],
                close: [ 0, 0 ]
            }), Kn(e), R(e, function(t) {
                t.text = this.formatValueText(t.interval);
            }, this);
        },
        categories: function() {
            var t = this.option;
            R(t.categories, function(t) {
                this._pieceList.push({
                    text: this.formatValueText(t, !0),
                    value: t
                });
            }, this), ff(t, this._pieceList);
        },
        pieces: function() {
            var t = this.option, d = this._pieceList;
            R(t.pieces, function(t, e) {
                B(t) || (t = {
                    value: t
                });
                var i = {
                    text: "",
                    index: e
                };
                if (null != t.label && (i.text = t.label), t.hasOwnProperty("value")) {
                    var n = i.value = t.value;
                    i.interval = [ n, n ], i.close = [ 1, 1 ];
                } else {
                    for (var a = i.interval = [], o = i.close = [ 0, 0 ], r = [ 1, 0, 1 ], s = [ -1 / 0, 1 / 0 ], l = [], h = 0; h < 2; h++) {
                        for (var u = [ [ "gte", "gt", "min" ], [ "lte", "lt", "max" ] ][h], c = 0; c < 3 && null == a[h]; c++) a[h] = t[u[c]], 
                        o[h] = r[c], l[h] = 2 === c;
                        null == a[h] && (a[h] = s[h]);
                    }
                    l[0] && a[1] === 1 / 0 && (o[0] = 0), l[1] && a[0] === -1 / 0 && (o[1] = 0), a[0] === a[1] && o[0] && o[1] && (i.value = a[0]);
                }
                i.visual = eS.retrieveVisuals(t), d.push(i);
            }, this), ff(t, d), Kn(d), R(d, function(t) {
                var e = t.close, i = [ [ "<", "≤" ][e[1]], [ ">", "≥" ][e[0]] ];
                t.text = t.text || this.formatValueText(null != t.value ? t.value : t.interval, !1, i);
            }, this);
        }
    };
    xD.extend({
        type: "visualMap.piecewise",
        doRender: function() {
            var o = this.group;
            o.removeAll();
            var r = this.visualMapModel, s = r.get("textGap"), t = r.textStyleModel, l = t.getFont(), h = t.getTextColor(), u = this._getItemAlign(), c = r.itemSize, e = this._getViewData(), i = e.endsText, d = V(r.get("showLabel", !0), !i);
            i && this._renderEndsText(o, i[0], c, d, u), R(e.viewPieceList, function(t) {
                var e = t.piece, i = new Dg();
                i.onclick = _(this._onItemClick, this, e), this._enableHoverLink(i, t.indexInModelPieceList);
                var n = r.getRepresentValue(e);
                if (this._createItemSymbol(i, n, [ 0, 0, c[0], c[1] ]), d) {
                    var a = this.visualMapModel.getValueState(n);
                    i.add(new Nv({
                        style: {
                            x: "right" === u ? -s : c[0] + s,
                            y: c[1] / 2,
                            text: e.text,
                            textVerticalAlign: "middle",
                            textAlign: u,
                            textFont: l,
                            textFill: h,
                            opacity: "outOfRange" === a ? .5 : 1
                        }
                    }));
                }
                o.add(i);
            }, this), i && this._renderEndsText(o, i[1], c, d, u), Dy(r.get("orient"), o, r.get("itemGap")), 
            this.renderBackground(o), this.positionGroup(o);
        },
        _enableHoverLink: function(t, i) {
            function e(t) {
                var e = this.visualMapModel;
                e.option.hoverLink && this.api.dispatchAction({
                    type: t,
                    batch: hf(e.findTargetDataIndices(i))
                });
            }
            t.on("mouseover", _(e, this, "highlight")).on("mouseout", _(e, this, "downplay"));
        },
        _getItemAlign: function() {
            var t = this.visualMapModel, e = t.option;
            if ("vertical" === e.orient) return lf(t, this.api, t.itemSize);
            var i = e.align;
            return i && "auto" !== i || (i = "left"), i;
        },
        _renderEndsText: function(t, e, i, n, a) {
            if (e) {
                var o = new Dg(), r = this.visualMapModel.textStyleModel;
                o.add(new Nv({
                    style: {
                        x: n ? "right" === a ? i[0] : 0 : i[0] / 2,
                        y: i[1] / 2,
                        textVerticalAlign: "middle",
                        textAlign: n ? a : "center",
                        text: e,
                        textFont: r.getFont(),
                        textFill: r.getTextColor()
                    }
                })), t.add(o);
            }
        },
        _getViewData: function() {
            var t = this.visualMapModel, e = L(t.getPieceList(), function(t, e) {
                return {
                    piece: t,
                    indexInModelPieceList: e
                };
            }), i = t.get("text"), n = t.get("orient"), a = t.get("inverse");
            return ("horizontal" === n ? a : !a) ? e.reverse() : i && (i = i.slice().reverse()), 
            {
                viewPieceList: e,
                endsText: i
            };
        },
        _createItemSymbol: function(t, e, i) {
            t.add(Rr(this.getControllerVisual(e, "symbol"), i[0], i[1], i[2], i[3], this.getControllerVisual(e, "color")));
        },
        _onItemClick: function(t) {
            var e = this.visualMapModel, i = e.option, n = A(i.selected), a = e.getSelectedMapKey(t);
            "single" === i.selectedMode ? (n[a] = !0, R(n, function(t, e) {
                n[e] = e === a;
            })) : n[a] = !n[a], this.api.dispatchAction({
                type: "selectDataRange",
                from: this.uid,
                visualMapId: this.visualMapModel.id,
                selected: n
            });
        }
    }), Go(rD);
    var DD = Jn, AD = ta, CD = Yo({
        type: "marker",
        dependencies: [ "series", "grid", "polar", "geo" ],
        init: function(t, e, i, n) {
            this.mergeDefaultAndTheme(t, i), this.mergeOption(t, i, n.createdBySelf, !0);
        },
        isAnimationEnabled: function() {
            if (Sp.node) return !1;
            var t = this.__hostSeries;
            return this.getShallow("animation") && t && t.isAnimationEnabled();
        },
        mergeOption: function(t, n, e, a) {
            var o = this.constructor, r = this.mainType + "Model";
            e || n.eachSeries(function(t) {
                var e = t.get(this.mainType, !0), i = t[r];
                e && e.data ? (i ? i.mergeOption(e, n, !0) : (a && pf(e), R(e.data, function(t) {
                    t instanceof Array ? (pf(t[0]), pf(t[1])) : pf(t);
                }), P(i = new o(e, this, n), {
                    mainType: this.mainType,
                    seriesIndex: t.seriesIndex,
                    name: t.name,
                    createdBySelf: !0
                }), i.__hostSeries = t), t[r] = i) : t[r] = null;
            }, this);
        },
        formatTooltip: function(t) {
            var e = this.getData(), i = this.getRawValue(t), n = N(i) ? L(i, DD).join(", ") : DD(i), a = e.getName(t), o = AD(this.name);
            return (null != i || a) && (o += "<br />"), a && (o += AD(a), null != i && (o += " : ")), 
            null != i && (o += AD(n)), o;
        },
        getData: function() {
            return this._data;
        },
        setData: function(t) {
            this._data = t;
        }
    });
    a(CD, cx), CD.extend({
        type: "markPoint",
        defaultOption: {
            zlevel: 0,
            z: 5,
            symbol: "pin",
            symbolSize: 50,
            tooltip: {
                trigger: "item"
            },
            label: {
                show: !0,
                position: "inside"
            },
            itemStyle: {
                borderWidth: 2
            },
            emphasis: {
                label: {
                    show: !0
                }
            }
        }
    });
    var LD = C, kD = z, PD = {
        min: kD(gf, "min"),
        max: kD(gf, "max"),
        average: kD(gf, "average")
    }, ND = qo({
        type: "marker",
        init: function() {
            this.markerGroupMap = W();
        },
        render: function(t, i, n) {
            var e = this.markerGroupMap;
            e.each(function(t) {
                t.__keep = !1;
            });
            var a = this.type + "Model";
            i.eachSeries(function(t) {
                var e = t[a];
                e && this.renderSeries(t, e, i, n);
            }, this), e.each(function(t) {
                !t.__keep && this.group.remove(t.group);
            }, this);
        },
        renderSeries: function() {}
    });
    ND.extend({
        type: "markPoint",
        updateTransform: function(t, e, i) {
            e.eachSeries(function(t) {
                var e = t.markPointModel;
                e && (wf(e.getData(), t, i), this.markerGroupMap.get(t.id).updateLayout(e));
            }, this);
        },
        renderSeries: function(t, n, e, i) {
            var a = t.coordinateSystem, o = t.id, r = t.getData(), s = this.markerGroupMap, l = s.get(o) || s.set(o, new jr()), h = function(t, e, i) {
                var n;
                n = t ? L(t && t.dimensions, function(t) {
                    return E({
                        name: t
                    }, e.getData().getDimensionInfo(e.getData().mapDimension(t)) || {});
                }) : [ {
                    name: "value",
                    type: "float"
                } ];
                var a = new x_(n, i), o = L(i.get("data"), z(mf, e));
                return t && (o = I(o, z(yf, t))), a.initData(o, null, t ? xf : function(t) {
                    return t.value;
                }), a;
            }(a, t, n);
            n.setData(h), wf(n.getData(), t, i), h.each(function(t) {
                var e = h.getItemModel(t), i = e.getShallow("symbolSize");
                "function" == typeof i && (i = i(n.getRawValue(t), n.getDataParams(t))), h.setItemVisual(t, {
                    symbolSize: i,
                    color: e.get("itemStyle.color") || r.getVisual("color"),
                    symbol: e.getShallow("symbol")
                });
            }), l.updateData(h), this.group.add(l.group), h.eachItemGraphicEl(function(t) {
                t.traverse(function(t) {
                    t.dataModel = n;
                });
            }), l.__keep = !0, l.group.silent = n.get("silent") || t.get("silent");
        }
    }), Go(function(t) {
        t.markPoint = t.markPoint || {};
    }), CD.extend({
        type: "markLine",
        defaultOption: {
            zlevel: 0,
            z: 5,
            symbol: [ "circle", "arrow" ],
            symbolSize: [ 8, 16 ],
            precision: 2,
            tooltip: {
                trigger: "item"
            },
            label: {
                show: !0,
                position: "end"
            },
            lineStyle: {
                type: "dashed"
            },
            emphasis: {
                label: {
                    show: !0
                },
                lineStyle: {
                    width: 3
                }
            },
            animationEasing: "linear"
        }
    });
    var OD = function(t, e, i, n) {
        var a = t.getData(), o = n.type;
        if (!N(n) && ("min" === o || "max" === o || "average" === o || "median" === o || null != n.xAxis || null != n.yAxis)) {
            var r, s;
            if (null != n.yAxis || null != n.xAxis) r = null != n.yAxis ? "y" : "x", e.getAxis(r), 
            s = V(n.yAxis, n.xAxis); else {
                var l = vf(n, a, e, t);
                r = l.valueDataDim, l.valueAxis, s = _f(a, r, o);
            }
            var h = "x" === r ? 0 : 1, u = 1 - h, c = A(n), d = {};
            c.type = null, c.coord = [], d.coord = [], c.coord[u] = -1 / 0, d.coord[u] = 1 / 0;
            var f = i.get("precision");
            0 <= f && "number" == typeof s && (s = +s.toFixed(Math.min(f, 20))), c.coord[h] = d.coord[h] = s, 
            n = [ c, d, {
                type: o,
                valueIndex: n.valueIndex,
                value: s
            } ];
        }
        return (n = [ mf(t, n[0]), mf(t, n[1]), P({}, n[2]) ])[2].type = n[2].type || "", 
        g(n[2], n[0]), g(n[2], n[1]), n;
    };
    ND.extend({
        type: "markLine",
        updateTransform: function(t, e, o) {
            e.eachSeries(function(e) {
                var t = e.markLineModel;
                if (t) {
                    var i = t.getData(), n = t.__from, a = t.__to;
                    n.each(function(t) {
                        If(n, t, !0, e, o), If(a, t, !1, e, o);
                    }), i.each(function(t) {
                        i.setItemLayout(t, [ n.getItemLayout(t), a.getItemLayout(t) ]);
                    }), this.markerGroupMap.get(e.id).updateLayout();
                }
            }, this);
        },
        renderSeries: function(a, i, t, o) {
            function e(t, e, i) {
                var n = t.getItemModel(e);
                If(t, e, i, a, o), t.setItemVisual(e, {
                    symbolSize: n.get("symbolSize") || g[i ? 0 : 1],
                    symbol: n.get("symbol", !0) || p[i ? 0 : 1],
                    color: n.get("itemStyle.color") || s.getVisual("color")
                });
            }
            var n = a.coordinateSystem, r = a.id, s = a.getData(), l = this.markerGroupMap, h = l.get(r) || l.set(r, new fh());
            this.group.add(h.group);
            var u = function(t, e, i) {
                var n;
                n = t ? L(t && t.dimensions, function(t) {
                    return E({
                        name: t
                    }, e.getData().getDimensionInfo(e.getData().mapDimension(t)) || {});
                }) : [ {
                    name: "value",
                    type: "float"
                } ];
                var a = new x_(n, i), o = new x_(n, i), r = new x_([], i), s = L(i.get("data"), z(OD, e, t, i));
                t && (s = I(s, z(Mf, t)));
                var l = t ? xf : function(t) {
                    return t.value;
                };
                return a.initData(L(s, function(t) {
                    return t[0];
                }), null, l), o.initData(L(s, function(t) {
                    return t[1];
                }), null, l), r.initData(L(s, function(t) {
                    return t[2];
                })), r.hasItemOption = !0, {
                    from: a,
                    to: o,
                    line: r
                };
            }(n, a, i), c = u.from, d = u.to, f = u.line;
            i.__from = c, i.__to = d, i.setData(f);
            var p = i.get("symbol"), g = i.get("symbolSize");
            N(p) || (p = [ p, p ]), "number" == typeof g && (g = [ g, g ]), u.from.each(function(t) {
                e(c, t, !0), e(d, t, !1);
            }), f.each(function(t) {
                var e = f.getItemModel(t).get("lineStyle.color");
                f.setItemVisual(t, {
                    color: e || c.getItemVisual(t, "color")
                }), f.setItemLayout(t, [ c.getItemLayout(t), d.getItemLayout(t) ]), f.setItemVisual(t, {
                    fromSymbolSize: c.getItemVisual(t, "symbolSize"),
                    fromSymbol: c.getItemVisual(t, "symbol"),
                    toSymbolSize: d.getItemVisual(t, "symbolSize"),
                    toSymbol: d.getItemVisual(t, "symbol")
                });
            }), h.updateData(f), u.line.eachItemGraphicEl(function(t, e) {
                t.traverse(function(t) {
                    t.dataModel = i;
                });
            }), h.__keep = !0, h.group.silent = i.get("silent") || a.get("silent");
        }
    }), Go(function(t) {
        t.markLine = t.markLine || {};
    }), CD.extend({
        type: "markArea",
        defaultOption: {
            zlevel: 0,
            z: 1,
            tooltip: {
                trigger: "item"
            },
            animation: !1,
            label: {
                show: !0,
                position: "top"
            },
            itemStyle: {
                borderWidth: 0
            },
            emphasis: {
                label: {
                    show: !0,
                    position: "top"
                }
            }
        }
    });
    var ED = function(t, e, i, n) {
        var a = mf(t, n[0]), o = mf(t, n[1]), r = V, s = a.coord, l = o.coord;
        s[0] = r(s[0], -1 / 0), s[1] = r(s[1], -1 / 0), l[0] = r(l[0], 1 / 0), l[1] = r(l[1], 1 / 0);
        var h = u([ {}, a, o ]);
        return h.coord = [ a.coord, o.coord ], h.x0 = a.x, h.y0 = a.y, h.x1 = o.x, h.y1 = o.y, 
        h;
    }, RD = [ [ "x0", "y0" ], [ "x1", "y0" ], [ "x1", "y1" ], [ "x0", "y1" ] ];
    ND.extend({
        type: "markArea",
        updateTransform: function(t, e, a) {
            e.eachSeries(function(i) {
                var t = i.markAreaModel;
                if (t) {
                    var n = t.getData();
                    n.each(function(e) {
                        var t = L(RD, function(t) {
                            return Cf(n, e, t, i, a);
                        });
                        n.setItemLayout(e, t), n.getItemGraphicEl(e).setShape("points", t);
                    });
                }
            }, this);
        },
        renderSeries: function(i, r, t, n) {
            var e = i.coordinateSystem, a = i.id, o = i.getData(), s = this.markerGroupMap, l = s.get(a) || s.set(a, {
                group: new Dg()
            });
            this.group.add(l.group), l.__keep = !0;
            var h = function(t, i, e) {
                var n, a;
                t ? (n = L(t && t.dimensions, function(t) {
                    var e = i.getData();
                    return E({
                        name: t
                    }, e.getDimensionInfo(e.mapDimension(t)) || {});
                }), a = new x_(L([ "x0", "y0", "x1", "y1" ], function(t, e) {
                    return {
                        name: t,
                        type: n[e % 2].type
                    };
                }), e)) : a = new x_(n = [ {
                    name: "value",
                    type: "float"
                } ], e);
                var o = L(e.get("data"), z(ED, i, t, e));
                t && (o = I(o, z(Af, t)));
                var r = t ? function(t, e, i, n) {
                    return t.coord[Math.floor(n / 2)][n % 2];
                } : function(t) {
                    return t.value;
                };
                return a.initData(o, null, r), a.hasItemOption = !0, a;
            }(e, i, r);
            r.setData(h), h.each(function(e) {
                h.setItemLayout(e, L(RD, function(t) {
                    return Cf(h, e, t, i, n);
                })), h.setItemVisual(e, {
                    color: o.getVisual("color")
                });
            }), h.diff(l.__data).add(function(t) {
                var e = new Vv({
                    shape: {
                        points: h.getItemLayout(t)
                    }
                });
                h.setItemGraphicEl(t, e), l.group.add(e);
            }).update(function(t, e) {
                var i = l.__data.getItemGraphicEl(e);
                Mn(i, {
                    shape: {
                        points: h.getItemLayout(t)
                    }
                }, r, t), l.group.add(i), h.setItemGraphicEl(t, i);
            }).remove(function(t) {
                var e = l.__data.getItemGraphicEl(t);
                l.group.remove(e);
            }).execute(), h.eachItemGraphicEl(function(t, e) {
                var i = h.getItemModel(e), n = i.getModel("label"), a = i.getModel("emphasis.label"), o = h.getItemVisual(e, "color");
                t.useStyle(E(i.getModel("itemStyle").getItemStyle(), {
                    fill: Nt(o, .4),
                    stroke: o
                })), t.hoverStyle = i.getModel("emphasis.itemStyle").getItemStyle(), mn(t.style, t.hoverStyle, n, a, {
                    labelFetcher: r,
                    labelDataIndex: e,
                    defaultText: h.getName(e) || "",
                    isRectText: !0,
                    autoColor: o
                }), gn(t, {}), t.dataModel = r;
            }), l.__data = h, l.group.silent = r.get("silent") || i.get("silent");
        }
    }), Go(function(t) {
        t.markArea = t.markArea || {};
    }), Cy.registerSubTypeDefaulter("timeline", function() {
        return "slider";
    }), Fo({
        type: "timelineChange",
        event: "timelineChanged",
        update: "prepareAndUpdate"
    }, function(t, e) {
        var i = e.getComponent("timeline");
        return i && null != t.currentIndex && (i.setCurrentIndex(t.currentIndex), !i.get("loop", !0) && i.isIndexMax() && i.setPlayState(!1)), 
        e.resetOption("timeline"), E({
            currentIndex: i.option.currentIndex
        }, t);
    }), Fo({
        type: "timelinePlayChange",
        event: "timelinePlayChanged",
        update: "update"
    }, function(t, e) {
        var i = e.getComponent("timeline");
        i && null != t.playState && i.setPlayState(t.playState);
    });
    var zD = Cy.extend({
        type: "timeline",
        layoutMode: "box",
        defaultOption: {
            zlevel: 0,
            z: 4,
            show: !0,
            axisType: "time",
            realtime: !0,
            left: "20%",
            top: null,
            right: "20%",
            bottom: 0,
            width: null,
            height: 40,
            padding: 5,
            controlPosition: "left",
            autoPlay: !1,
            rewind: !1,
            loop: !0,
            playInterval: 2e3,
            currentIndex: 0,
            itemStyle: {},
            label: {
                color: "#000"
            },
            data: []
        },
        init: function(t, e, i) {
            this._data, this._names, this.mergeDefaultAndTheme(t, i), this._initData();
        },
        mergeOption: function(t) {
            zD.superApply(this, "mergeOption", arguments), this._initData();
        },
        setCurrentIndex: function(t) {
            null == t && (t = this.option.currentIndex);
            var e = this._data.count();
            this.option.loop ? t = (t % e + e) % e : (e <= t && (t = e - 1), t < 0 && (t = 0)), 
            this.option.currentIndex = t;
        },
        getCurrentIndex: function() {
            return this.option.currentIndex;
        },
        isIndexMax: function() {
            return this.getCurrentIndex() >= this._data.count() - 1;
        },
        setPlayState: function(t) {
            this.option.autoPlay = !!t;
        },
        getPlayState: function() {
            return !!this.option.autoPlay;
        },
        _initData: function() {
            var t = this.option, e = t.data || [], i = t.axisType, a = this._names = [];
            if ("category" === i) {
                var o = [];
                R(e, function(t, e) {
                    var i, n = ei(t);
                    B(t) ? (i = A(t)).value = e : i = e, o.push(i), b(n) || null != n && !isNaN(n) || (n = ""), 
                    a.push(n + "");
                }), e = o;
            }
            var n = {
                category: "ordinal",
                time: "time"
            }[i] || "number";
            (this._data = new x_([ {
                name: "value",
                type: n
            } ], this)).initData(e, a);
        },
        getData: function() {
            return this._data;
        },
        getCategories: function() {
            if ("category" === this.get("axisType")) return this._names.slice();
        }
    });
    a(zD.extend({
        type: "timeline.slider",
        defaultOption: {
            backgroundColor: "rgba(0,0,0,0)",
            borderColor: "#ccc",
            borderWidth: 0,
            orient: "horizontal",
            inverse: !1,
            tooltip: {
                trigger: "item"
            },
            symbol: "emptyCircle",
            symbolSize: 10,
            lineStyle: {
                show: !0,
                width: 2,
                color: "#304654"
            },
            label: {
                position: "auto",
                show: !0,
                interval: "auto",
                rotate: 0,
                color: "#304654"
            },
            itemStyle: {
                color: "#304654",
                borderWidth: 1
            },
            checkpointStyle: {
                symbol: "circle",
                symbolSize: 13,
                color: "#c23531",
                borderWidth: 5,
                borderColor: "rgba(194,53,49, 0.5)",
                animation: !0,
                animationDuration: 300,
                animationEasing: "quinticInOut"
            },
            controlStyle: {
                show: !0,
                showPlayBtn: !0,
                showPrevBtn: !0,
                showNextBtn: !0,
                itemSize: 22,
                itemGap: 12,
                position: "left",
                playIcon: "path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z",
                stopIcon: "path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z",
                nextIcon: "path://M18.6,50.8l22.5-22.5c0.2-0.2,0.3-0.4,0.3-0.7c0-0.3-0.1-0.5-0.3-0.7L18.7,4.4c-0.1-0.1-0.2-0.3-0.2-0.5 c0-0.4,0.3-0.8,0.8-0.8c0.2,0,0.5,0.1,0.6,0.3l23.5,23.5l0,0c0.2,0.2,0.3,0.4,0.3,0.7c0,0.3-0.1,0.5-0.3,0.7l-0.1,0.1L19.7,52 c-0.1,0.1-0.3,0.2-0.5,0.2c-0.4,0-0.8-0.3-0.8-0.8C18.4,51.2,18.5,51,18.6,50.8z",
                prevIcon: "path://M43,52.8L20.4,30.3c-0.2-0.2-0.3-0.4-0.3-0.7c0-0.3,0.1-0.5,0.3-0.7L42.9,6.4c0.1-0.1,0.2-0.3,0.2-0.5 c0-0.4-0.3-0.8-0.8-0.8c-0.2,0-0.5,0.1-0.6,0.3L18.3,28.8l0,0c-0.2,0.2-0.3,0.4-0.3,0.7c0,0.3,0.1,0.5,0.3,0.7l0.1,0.1L41.9,54 c0.1,0.1,0.3,0.2,0.5,0.2c0.4,0,0.8-0.3,0.8-0.8C43.2,53.2,43.1,53,43,52.8z",
                color: "#304654",
                borderColor: "#304654",
                borderWidth: 1
            },
            emphasis: {
                label: {
                    show: !0,
                    color: "#c23531"
                },
                itemStyle: {
                    color: "#c23531"
                },
                controlStyle: {
                    color: "#c23531",
                    borderColor: "#c23531",
                    borderWidth: 2
                }
            },
            data: []
        }
    }), cx);
    var BD = gx.extend({
        type: "timeline"
    }), VD = function(t, e, i, n) {
        aw.call(this, t, e, i), this.type = n || "value", this._autoLabelInterval, this.model = null;
    };
    VD.prototype = {
        constructor: VD,
        getLabelInterval: function() {
            var t = this.model, e = t.getModel("label"), i = e.get("interval");
            return null != i && "auto" != i || (i = this._autoLabelInterval) || (i = this._autoLabelInterval = Pr(L(this.scale.getTicks(), this.dataToCoord, this), Nr(this, e.get("formatter")), e.getFont(), "horizontal" === t.get("orient") ? 0 : 90, e.get("rotate"))), 
            i;
        },
        isLabelIgnored: function(t) {
            if ("category" === this.type) {
                var e = this.getLabelInterval();
                return "function" == typeof e && !e(t, this.scale.getLabel(t)) || t % (e + 1);
            }
        }
    }, o(VD, aw);
    var GD = _, WD = R, FD = Math.PI;
    BD.extend({
        type: "timeline.slider",
        init: function(t, e) {
            this.api = e, this._axis, this._viewRect, this._timer, this._currentPointer, this._mainGroup, 
            this._labelGroup;
        },
        render: function(e, t, i, n) {
            if (this.model = e, this.api = i, this.ecModel = t, this.group.removeAll(), e.get("show", !0)) {
                var a = this._layout(e, i), o = this._createGroup("mainGroup"), r = this._createGroup("labelGroup"), s = this._axis = this._createAxis(a, e);
                e.formatTooltip = function(t) {
                    return ta(s.scale.getLabel(t));
                }, WD([ "AxisLine", "AxisTick", "Control", "CurrentPointer" ], function(t) {
                    this["_render" + t](a, o, s, e);
                }, this), this._renderAxisLabel(a, r, s, e), this._position(a, e);
            }
            this._doPlayStop();
        },
        remove: function() {
            this._clearTimer(), this.group.removeAll();
        },
        dispose: function() {
            this._clearTimer();
        },
        _layout: function(t, e) {
            var i, n, a = t.get("label.position"), o = t.get("orient"), r = (n = e, la((i = t).getBoxLayoutParams(), {
                width: n.getWidth(),
                height: n.getHeight()
            }, i.get("padding")));
            null == a || "auto" === a ? a = "horizontal" === o ? r.y + r.height / 2 < e.getHeight() / 2 ? "-" : "+" : r.x + r.width / 2 < e.getWidth() / 2 ? "+" : "-" : isNaN(a) && (a = {
                horizontal: {
                    top: "-",
                    bottom: "+"
                },
                vertical: {
                    left: "-",
                    right: "+"
                }
            }[o][a]);
            var s = {
                horizontal: "center",
                vertical: 0 <= a || "+" === a ? "left" : "right"
            }, l = {
                horizontal: 0 <= a || "+" === a ? "top" : "bottom",
                vertical: "middle"
            }, h = {
                horizontal: 0,
                vertical: FD / 2
            }, u = "vertical" === o ? r.height : r.width, c = t.getModel("controlStyle"), d = c.get("show", !0), f = d ? c.get("itemSize") : 0, p = d ? c.get("itemGap") : 0, g = f + p, m = t.get("label.rotate") || 0;
            m = m * FD / 180;
            var v, y, x, _, w = c.get("position", !0), b = d && c.get("showPlayBtn", !0), S = d && c.get("showPrevBtn", !0), M = d && c.get("showNextBtn", !0), I = 0, T = u;
            return "left" === w || "bottom" === w ? (b && (v = [ 0, 0 ], I += g), S && (y = [ I, 0 ], 
            I += g)) : (b && (v = [ T - f, 0 ], T -= g), S && (y = [ 0, 0 ], I += g)), M && (x = [ T - f, 0 ], 
            T -= g), _ = [ I, T ], t.get("inverse") && _.reverse(), {
                viewRect: r,
                mainLength: u,
                orient: o,
                rotation: h[o],
                labelRotation: m,
                labelPosOpt: a,
                labelAlign: t.get("label.align") || s[o],
                labelBaseline: t.get("label.verticalAlign") || t.get("label.baseline") || l[o],
                playPosition: v,
                prevBtnPosition: y,
                nextBtnPosition: x,
                axisExtent: _,
                controlSize: f,
                controlGap: p
            };
        },
        _position: function(t, e) {
            function i(t) {
                var e = t.position;
                t.origin = [ c[0][0] - e[0], c[1][0] - e[1] ];
            }
            function n(t) {
                return [ [ t.x, t.x + t.width ], [ t.y, t.y + t.height ] ];
            }
            function a(t, e, i, n, a) {
                t[n] += i[n][a] - e[n][a];
            }
            var o = this._mainGroup, r = this._labelGroup, s = t.viewRect;
            if ("vertical" === t.orient) {
                var l = rt(), h = s.x, u = s.y + s.height;
                ut(l, l, [ -h, -u ]), ct(l, l, -FD / 2), ut(l, l, [ h, u ]), (s = s.clone()).applyTransform(l);
            }
            var c = n(s), d = n(o.getBoundingRect()), f = n(r.getBoundingRect()), p = o.position, g = r.position;
            g[0] = p[0] = c[0][0];
            var m = t.labelPosOpt;
            if (isNaN(m)) a(p, d, c, 1, v = "+" === m ? 0 : 1), a(g, f, c, 1, 1 - v); else {
                var v = 0 <= m ? 0 : 1;
                a(p, d, c, 1, v), g[1] = p[1] + m;
            }
            o.attr("position", p), r.attr("position", g), o.rotation = r.rotation = t.rotation, 
            i(o), i(r);
        },
        _createAxis: function(t, e) {
            var i = e.getData(), n = e.get("axisType"), a = kr(e, n), o = i.getDataExtent("value");
            a.setExtent(o[0], o[1]), this._customizeScale(a, i), a.niceTicks();
            var r = new VD("value", a, t.axisExtent, n);
            return r.model = e, r;
        },
        _customizeScale: function(t, e) {
            t.getTicks = function() {
                return e.mapArray([ "value" ], function(t) {
                    return t;
                });
            }, t.getTicksLabels = function() {
                return L(this.getTicks(), t.getLabel, t);
            };
        },
        _createGroup: function(t) {
            var e = this["_" + t] = new Dg();
            return this.group.add(e), e;
        },
        _renderAxisLine: function(t, e, i, n) {
            var a = i.getExtent();
            n.get("lineStyle.show") && e.add(new Fv({
                shape: {
                    x1: a[0],
                    y1: 0,
                    x2: a[1],
                    y2: 0
                },
                style: P({
                    lineCap: "round"
                }, n.getModel("lineStyle").getLineStyle()),
                silent: !0,
                z2: 1
            }));
        },
        _renderAxisTick: function(t, l, h, u) {
            var c = u.getData(), e = h.scale.getTicks();
            WD(e, function(t, e) {
                var i = h.dataToCoord(t), n = c.getItemModel(e), a = n.getModel("itemStyle"), o = n.getModel("emphasis.itemStyle"), r = {
                    position: [ i, 0 ],
                    onclick: GD(this._changeTimeline, this, e)
                }, s = Pf(n, a, l, r);
                gn(s, o.getItemStyle()), n.get("tooltip") ? (s.dataIndex = e, s.dataModel = u) : s.dataIndex = s.dataModel = null;
            }, this);
        },
        _renderAxisLabel: function(s, l, h, t) {
            var e = t.getModel("label");
            if (e.get("show")) {
                var u = t.getData(), i = h.scale.getTicks(), c = Nr(h, e.get("formatter")), d = h.getLabelInterval();
                WD(i, function(t, e) {
                    if (!h.isLabelIgnored(e, d)) {
                        var i = u.getItemModel(e), n = i.getModel("label"), a = i.getModel("emphasis.label"), o = h.dataToCoord(t), r = new Nv({
                            position: [ o, 0 ],
                            rotation: s.labelRotation - s.rotation,
                            onclick: GD(this._changeTimeline, this, e),
                            silent: !1
                        });
                        vn(r.style, n, {
                            text: c[e],
                            textAlign: s.labelAlign,
                            textVerticalAlign: s.labelBaseline
                        }), l.add(r), gn(r, vn({}, a));
                    }
                }, this);
            }
        },
        _renderControl: function(t, l, e, h) {
            function i(t, e, i, n) {
                if (t) {
                    var a = (o = e, r = p, s = {
                        position: t,
                        origin: [ u / 2, 0 ],
                        rotation: n ? -c : 0,
                        rectHover: !0,
                        style: d,
                        onclick: i
                    }, qi(h.get(o).replace(/^path:\/\//, ""), A(s || {}), new Xt(r[0], r[1], r[2], r[3]), "center"));
                    l.add(a), gn(a, f);
                }
                var o, r, s;
            }
            var u = t.controlSize, c = t.rotation, d = h.getModel("controlStyle").getItemStyle(), f = h.getModel("emphasis.controlStyle").getItemStyle(), p = [ 0, -u / 2, u, u ], n = h.getPlayState(), a = h.get("inverse", !0);
            i(t.nextBtnPosition, "controlStyle.nextIcon", GD(this._changeTimeline, this, a ? "-" : "+")), 
            i(t.prevBtnPosition, "controlStyle.prevIcon", GD(this._changeTimeline, this, a ? "+" : "-")), 
            i(t.playPosition, "controlStyle." + (n ? "stopIcon" : "playIcon"), GD(this._handlePlayClick, this, !n), !0);
        },
        _renderCurrentPointer: function(t, e, i, n) {
            var a = n.getData(), o = n.getCurrentIndex(), r = a.getItemModel(o).getModel("checkpointStyle"), s = this, l = {
                onCreate: function(t) {
                    t.draggable = !0, t.drift = GD(s._handlePointerDrag, s), t.ondragend = GD(s._handlePointerDragend, s), 
                    Nf(t, o, i, n, !0);
                },
                onUpdate: function(t) {
                    Nf(t, o, i, n);
                }
            };
            this._currentPointer = Pf(r, r, this._mainGroup, {}, this._currentPointer, l);
        },
        _handlePlayClick: function(t) {
            this._clearTimer(), this.api.dispatchAction({
                type: "timelinePlayChange",
                playState: t,
                from: this.uid
            });
        },
        _handlePointerDrag: function(t, e, i) {
            this._clearTimer(), this._pointerChangeTimeline([ i.offsetX, i.offsetY ]);
        },
        _handlePointerDragend: function(t) {
            this._pointerChangeTimeline([ t.offsetX, t.offsetY ], !0);
        },
        _pointerChangeTimeline: function(t, e) {
            var i = this._toAxisCoord(t)[0], n = Vn(this._axis.getExtent().slice());
            i > n[1] && (i = n[1]), i < n[0] && (i = n[0]), this._currentPointer.position[0] = i, 
            this._currentPointer.dirty();
            var a = this._findNearestTick(i), o = this.model;
            (e || a !== o.getCurrentIndex() && o.get("realtime")) && this._changeTimeline(a);
        },
        _doPlayStop: function() {
            this._clearTimer(), this.model.getPlayState() && (this._timer = setTimeout(GD(function() {
                var t = this.model;
                this._changeTimeline(t.getCurrentIndex() + (t.get("rewind", !0) ? -1 : 1));
            }, this), this.model.get("playInterval")));
        },
        _toAxisCoord: function(t) {
            return Dn(t, this._mainGroup.getLocalTransform(), !0);
        },
        _findNearestTick: function(a) {
            var o, t = this.model.getData(), r = 1 / 0, s = this._axis;
            return t.each([ "value" ], function(t, e) {
                var i = s.dataToCoord(t), n = Math.abs(i - a);
                n < r && (r = n, o = e);
            }), o;
        },
        _clearTimer: function() {
            this._timer && (clearTimeout(this._timer), this._timer = null);
        },
        _changeTimeline: function(t) {
            var e = this.model.getCurrentIndex();
            "+" === t ? t = e + 1 : "-" === t && (t = e - 1), this.api.dispatchAction({
                type: "timelineChange",
                currentIndex: t,
                from: this.uid
            });
        }
    }), Go(function(t) {
        var e = t && t.timeline;
        N(e) || (e = e ? [ e ] : []), R(e, function(t) {
            t && function(t) {
                var e = t.type, i = {
                    number: "value",
                    time: "time"
                };
                if (i[e] && (t.axisType = i[e], delete t.type), Lf(t), kf(t, "controlPosition")) {
                    var n = t.controlStyle || (t.controlStyle = {});
                    kf(n, "position") || (n.position = t.controlPosition), "none" !== n.position || kf(n, "show") || (n.show = !1, 
                    delete n.position), delete t.controlPosition;
                }
                R(t.data || [], function(t) {
                    B(t) && !N(t) && (!kf(t, "value") && kf(t, "name") && (t.value = t.name), Lf(t));
                });
            }(t);
        });
    });
    var HD = Yo({
        type: "toolbox",
        layoutMode: {
            type: "box",
            ignoreSize: !0
        },
        mergeDefaultAndTheme: function(t) {
            HD.superApply(this, "mergeDefaultAndTheme", arguments), R(this.option.feature, function(t, e) {
                var i = Gd(e);
                i && g(t, i.defaultOption);
            });
        },
        defaultOption: {
            show: !0,
            z: 6,
            zlevel: 0,
            orient: "horizontal",
            left: "right",
            top: "top",
            backgroundColor: "transparent",
            borderColor: "#ccc",
            borderRadius: 0,
            borderWidth: 0,
            padding: 5,
            itemSize: 15,
            itemGap: 8,
            showTitle: !0,
            iconStyle: {
                borderColor: "#666",
                color: "none"
            },
            emphasis: {
                iconStyle: {
                    borderColor: "#3E98C5"
                }
            }
        }
    });
    qo({
        type: "toolbox",
        render: function(u, c, d, s) {
            function t(t, e) {
                var i, n = m[t], a = m[e], o = new Pn(h[n], u, u.ecModel);
                if (n && !a) {
                    if (0 === n.indexOf("my")) i = {
                        model: o,
                        onclick: o.option.onclick,
                        featureName: n
                    }; else {
                        var r = Gd(n);
                        if (!r) return;
                        i = new r(o, c, d);
                    }
                    g[n] = i;
                } else {
                    if (!(i = g[a])) return;
                    i.model = o, i.ecModel = c, i.api = d;
                }
                n || !a ? o.get("show") && !i.unusable ? (function(n, a, t) {
                    var o = n.getModel("iconStyle"), r = n.getModel("emphasis.iconStyle"), e = a.getIcons ? a.getIcons() : n.get("icon"), s = n.get("title") || {};
                    if ("string" == typeof e) {
                        var i = e, l = s;
                        s = {}, (e = {})[t] = i, s[t] = l;
                    }
                    var h = n.iconPaths = {};
                    R(e, function(t, e) {
                        var i = kn(t, {}, {
                            x: -p / 2,
                            y: -p / 2,
                            width: p,
                            height: p
                        });
                        i.setStyle(o.getItemStyle()), i.hoverStyle = r.getItemStyle(), gn(i), u.get("showTitle") && (i.__title = s[e], 
                        i.on("mouseover", function() {
                            var t = r.getItemStyle();
                            i.setStyle({
                                text: s[e],
                                textPosition: t.textPosition || "bottom",
                                textFill: t.fill || t.stroke || "#000",
                                textAlign: t.textAlign || "center"
                            });
                        }).on("mouseout", function() {
                            i.setStyle({
                                textFill: null
                            });
                        })), i.trigger(n.get("iconStatus." + e) || "normal"), f.add(i), i.on("click", _(a.onclick, a, c, d, e)), 
                        h[e] = i;
                    });
                }(o, i, n), o.setIconStatus = function(t, e) {
                    var i = this.option, n = this.iconPaths;
                    i.iconStatus = i.iconStatus || {}, i.iconStatus[t] = e, n[t] && n[t].trigger(e);
                }, i.render && i.render(o, c, d, s)) : i.remove && i.remove(c, d) : i.dispose && i.dispose(c, d);
            }
            var e, i, n, a, o, r, l, f = this.group;
            if (f.removeAll(), u.get("show")) {
                var p = +u.get("itemSize"), h = u.get("feature") || {}, g = this._features || (this._features = {}), m = [];
                R(h, function(t, e) {
                    m.push(e);
                }), new tr(this._featureNames || [], m).add(t).update(t).remove(z(t, null)).execute(), 
                this._featureNames = m, e = f, n = d, a = (i = u).getBoxLayoutParams(), o = i.get("padding"), 
                r = {
                    width: n.getWidth(),
                    height: n.getHeight()
                }, l = la(a, r, o), Dy(i.get("orient"), e, i.get("itemGap"), l.width, l.height), 
                ha(e, a, r, o), f.add(Jc(f.getBoundingRect(), u)), f.eachChild(function(t) {
                    var e = t.__title, i = t.hoverStyle;
                    if (i && e) {
                        var n = le(e, _e(i)), a = t.position[0] + f.position[0], o = !1;
                        t.position[1] + f.position[1] + p + n.height > d.getHeight() && (i.textPosition = "top", 
                        o = !0);
                        var r = o ? -5 - n.height : p + 8;
                        a + n.width / 2 > d.getWidth() ? (i.textPosition = [ "100%", r ], i.textAlign = "right") : a - n.width / 2 < 0 && (i.textPosition = [ 0, r ], 
                        i.textAlign = "left");
                    }
                });
            }
        },
        updateView: function(t, e, i, n) {
            R(this._features, function(t) {
                t.updateView && t.updateView(t.model, e, i, n);
            });
        },
        remove: function(e, i) {
            R(this._features, function(t) {
                t.remove && t.remove(e, i);
            }), this.group.removeAll();
        },
        dispose: function(e, i) {
            R(this._features, function(t) {
                t.dispose && t.dispose(e, i);
            });
        }
    });
    var ZD = Dx.toolbox.saveAsImage;
    Of.defaultOption = {
        show: !0,
        icon: "M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0",
        title: ZD.title,
        type: "png",
        name: "",
        excludeComponents: [ "toolbox" ],
        pixelRatio: 1,
        lang: ZD.lang.slice()
    }, Of.prototype.unusable = !Sp.canvasSupported, Of.prototype.onclick = function(t, e) {
        var i = this.model, n = i.get("name") || t.get("title.0.text") || "echarts", a = document.createElement("a"), o = i.get("type", !0) || "png";
        a.download = n + "." + o, a.target = "_blank";
        var r = e.getConnectedDataURL({
            type: o,
            backgroundColor: i.get("backgroundColor", !0) || t.get("backgroundColor") || "#fff",
            excludeComponents: i.get("excludeComponents"),
            pixelRatio: i.get("pixelRatio")
        });
        if (a.href = r, "function" != typeof MouseEvent || Sp.browser.ie || Sp.browser.edge) if (window.navigator.msSaveOrOpenBlob) {
            for (var s = atob(r.split(",")[1]), l = s.length, h = new Uint8Array(l); l--; ) h[l] = s.charCodeAt(l);
            var u = new Blob([ h ]);
            window.navigator.msSaveOrOpenBlob(u, n + "." + o);
        } else {
            var c = i.get("lang"), d = '<body style="margin:0;"><img src="' + r + '" style="max-width:100%;" title="' + (c && c[0] || "") + '" /></body>';
            window.open().document.write(d);
        } else {
            var f = new MouseEvent("click", {
                view: window,
                bubbles: !0,
                cancelable: !1
            });
            a.dispatchEvent(f);
        }
    }, Vd("saveAsImage", Of);
    var UD = Dx.toolbox.magicType;
    Ef.defaultOption = {
        show: !0,
        type: [],
        icon: {
            line: "M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4",
            bar: "M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7",
            stack: "M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z",
            tiled: "M2.3,2.2h22.8V25H2.3V2.2z M35,2.2h22.8V25H35V2.2zM2.3,35h22.8v22.8H2.3V35z M35,35h22.8v22.8H35V35z"
        },
        title: A(UD.title),
        option: {},
        seriesIndex: {}
    };
    var jD = Ef.prototype;
    jD.getIcons = function() {
        var t = this.model, e = t.get("icon"), i = {};
        return R(t.get("type"), function(t) {
            e[t] && (i[t] = e[t]);
        }), i;
    };
    var XD = {
        line: function(t, e, i, n) {
            if ("bar" === t) return g({
                id: e,
                type: "line",
                data: i.get("data"),
                stack: i.get("stack"),
                markPoint: i.get("markPoint"),
                markLine: i.get("markLine")
            }, n.get("option.line") || {}, !0);
        },
        bar: function(t, e, i, n) {
            if ("line" === t) return g({
                id: e,
                type: "bar",
                data: i.get("data"),
                stack: i.get("stack"),
                markPoint: i.get("markPoint"),
                markLine: i.get("markLine")
            }, n.get("option.bar") || {}, !0);
        },
        stack: function(t, e, i, n) {
            if ("line" === t || "bar" === t) return g({
                id: e,
                stack: "__ec_magicType_stack__"
            }, n.get("option.stack") || {}, !0);
        },
        tiled: function(t, e, i, n) {
            if ("line" === t || "bar" === t) return g({
                id: e,
                stack: ""
            }, n.get("option.tiled") || {}, !0);
        }
    }, YD = [ [ "line", "bar" ], [ "stack", "tiled" ] ];
    jD.onclick = function(h, t, u) {
        var c = this.model, e = c.get("seriesIndex." + u);
        if (XD[u]) {
            var d = {
                series: []
            };
            R(YD, function(t) {
                0 <= C(t, u) && R(t, function(t) {
                    c.setIconStatus(t, "normal");
                });
            }), c.setIconStatus(u, "emphasis"), h.eachComponent({
                mainType: "series",
                query: null == e ? null : {
                    seriesIndex: e
                }
            }, function(t) {
                var e = t.subType, i = t.id, n = XD[u](e, i, t, c);
                n && (E(n, t.option), d.series.push(n));
                var a = t.coordinateSystem;
                if (a && "cartesian2d" === a.type && ("line" === u || "bar" === u)) {
                    var o = a.getAxesByScale("ordinal")[0];
                    if (o) {
                        var r = o.dim + "Axis", s = h.queryComponents({
                            mainType: r,
                            index: t.get(name + "Index"),
                            id: t.get(name + "Id")
                        })[0].componentIndex;
                        d[r] = d[r] || [];
                        for (var l = 0; l <= s; l++) d[r][s] = d[r][s] || {};
                        d[r][s].boundaryGap = "bar" === u;
                    }
                }
            }), t.dispatchAction({
                type: "changeMagicType",
                currentType: u,
                newOption: d
            });
        }
    }, Fo({
        type: "changeMagicType",
        event: "magicTypeChanged",
        update: "prepareAndUpdate"
    }, function(t, e) {
        e.mergeOption(t.newOption);
    }), Vd("magicType", Ef);
    var qD = Dx.toolbox.dataView, KD = new Array(60).join("-"), $D = "\t", JD = new RegExp("[" + $D + "]+", "g");
    Vf.defaultOption = {
        show: !0,
        readOnly: !1,
        optionToContent: null,
        contentToOption: null,
        icon: "M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28",
        title: A(qD.title),
        lang: A(qD.lang),
        backgroundColor: "#fff",
        textColor: "#000",
        textareaColor: "#fff",
        textareaBorderColor: "#333",
        buttonColor: "#c23531",
        buttonTextColor: "#fff"
    }, Vf.prototype.onclick = function(t, e) {
        function i() {
            n.removeChild(o), x._dom = null;
        }
        var n = e.getDom(), a = this.model;
        this._dom && n.removeChild(this._dom);
        var o = document.createElement("div");
        o.style.cssText = "position:absolute;left:5px;top:5px;bottom:5px;right:5px;", o.style.backgroundColor = a.get("backgroundColor") || "#fff";
        var r = document.createElement("h4"), s = a.get("lang") || [];
        r.innerHTML = s[0] || a.get("title"), r.style.cssText = "margin: 10px 20px;", r.style.color = a.get("textColor");
        var l = document.createElement("div"), h = document.createElement("textarea");
        l.style.cssText = "display:block;width:100%;overflow:auto;";
        var u = a.get("optionToContent"), c = a.get("contentToOption"), d = Rf(t);
        if ("function" == typeof u) {
            var f = u(e.getOption());
            "string" == typeof f ? l.innerHTML = f : w(f) && l.appendChild(f);
        } else l.appendChild(h), h.readOnly = a.get("readOnly"), h.style.cssText = "width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;", 
        h.style.color = a.get("textColor"), h.style.borderColor = a.get("textareaBorderColor"), 
        h.style.backgroundColor = a.get("textareaColor"), h.value = d.value;
        var p = d.meta, g = document.createElement("div");
        g.style.cssText = "position:absolute;bottom:0;left:0;right:0;";
        var m = "float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px", v = document.createElement("div"), y = document.createElement("div");
        m += ";background-color:" + a.get("buttonColor"), m += ";color:" + a.get("buttonTextColor");
        var x = this;
        He(v, "click", i), He(y, "click", function() {
            var t;
            try {
                t = "function" == typeof c ? c(l, e.getOption()) : Bf(h.value, p);
            } catch (t) {
                throw i(), new Error("Data view format error " + t);
            }
            t && e.dispatchAction({
                type: "changeDataView",
                newOption: t
            }), i();
        }), v.innerHTML = s[1], y.innerHTML = s[2], y.style.cssText = m, v.style.cssText = m, 
        !a.get("readOnly") && g.appendChild(y), g.appendChild(v), He(h, "keydown", function(t) {
            if (9 === (t.keyCode || t.which)) {
                var e = this.value, i = this.selectionStart, n = this.selectionEnd;
                this.value = e.substring(0, i) + $D + e.substring(n), this.selectionStart = this.selectionEnd = i + 1, 
                nm(t);
            }
        }), o.appendChild(r), o.appendChild(l), o.appendChild(g), l.style.height = n.clientHeight - 80 + "px", 
        n.appendChild(o), this._dom = o;
    }, Vf.prototype.remove = function(t, e) {
        this._dom && e.getDom().removeChild(this._dom);
    }, Vf.prototype.dispose = function(t, e) {
        this.remove(t, e);
    }, Vd("dataView", Vf), Fo({
        type: "changeDataView",
        event: "dataViewChanged",
        update: "prepareAndUpdate"
    }, function(t, o) {
        var r = [];
        R(t.newOption.series, function(t) {
            var e, n, i = o.getSeriesByName(t.name)[0];
            if (i) {
                var a = i.get("data");
                r.push({
                    name: t.name,
                    data: (e = t.data, n = a, L(e, function(t, e) {
                        var i = n && n[e];
                        return B(i) && !N(i) ? (B(t) && !N(t) && (t = t.value), E({
                            value: t
                        }, i)) : t;
                    }))
                });
            } else r.push(P({
                type: "scatter"
            }, t));
        }), o.mergeOption(E({
            series: r
        }, t.newOption));
    });
    var QD = R, tA = "\0_ec_hist_store";
    ZT.extend({
        type: "dataZoom.select"
    }), UT.extend({
        type: "dataZoom.select"
    });
    var eA = Dx.toolbox.dataZoom, iA = R;
    Wf.defaultOption = {
        show: !0,
        icon: {
            zoom: "M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1",
            back: "M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26"
        },
        title: A(eA.title)
    };
    var nA = Wf.prototype;
    nA.render = function(t, e, i, n) {
        this.model = t, this.ecModel = e, this.api = i, function(t, e, i, n, a) {
            var o = i._isZoomActive;
            n && "takeGlobalCursor" === n.type && (o = "dataZoomSelect" === n.key && n.dataZoomSelectActive), 
            i._isZoomActive = o, t.setIconStatus("zoom", o ? "emphasis" : "normal");
            var r = new Dd(Ff(t.option), e, {
                include: [ "grid" ]
            });
            i._brushController.setPanels(r.makePanelOpts(a, function(t) {
                return t.xAxisDeclared && !t.yAxisDeclared ? "lineX" : !t.xAxisDeclared && t.yAxisDeclared ? "lineY" : "rect";
            })).enableBrush(!!o && {
                brushType: "auto",
                brushStyle: {
                    lineWidth: 0,
                    fill: "rgba(0,0,0,0.2)"
                }
            });
        }(t, e, this, n, i), Hf(t, e);
    }, nA.onclick = function(t, e, i) {
        aA[i].call(this);
    }, nA.remove = function(t, e) {
        this._brushController.unmount();
    }, nA.dispose = function(t, e) {
        this._brushController.dispose();
    };
    var aA = {
        zoom: function() {
            var t = !this._isZoomActive;
            this.api.dispatchAction({
                type: "takeGlobalCursor",
                key: "dataZoomSelect",
                dataZoomSelectActive: t
            });
        },
        back: function() {
            this._dispatchZoomAction(function(t) {
                var n = Gf(t), e = n[n.length - 1];
                1 < n.length && n.pop();
                var a = {};
                return QD(e, function(t, e) {
                    for (var i = n.length - 1; 0 <= i; i--) if (t = n[i][e]) {
                        a[e] = t;
                        break;
                    }
                }), a;
            }(this.ecModel));
        }
    };
    nA._onBrush = function(t, e) {
        function a(t, e, i) {
            var n, a, o, r = e.getAxis(t), s = r.model, l = (n = t, a = s, c.eachComponent({
                mainType: "dataZoom",
                subType: "select"
            }, function(t) {
                t.getAxisModel(n, a.componentIndex) && (o = t);
            }), o), h = l.findRepresentativeAxisProxy(s).getMinMaxSpan();
            null == h.minValueSpan && null == h.maxValueSpan || (i = HS(0, i.slice(), r.scale.getExtent(), 0, h.minValueSpan, h.maxValueSpan)), 
            l && (u[l.id] = {
                dataZoomId: l.id,
                startValue: i[0],
                endValue: i[1]
            });
        }
        if (e.isEnd && t.length) {
            var u = {}, c = this.ecModel;
            this._brushController.updateCovers([]), new Dd(Ff(this.model.option), c, {
                include: [ "grid" ]
            }).matchOutputRanges(t, c, function(t, e, i) {
                if ("cartesian2d" === i.type) {
                    var n = t.brushType;
                    "rect" === n ? (a("x", i, e[0]), a("y", i, e[1])) : a({
                        lineX: "x",
                        lineY: "y"
                    }[n], i, e);
                }
            }), i = u, r = Gf(o = c), QD(i, function(t, e) {
                for (var i = r.length - 1; 0 <= i && !r[i][e]; i--) ;
                if (i < 0) {
                    var n = o.queryComponents({
                        mainType: "dataZoom",
                        subType: "select",
                        id: e
                    })[0];
                    if (n) {
                        var a = n.getPercentRange();
                        r[0][e] = {
                            dataZoomId: e,
                            start: a[0],
                            end: a[1]
                        };
                    }
                }
            }), r.push(i), this._dispatchZoomAction(u);
        }
        var o, i, r;
    }, nA._dispatchZoomAction = function(t) {
        var i = [];
        iA(t, function(t, e) {
            i.push(A(t));
        }), i.length && this.api.dispatchAction({
            type: "dataZoom",
            from: this.uid,
            batch: i
        });
    }, Vd("dataZoom", Wf), Go(function(r) {
        function t(n, t) {
            if (t) {
                var a = n + "Index", o = t[a];
                null == o || "all" == o || N(o) || (o = !1 === o || "none" === o ? [] : [ o ]), 
                e = function(t, e) {
                    if (null == o || "all" == o || -1 !== C(o, e)) {
                        var i = {
                            type: "select",
                            $fromToolbox: !0,
                            id: "\0_ec_\0toolbox-dataZoom_" + n + e
                        };
                        i[a] = e, s.push(i);
                    }
                }, N(i = r[n]) || (i = i ? [ i ] : []), iA(i, e);
            }
            var e, i;
        }
        if (r) {
            var s = r.dataZoom || (r.dataZoom = []);
            N(s) || (r.dataZoom = s = [ s ]);
            var e = r.toolbox;
            if (e && (N(e) && (e = e[0]), e && e.feature)) {
                var i = e.feature.dataZoom;
                t("xAxis", i), t("yAxis", i);
            }
        }
    });
    var oA = Dx.toolbox.restore;
    Zf.defaultOption = {
        show: !0,
        icon: "M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5",
        title: oA.title
    }, Zf.prototype.onclick = function(t, e, i) {
        t[tA] = null, e.dispatchAction({
            type: "restore",
            from: this.uid
        });
    }, Vd("restore", Zf), Fo({
        type: "restore",
        event: "restore",
        update: "prepareAndUpdate"
    }, function(t, e) {
        e.resetOption("recreate");
    });
    var rA, sA = "urn:schemas-microsoft-com:vml", lA = "undefined" == typeof window ? null : window, hA = !1, uA = lA && lA.document;
    if (uA && !Sp.canvasSupported) try {
        !uA.namespaces.zrvml && uA.namespaces.add("zrvml", sA), rA = function(t) {
            return uA.createElement("<zrvml:" + t + ' class="zrvml">');
        };
    } catch (t) {
        rA = function(t) {
            return uA.createElement("<" + t + ' xmlns="' + sA + '" class="zrvml">');
        };
    }
    var cA = hv.CMD, dA = Math.round, fA = Math.sqrt, pA = Math.abs, gA = Math.cos, mA = Math.sin, vA = Math.max;
    if (!Sp.canvasSupported) {
        var yA = 21600, xA = yA / 2, _A = function(t) {
            t.style.cssText = "position:absolute;left:0;top:0;width:1px;height:1px;", t.coordsize = yA + "," + yA, 
            t.coordorigin = "0,0";
        }, wA = function(t, e, i) {
            return "rgb(" + [ t, e, i ].join(",") + ")";
        }, bA = function(t, e) {
            e && t && e.parentNode !== t && t.appendChild(e);
        }, SA = function(t, e) {
            e && t && e.parentNode === t && t.removeChild(e);
        }, MA = function(t, e, i) {
            return 1e5 * (parseFloat(t) || 0) + 1e3 * (parseFloat(e) || 0) + i;
        }, IA = function(t, e) {
            return "string" == typeof t ? 0 <= t.lastIndexOf("%") ? parseFloat(t) / 100 * e : parseFloat(t) : t;
        }, TA = function(t, e, i) {
            var n = Tt(e);
            i = +i, isNaN(i) && (i = 1), n && (t.color = wA(n[0], n[1], n[2]), t.opacity = i * n[3]);
        }, DA = function(t, e, i, n) {
            var a, o, r = "fill" == e, s = t.getElementsByTagName(e)[0];
            null != i[e] && "none" !== i[e] && (r || !r && i.lineWidth) ? (t[r ? "filled" : "stroked"] = "true", 
            i[e] instanceof Xv && SA(t, s), s || (s = Uf(e)), r ? function(t, e, i) {
                var n, a, o = e.fill;
                if (null != o) if (o instanceof Xv) {
                    var r, s = 0, l = [ 0, 0 ], h = 0, u = 1, c = i.getBoundingRect(), d = c.width, f = c.height;
                    if ("linear" === o.type) {
                        r = "gradient";
                        var p = i.transform, g = [ o.x * d, o.y * f ], m = [ o.x2 * d, o.y2 * f ];
                        p && (Q(g, g, p), Q(m, m, p));
                        var v = m[0] - g[0], y = m[1] - g[1];
                        (s = 180 * Math.atan2(v, y) / Math.PI) < 0 && (s += 360), s < 1e-6 && (s = 0);
                    } else {
                        r = "gradientradial", g = [ o.x * d, o.y * f ], p = i.transform;
                        var x = i.scale, _ = d, w = f;
                        l = [ (g[0] - c.x) / _, (g[1] - c.y) / w ], p && Q(g, g, p), _ /= x[0] * yA, w /= x[1] * yA;
                        var b = vA(_, w);
                        h = 0 / b, u = 2 * o.r / b - h;
                    }
                    var S = o.colorStops.slice();
                    S.sort(function(t, e) {
                        return t.offset - e.offset;
                    });
                    for (var M = S.length, I = [], T = [], D = 0; D < M; D++) {
                        var A = S[D], C = (n = A.color, a = Tt(n), [ wA(a[0], a[1], a[2]), a[3] ]);
                        T.push(A.offset * u + h + " " + C[0]), 0 !== D && D !== M - 1 || I.push(C);
                    }
                    if (2 <= M) {
                        var L = I[0][0], k = I[1][0], P = I[0][1] * e.opacity, N = I[1][1] * e.opacity;
                        t.type = r, t.method = "none", t.focus = "100%", t.angle = s, t.color = L, t.color2 = k, 
                        t.colors = T.join(","), t.opacity = N, t.opacity2 = P;
                    }
                    "radial" === r && (t.focusposition = l.join(","));
                } else TA(t, o, e.opacity);
            }(s, i, n) : (a = s, null != (o = i).lineDash && (a.dashstyle = o.lineDash.join(" ")), 
            null == o.stroke || o.stroke instanceof Xv || TA(a, o.stroke, o.opacity)), bA(t, s)) : (t[r ? "filled" : "stroked"] = "false", 
            SA(t, s));
        }, AA = [ [], [], [] ];
        Wi.prototype.brushVML = function(t) {
            var e = this.style, i = this._vmlEl;
            i || (i = Uf("shape"), _A(i), this._vmlEl = i), DA(i, "fill", e, this), DA(i, "stroke", e, this);
            var n = this.transform, a = null != n, o = i.getElementsByTagName("stroke")[0];
            if (o) {
                var r = e.lineWidth;
                if (a && !e.strokeNoScale) {
                    var s = n[0] * n[3] - n[1] * n[2];
                    r *= fA(pA(s));
                }
                o.weight = r + "px";
            }
            var l = this.path || (this.path = new hv());
            this.__dirtyPath && (l.beginPath(), this.buildPath(l, this.shape), l.toStatic(), 
            this.__dirtyPath = !1), i.path = function(t, e) {
                var i, n, a, o, r, s, l = cA.M, h = cA.C, u = cA.L, c = cA.A, d = cA.Q, f = [], p = t.data, g = t.len();
                for (o = 0; o < g; ) {
                    switch (n = "", i = 0, a = p[o++]) {
                      case l:
                        n = " m ", i = 1, r = p[o++], s = p[o++], AA[0][0] = r, AA[0][1] = s;
                        break;

                      case u:
                        n = " l ", i = 1, r = p[o++], s = p[o++], AA[0][0] = r, AA[0][1] = s;
                        break;

                      case d:
                      case h:
                        n = " c ", i = 3;
                        var m, v, y = p[o++], x = p[o++], _ = p[o++], w = p[o++];
                        a === d ? (_ = ((m = _) + 2 * y) / 3, w = ((v = w) + 2 * x) / 3, y = (r + 2 * y) / 3, 
                        x = (s + 2 * x) / 3) : (m = p[o++], v = p[o++]), AA[0][0] = y, AA[0][1] = x, AA[1][0] = _, 
                        AA[1][1] = w, r = AA[2][0] = m, s = AA[2][1] = v;
                        break;

                      case c:
                        var b = 0, S = 0, M = 1, I = 1, T = 0;
                        e && (b = e[4], S = e[5], M = fA(e[0] * e[0] + e[1] * e[1]), I = fA(e[2] * e[2] + e[3] * e[3]), 
                        T = Math.atan2(-e[1] / I, e[0] / M));
                        var D = p[o++], A = p[o++], C = p[o++], L = p[o++], k = p[o++] + T, P = p[o++] + k + T;
                        o++;
                        var N = p[o++], O = D + gA(k) * C, E = A + mA(k) * L, R = (y = D + gA(P) * C, x = A + mA(P) * L, 
                        N ? " wa " : " at ");
                        Math.abs(O - y) < 1e-4 && (.01 < Math.abs(P - k) ? N && (O += .0125) : Math.abs(E - A) < 1e-4 ? N && O < D || !N && D < O ? x -= .0125 : x += .0125 : N && E < A || !N && A < E ? y += .0125 : y -= .0125), 
                        f.push(R, dA(((D - C) * M + b) * yA - xA), ",", dA(((A - L) * I + S) * yA - xA), ",", dA(((D + C) * M + b) * yA - xA), ",", dA(((A + L) * I + S) * yA - xA), ",", dA((O * M + b) * yA - xA), ",", dA((E * I + S) * yA - xA), ",", dA((y * M + b) * yA - xA), ",", dA((x * I + S) * yA - xA)), 
                        r = y, s = x;
                        break;

                      case cA.R:
                        var z = AA[0], B = AA[1];
                        z[0] = p[o++], z[1] = p[o++], B[0] = z[0] + p[o++], B[1] = z[1] + p[o++], e && (Q(z, z, e), 
                        Q(B, B, e)), z[0] = dA(z[0] * yA - xA), B[0] = dA(B[0] * yA - xA), z[1] = dA(z[1] * yA - xA), 
                        B[1] = dA(B[1] * yA - xA), f.push(" m ", z[0], ",", z[1], " l ", B[0], ",", z[1], " l ", B[0], ",", B[1], " l ", z[0], ",", B[1]);
                        break;

                      case cA.Z:
                        f.push(" x ");
                    }
                    if (0 < i) {
                        f.push(n);
                        for (var V = 0; V < i; V++) {
                            var G = AA[V];
                            e && Q(G, G, e), f.push(dA(G[0] * yA - xA), ",", dA(G[1] * yA - xA), V < i - 1 ? "," : "");
                        }
                    }
                }
                return f.join("");
            }(l, this.transform), i.style.zIndex = MA(this.zlevel, this.z, this.z2), bA(t, i), 
            null != e.text ? this.drawRectText(t, this.getBoundingRect()) : this.removeRectText(t);
        }, Wi.prototype.onRemove = function(t) {
            SA(t, this._vmlEl), this.removeRectText(t);
        }, Wi.prototype.onAdd = function(t) {
            bA(t, this._vmlEl), this.appendRectText(t);
        };
        Be.prototype.brushVML = function(t) {
            var e, i, n, a = this.style, o = a.image;
            if ("object" == (void 0 === (n = o) ? "undefined" : _typeof(n)) && n.tagName && "IMG" === n.tagName.toUpperCase()) {
                var r = o.src;
                if (r === this._imageSrc) e = this._imageWidth, i = this._imageHeight; else {
                    var s = o.runtimeStyle, l = s.width, h = s.height;
                    s.width = "auto", s.height = "auto", e = o.width, i = o.height, s.width = l, s.height = h, 
                    this._imageSrc = r, this._imageWidth = e, this._imageHeight = i;
                }
                o = r;
            } else o === this._imageSrc && (e = this._imageWidth, i = this._imageHeight);
            if (o) {
                var u = a.x || 0, c = a.y || 0, d = a.width, f = a.height, p = a.sWidth, g = a.sHeight, m = a.sx || 0, v = a.sy || 0, y = p && g, x = this._vmlEl;
                x || (x = uA.createElement("div"), _A(x), this._vmlEl = x);
                var _, w = x.style, b = !1, S = 1, M = 1;
                if (this.transform && (_ = this.transform, S = fA(_[0] * _[0] + _[1] * _[1]), M = fA(_[2] * _[2] + _[3] * _[3]), 
                b = _[1] || _[2]), b) {
                    var I = [ u, c ], T = [ u + d, c ], D = [ u, c + f ], A = [ u + d, c + f ];
                    Q(I, I, _), Q(T, T, _), Q(D, D, _), Q(A, A, _);
                    var C = vA(I[0], T[0], D[0], A[0]), L = vA(I[1], T[1], D[1], A[1]), k = [];
                    k.push("M11=", _[0] / S, ",", "M12=", _[2] / M, ",", "M21=", _[1] / S, ",", "M22=", _[3] / M, ",", "Dx=", dA(u * S + _[4]), ",", "Dy=", dA(c * M + _[5])), 
                    w.padding = "0 " + dA(C) + "px " + dA(L) + "px 0", w.filter = "progid:DXImageTransform.Microsoft.Matrix(" + k.join("") + ", SizingMethod=clip)";
                } else _ && (u = u * S + _[4], c = c * M + _[5]), w.filter = "", w.left = dA(u) + "px", 
                w.top = dA(c) + "px";
                var P = this._imageEl, N = this._cropEl;
                P || (P = uA.createElement("div"), this._imageEl = P);
                var O = P.style;
                if (y) {
                    if (e && i) O.width = dA(S * e * d / p) + "px", O.height = dA(M * i * f / g) + "px"; else {
                        var E = new Image(), R = this;
                        E.onload = function() {
                            E.onload = null, e = E.width, i = E.height, O.width = dA(S * e * d / p) + "px", 
                            O.height = dA(M * i * f / g) + "px", R._imageWidth = e, R._imageHeight = i, R._imageSrc = o;
                        }, E.src = o;
                    }
                    N || ((N = uA.createElement("div")).style.overflow = "hidden", this._cropEl = N);
                    var z = N.style;
                    z.width = dA((d + m * d / p) * S), z.height = dA((f + v * f / g) * M), z.filter = "progid:DXImageTransform.Microsoft.Matrix(Dx=" + -m * d / p * S + ",Dy=" + -v * f / g * M + ")", 
                    N.parentNode || x.appendChild(N), P.parentNode != N && N.appendChild(P);
                } else O.width = dA(S * d) + "px", O.height = dA(M * f) + "px", x.appendChild(P), 
                N && N.parentNode && (x.removeChild(N), this._cropEl = null);
                var B = "", V = a.opacity;
                V < 1 && (B += ".Alpha(opacity=" + dA(100 * V) + ") "), B += "progid:DXImageTransform.Microsoft.AlphaImageLoader(src=" + o + ", SizingMethod=scale)", 
                O.filter = B, x.style.zIndex = MA(this.zlevel, this.z, this.z2), bA(t, x), null != a.text && this.drawRectText(t, this.getBoundingRect());
            }
        }, Be.prototype.onRemove = function(t) {
            SA(t, this._vmlEl), this._vmlEl = null, this._cropEl = null, this._imageEl = null, 
            this.removeRectText(t);
        }, Be.prototype.onAdd = function(t) {
            bA(t, this._vmlEl), this.appendRectText(t);
        };
        var CA, LA = {}, kA = 0, PA = document.createElement("div"), NA = function(t) {
            var e = LA[t];
            if (!e) {
                100 < kA && (kA = 0, LA = {});
                var i, n = PA.style;
                try {
                    n.font = t, i = n.fontFamily.split(",")[0];
                } catch (t) {}
                e = {
                    style: n.fontStyle || "normal",
                    variant: n.fontVariant || "normal",
                    weight: n.fontWeight || "normal",
                    size: 0 | parseFloat(n.fontSize || 12),
                    family: i || "Microsoft YaHei"
                }, LA[t] = e, kA++;
            }
            return e;
        };
        Xg.measureText = function(t, e) {
            var i = uA;
            CA || ((CA = i.createElement("div")).style.cssText = "position:absolute;top:-20000px;left:0;padding:0;margin:0;border:none;white-space:pre;", 
            uA.body.appendChild(CA));
            try {
                CA.style.font = e;
            } catch (t) {}
            return CA.innerHTML = "", CA.appendChild(i.createTextNode(t)), {
                width: CA.offsetWidth
            };
        };
        for (var OA = new Xt(), EA = [ $g, ze, Be, Wi, Nv ], RA = 0; RA < EA.length; RA++) {
            var zA = EA[RA].prototype;
            zA.drawRectText = function(t, e, i, n) {
                var a = this.style;
                this.__dirty && be(a);
                var o = a.text;
                if (null != o && (o += ""), o) {
                    if (a.rich) {
                        var r = ye(o, a);
                        o = [];
                        for (var s = 0; s < r.lines.length; s++) {
                            for (var l = r.lines[s].tokens, h = [], u = 0; u < l.length; u++) h.push(l[u].text);
                            o.push(h.join(""));
                        }
                        o = o.join("\n");
                    }
                    var c, d, f = a.textAlign, p = a.textVerticalAlign, g = NA(a.font), m = g.style + " " + g.variant + " " + g.weight + " " + g.size + 'px "' + g.family + '"';
                    i = i || le(o, m, f, p);
                    var v = this.transform;
                    if (v && !n && (OA.copy(e), OA.applyTransform(v), e = OA), n) c = e.x, d = e.y; else {
                        var y = a.textPosition, x = a.textDistance;
                        if (y instanceof Array) c = e.x + IA(y[0], e.width), d = e.y + IA(y[1], e.height), 
                        f = f || "left"; else {
                            var _ = ce(y, e, x);
                            c = _.x, d = _.y, f = f || _.textAlign, p = p || _.textVerticalAlign;
                        }
                    }
                    c = he(c, i.width, f), d = ue(d, i.height, p), d += i.height / 2;
                    var w, b, S, M = Uf, I = this._textVmlEl;
                    I ? b = (w = (S = I.firstChild).nextSibling).nextSibling : (I = M("line"), w = M("path"), 
                    b = M("textpath"), S = M("skew"), b.style["v-text-align"] = "left", _A(I), w.textpathok = !0, 
                    b.on = !0, I.from = "0 0", I.to = "1000 0.05", bA(I, S), bA(I, w), bA(I, b), this._textVmlEl = I);
                    var T = [ c, d ], D = I.style;
                    v && n ? (Q(T, T, v), S.on = !0, S.matrix = v[0].toFixed(3) + "," + v[2].toFixed(3) + "," + v[1].toFixed(3) + "," + v[3].toFixed(3) + ",0,0", 
                    S.offset = (dA(T[0]) || 0) + "," + (dA(T[1]) || 0), S.origin = "0 0", D.left = "0px", 
                    D.top = "0px") : (S.on = !1, D.left = dA(c) + "px", D.top = dA(d) + "px"), b.string = String(o).replace(/&/g, "&amp;").replace(/"/g, "&quot;");
                    try {
                        b.style.font = m;
                    } catch (t) {}
                    DA(I, "fill", {
                        fill: a.textFill,
                        opacity: a.opacity
                    }, this), DA(I, "stroke", {
                        stroke: a.textStroke,
                        opacity: a.opacity,
                        lineDash: a.lineDash
                    }, this), I.style.zIndex = MA(this.zlevel, this.z, this.z2), bA(t, I);
                }
            }, zA.removeRectText = function(t) {
                SA(t, this._textVmlEl), this._textVmlEl = null;
            }, zA.appendRectText = function(t) {
                bA(t, this._textVmlEl);
            };
        }
        Nv.prototype.brushVML = function(t) {
            var e = this.style;
            null != e.text ? this.drawRectText(t, {
                x: e.x || 0,
                y: e.y || 0,
                width: 0,
                height: 0
            }, this.getBoundingRect(), !0) : this.removeRectText(t);
        }, Nv.prototype.onRemove = function(t) {
            this.removeRectText(t);
        }, Nv.prototype.onAdd = function(t) {
            this.appendRectText(t);
        };
    }
    Xf.prototype = {
        constructor: Xf,
        getType: function() {
            return "vml";
        },
        getViewportRoot: function() {
            return this._vmlViewport;
        },
        getViewportRootOffset: function() {
            var t = this.getViewportRoot();
            if (t) return {
                offsetLeft: t.offsetLeft || 0,
                offsetTop: t.offsetTop || 0
            };
        },
        refresh: function() {
            var t = this.storage.getDisplayList(!0, !0);
            this._paintList(t);
        },
        _paintList: function(t) {
            for (var e = this._vmlRoot, i = 0; i < t.length; i++) {
                var n = t[i];
                n.invisible || n.ignore ? (n.__alreadyNotVisible || n.onRemove(e), n.__alreadyNotVisible = !0) : (n.__alreadyNotVisible && n.onAdd(e), 
                n.__alreadyNotVisible = !1, n.__dirty && (n.beforeBrush && n.beforeBrush(), (n.brushVML || n.brush).call(n, e), 
                n.afterBrush && n.afterBrush())), n.__dirty = !1;
            }
            this._firstPaint && (this._vmlViewport.appendChild(e), this._firstPaint = !1);
        },
        resize: function(t, e) {
            t = null == t ? this._getWidth() : t, e = null == e ? this._getHeight() : e;
            if (this._width != t || this._height != e) {
                this._width = t, this._height = e;
                var i = this._vmlViewport.style;
                i.width = t + "px", i.height = e + "px";
            }
        },
        dispose: function() {
            this.root.innerHTML = "", this._vmlRoot = this._vmlViewport = this.storage = null;
        },
        getWidth: function() {
            return this._width;
        },
        getHeight: function() {
            return this._height;
        },
        clear: function() {
            this._vmlViewport && this.root.removeChild(this._vmlViewport);
        },
        _getWidth: function() {
            var t = this.root, e = t.currentStyle;
            return (t.clientWidth || jf(e.width)) - jf(e.paddingLeft) - jf(e.paddingRight) | 0;
        },
        _getHeight: function() {
            var t = this.root, e = t.currentStyle;
            return (t.clientHeight || jf(e.height)) - jf(e.paddingTop) - jf(e.paddingBottom) | 0;
        }
    }, R([ "getLayer", "insertLayer", "eachLayer", "eachBuiltinLayer", "eachOtherLayer", "getLayers", "modLayer", "delLayer", "clearLayer", "toDataURL", "pathToImage" ], function(t) {
        var e;
        Xf.prototype[t] = (e = t, function() {
            vg('In IE8.0 VML mode painter not support method "' + e + '"');
        });
    }), Je("vml", Xf);
    var BA = hv.CMD, VA = Array.prototype.join, GA = "none", WA = Math.round, FA = Math.sin, HA = Math.cos, ZA = Math.PI, UA = 2 * Math.PI, jA = 180 / ZA, XA = 1e-4, YA = {};
    YA.brush = function(t) {
        var e = t.style, i = t.__svgEl;
        i || (i = Yf("path"), t.__svgEl = i), t.path || t.createPathProxy();
        var n = t.path;
        if (t.__dirtyPath) {
            n.beginPath(), t.buildPath(n, t.shape), t.__dirtyPath = !1;
            var a = function(t) {
                for (var e = [], i = t.data, n = t.len(), a = 0; a < n; ) {
                    var o = "", r = 0;
                    switch (i[a++]) {
                      case BA.M:
                        o = "M", r = 2;
                        break;

                      case BA.L:
                        o = "L", r = 2;
                        break;

                      case BA.Q:
                        o = "Q", r = 4;
                        break;

                      case BA.C:
                        o = "C", r = 6;
                        break;

                      case BA.A:
                        var s = i[a++], l = i[a++], h = i[a++], u = i[a++], c = i[a++], d = i[a++], f = i[a++], p = i[a++], g = Math.abs(d), m = Kf(g - UA) && !Kf(g), v = !1;
                        v = UA <= g || !Kf(g) && (-ZA < d && d < 0 || ZA < d) == !!p;
                        var y = qf(s + h * HA(c)), x = qf(l + u * FA(c));
                        m && (d = p ? UA - 1e-4 : 1e-4 - UA, v = !0, 9 === a && e.push("M", y, x));
                        var _ = qf(s + h * HA(c + d)), w = qf(l + u * FA(c + d));
                        e.push("A", qf(h), qf(u), WA(f * jA), +v, +p, _, w);
                        break;

                      case BA.Z:
                        o = "Z";
                        break;

                      case BA.R:
                        _ = qf(i[a++]), w = qf(i[a++]);
                        var b = qf(i[a++]), S = qf(i[a++]);
                        e.push("M", _, w, "L", _ + b, w, "L", _ + b, w + S, "L", _, w + S, "L", _, w);
                    }
                    o && e.push(o);
                    for (var M = 0; M < r; M++) e.push(qf(i[a++]));
                }
                return e.join(" ");
            }(n);
            a.indexOf("NaN") < 0 && Jf(i, "d", a);
        }
        Qf(i, e), $f(i, t.transform), null != e.text && JA(t, t.getBoundingRect());
    };
    var qA = {
        brush: function(t) {
            var e, i, n = t.style, a = n.image;
            if (a instanceof HTMLImageElement && (a = a.src), a) {
                var o = n.x || 0, r = n.y || 0, s = n.width, l = n.height, h = t.__svgEl;
                h || (h = Yf("image"), t.__svgEl = h), a !== t.__imageSrc && (e = "href", i = a, 
                h.setAttributeNS("http://www.w3.org/1999/xlink", e, i), t.__imageSrc = a), Jf(h, "width", s), 
                Jf(h, "height", l), Jf(h, "x", o), Jf(h, "y", r), $f(h, t.transform), null != n.text && JA(t, t.getBoundingRect());
            }
        }
    }, KA = {}, $A = new Xt(), JA = function(t, e, i) {
        var n = t.style;
        t.__dirty && be(n);
        var a = n.text;
        if (null != a) {
            a += "";
            var o = t.__textSvgEl;
            o || (o = Yf("text"), t.__textSvgEl = o);
            var r, s, l = n.textPosition, h = n.textDistance, u = n.textAlign || "left";
            "number" == typeof n.fontSize && (n.fontSize += "px");
            var c = n.font || [ n.fontStyle || "", n.fontWeight || "", n.fontSize || "", n.fontFamily || "" ].join(" ") || jg, d = tp(n.textVerticalAlign), f = (i = le(a, c, u, d)).lineHeight;
            if (l instanceof Array) r = e.x + l[0], s = e.y + l[1]; else {
                var p = ce(l, e, h);
                r = p.x, s = p.y, d = tp(p.textVerticalAlign), u = p.textAlign;
            }
            Jf(o, "alignment-baseline", d), c && (o.style.font = c);
            var g = n.textPadding;
            if (Jf(o, "x", r), Jf(o, "y", s), Qf(o, n, !0), t instanceof Nv || t.style.transformText) $f(o, t.transform); else {
                if (t.transform) $A.copy(e), $A.applyTransform(t.transform), e = $A; else {
                    var m = t.transformCoordToGlobal(e.x, e.y);
                    e.x = m[0], e.y = m[1];
                }
                var v = n.textOrigin;
                "center" === v ? (r = i.width / 2 + r, s = i.height / 2 + s) : v && (r = v[0] + r, 
                s = v[1] + s), Jf(o, "transform", "rotate(" + 180 * -n.textRotation / Math.PI + "," + r + "," + s + ")");
            }
            var y = a.split("\n"), x = y.length, _ = u;
            "left" === _ ? (_ = "start", g && (r += g[3])) : "right" === _ ? (_ = "end", g && (r -= g[1])) : "center" === _ && (_ = "middle", 
            g && (r += (g[3] - g[1]) / 2));
            var w = 0;
            if ("baseline" === d ? (w = -i.height + f, g && (w -= g[2])) : "middle" === d ? (w = (-i.height + f) / 2, 
            g && (s += (g[0] - g[2]) / 2)) : g && (w += g[0]), t.__text !== a || t.__textFont !== c) {
                var b = t.__tspanList || [];
                for (t.__tspanList = b, M = 0; M < x; M++) (I = b[M]) ? I.innerHTML = "" : (I = b[M] = Yf("tspan"), 
                o.appendChild(I), Jf(I, "alignment-baseline", d), Jf(I, "text-anchor", _)), Jf(I, "x", r), 
                Jf(I, "y", s + M * f + w), I.appendChild(document.createTextNode(y[M]));
                for (;M < b.length; M++) o.removeChild(b[M]);
                b.length = x, t.__text = a, t.__textFont = c;
            } else if (t.__tspanList.length) for (var S = t.__tspanList.length, M = 0; M < S; ++M) {
                var I = t.__tspanList[M];
                I && (Jf(I, "x", r), Jf(I, "y", s + M * f + w));
            }
        }
    };
    KA.drawRectText = JA, KA.brush = function(t) {
        var e = t.style;
        null != e.text && (e.textPosition = [ 0, 0 ], JA(t, {
            x: e.x || 0,
            y: e.y || 0,
            width: 0,
            height: 0
        }, t.getBoundingRect()));
    }, ep.prototype = {
        diff: function(l, h, t) {
            t || (t = function(t, e) {
                return t === e;
            }), this.equals = t;
            var u = this;
            l = l.slice();
            var c = (h = h.slice()).length, d = l.length, f = 1, e = c + d, p = [ {
                newPos: -1,
                components: []
            } ], i = this.extractCommon(p[0], h, l, 0);
            if (p[0].newPos + 1 >= c && d <= i + 1) {
                for (var n = [], a = 0; a < h.length; a++) n.push(a);
                return [ {
                    indices: n,
                    count: h.length
                } ];
            }
            for (;f <= e; ) {
                var o = function() {
                    for (var t = -1 * f; t <= f; t += 2) {
                        var e, i = p[t - 1], n = p[t + 1], a = (n ? n.newPos : 0) - t;
                        i && (p[t - 1] = void 0);
                        var o = i && i.newPos + 1 < c, r = n && 0 <= a && a < d;
                        if (o || r) {
                            if (!o || r && i.newPos < n.newPos ? (e = {
                                newPos: (s = n).newPos,
                                components: s.components.slice(0)
                            }, u.pushComponent(e.components, void 0, !0)) : ((e = i).newPos++, u.pushComponent(e.components, !0, void 0)), 
                            a = u.extractCommon(e, h, l, t), e.newPos + 1 >= c && d <= a + 1) return ip(0, e.components);
                            p[t] = e;
                        } else p[t] = void 0;
                    }
                    var s;
                    f++;
                }();
                if (o) return o;
            }
        },
        pushComponent: function(t, e, i) {
            var n = t[t.length - 1];
            n && n.added === e && n.removed === i ? t[t.length - 1] = {
                count: n.count + 1,
                added: e,
                removed: i
            } : t.push({
                count: 1,
                added: e,
                removed: i
            });
        },
        extractCommon: function(t, e, i, n) {
            for (var a = e.length, o = i.length, r = t.newPos, s = r - n, l = 0; r + 1 < a && s + 1 < o && this.equals(e[r + 1], i[s + 1]); ) r++, 
            s++, l++;
            return l && t.components.push({
                count: l
            }), t.newPos = r, s;
        },
        tokenize: function(t) {
            return t.slice();
        },
        join: function(t) {
            return t.slice();
        }
    };
    var QA = new ep();
    np.prototype.createElement = Yf, np.prototype.getDefs = function(t) {
        var e = this._svgRoot, n = this._svgRoot.getElementsByTagName("defs");
        return 0 === n.length ? t ? ((n = e.insertBefore(this.createElement("defs"), e.firstChild)).contains || (n.contains = function(t) {
            var e = n.children;
            if (!e) return !1;
            for (var i = e.length - 1; 0 <= i; --i) if (e[i] === t) return !0;
            return !1;
        }), n) : null : n[0];
    }, np.prototype.update = function(t, e) {
        if (t) {
            var i = this.getDefs(!1);
            if (t[this._domName] && i.contains(t[this._domName])) "function" == typeof e && e(t); else {
                var n = this.add(t);
                n && (t[this._domName] = n);
            }
        }
    }, np.prototype.addDom = function(t) {
        this.getDefs(!0).appendChild(t);
    }, np.prototype.removeDom = function(t) {
        var e = this.getDefs(!1);
        e && t[this._domName] && (e.removeChild(t[this._domName]), t[this._domName] = null);
    }, np.prototype.getDoms = function() {
        var i = this.getDefs(!1);
        if (!i) return [];
        var n = [];
        return R(this._tagNames, function(t) {
            var e = i.getElementsByTagName(t);
            n = n.concat([].slice.call(e));
        }), n;
    }, np.prototype.markAllUnused = function() {
        var e = this;
        R(this.getDoms(), function(t) {
            t[e._markLabel] = "0";
        });
    }, np.prototype.markUsed = function(t) {
        t && (t[this._markLabel] = "1");
    }, np.prototype.removeUnused = function() {
        var e = this.getDefs(!1);
        if (e) {
            var i = this;
            R(this.getDoms(), function(t) {
                "1" !== t[i._markLabel] && e.removeChild(t);
            });
        }
    }, np.prototype.getSvgProxy = function(t) {
        return t instanceof Wi ? YA : t instanceof Be ? qA : t instanceof Nv ? KA : YA;
    }, np.prototype.getTextSvgElement = function(t) {
        return t.__textSvgEl;
    }, np.prototype.getSvgElement = function(t) {
        return t.__svgEl;
    }, o(ap, np), ap.prototype.addWithoutUpdate = function(o, r) {
        if (r && r.style) {
            var s = this;
            R([ "fill", "stroke" ], function(t) {
                if (r.style[t] && ("linear" === r.style[t].type || "radial" === r.style[t].type)) {
                    var e, i = r.style[t], n = s.getDefs(!0);
                    i._dom ? (e = i._dom, n.contains(i._dom) || s.addDom(e)) : e = s.add(i), s.markUsed(r);
                    var a = e.getAttribute("id");
                    o.setAttribute(t, "url(#" + a + ")");
                }
            });
        }
    }, ap.prototype.add = function(t) {
        var e;
        if ("linear" === t.type) e = this.createElement("linearGradient"); else {
            if ("radial" !== t.type) return vg("Illegal gradient type."), null;
            e = this.createElement("radialGradient");
        }
        return t.id = t.id || this.nextId++, e.setAttribute("id", "zr" + this._zrId + "-gradient-" + t.id), 
        this.updateDom(t, e), this.addDom(e), e;
    }, ap.prototype.update = function(i) {
        var n = this;
        np.prototype.update.call(this, i, function() {
            var t = i.type, e = i._dom.tagName;
            "linear" === t && "linearGradient" === e || "radial" === t && "radialGradient" === e ? n.updateDom(i, i._dom) : (n.removeDom(i), 
            n.add(i));
        });
    }, ap.prototype.updateDom = function(t, e) {
        if ("linear" === t.type) e.setAttribute("x1", t.x), e.setAttribute("y1", t.y), e.setAttribute("x2", t.x2), 
        e.setAttribute("y2", t.y2); else {
            if ("radial" !== t.type) return void vg("Illegal gradient type.");
            e.setAttribute("cx", t.x), e.setAttribute("cy", t.y), e.setAttribute("r", t.r);
        }
        t.global ? e.setAttribute("gradientUnits", "userSpaceOnUse") : e.setAttribute("gradientUnits", "objectBoundingBox"), 
        e.innerHTML = "";
        for (var i = t.colorStops, n = 0, a = i.length; n < a; ++n) {
            var o = this.createElement("stop");
            o.setAttribute("offset", 100 * i[n].offset + "%"), o.setAttribute("stop-color", i[n].color), 
            e.appendChild(o);
        }
        t._dom = e;
    }, ap.prototype.markUsed = function(t) {
        if (t.style) {
            var e = t.style.fill;
            e && e._dom && np.prototype.markUsed.call(this, e._dom), (e = t.style.stroke) && e._dom && np.prototype.markUsed.call(this, e._dom);
        }
    }, o(op, np), op.prototype.update = function(t) {
        var e = this.getSvgElement(t);
        e && this.updateDom(e, t.__clipPaths, !1);
        var i = this.getTextSvgElement(t);
        i && this.updateDom(i, t.__clipPaths, !0), this.markUsed(t);
    }, op.prototype.updateDom = function(t, e, i) {
        if (e && 0 < e.length) {
            var n, a, o = this.getDefs(!0), r = e[0], s = i ? "_textDom" : "_dom";
            r[s] ? (a = r[s].getAttribute("id"), n = r[s], o.contains(n) || o.appendChild(n)) : (a = "zr" + this._zrId + "-clip-" + this.nextId, 
            ++this.nextId, (n = this.createElement("clipPath")).setAttribute("id", a), o.appendChild(n), 
            r[s] = n);
            var l = this.getSvgProxy(r);
            if (r.transform && r.parent.invTransform && !i) {
                var h = Array.prototype.slice.call(r.transform);
                ht(r.transform, r.parent.invTransform, r.transform), l.brush(r), r.transform = h;
            } else l.brush(r);
            var u = this.getSvgElement(r);
            n.innerHTML = "", n.appendChild(u.cloneNode()), t.setAttribute("clip-path", "url(#" + a + ")"), 
            1 < e.length && this.updateDom(n, e.slice(1), i);
        } else t && t.setAttribute("clip-path", "none");
    }, op.prototype.markUsed = function(t) {
        var e = this;
        t.__clipPaths && 0 < t.__clipPaths.length && R(t.__clipPaths, function(t) {
            t._dom && np.prototype.markUsed.call(e, t._dom), t._textDom && np.prototype.markUsed.call(e, t._textDom);
        });
    }, o(rp, np), rp.prototype.addWithoutUpdate = function(t, e) {
        if (e && sp(e.style)) {
            var i, n = e.style;
            n._shadowDom ? (i = n._shadowDom, this.getDefs(!0).contains(n._shadowDom) || this.addDom(i)) : i = this.add(e), 
            this.markUsed(e);
            var a = i.getAttribute("id");
            t.style.filter = "url(#" + a + ")";
        }
    }, rp.prototype.add = function(t) {
        var e = this.createElement("filter"), i = t.style;
        return i._shadowDomId = i._shadowDomId || this.nextId++, e.setAttribute("id", "zr" + this._zrId + "-shadow-" + i._shadowDomId), 
        this.updateDom(t, e), this.addDom(e), e;
    }, rp.prototype.update = function(t, e) {
        var i = e.style;
        if (sp(i)) {
            var n = this;
            np.prototype.update.call(this, e, function(t) {
                n.updateDom(e, t._shadowDom);
            });
        } else this.remove(t, i);
    }, rp.prototype.remove = function(t, e) {
        null != e._shadowDomId && (this.removeDom(e), t.style.filter = "");
    }, rp.prototype.updateDom = function(t, e) {
        var i = e.getElementsByTagName("feDropShadow");
        i = 0 === i.length ? this.createElement("feDropShadow") : i[0];
        var n, a, o, r, s = t.style, l = t.scale && t.scale[0] || 1, h = t.scale && t.scale[1] || 1;
        if (s.shadowBlur || s.shadowOffsetX || s.shadowOffsetY) n = s.shadowOffsetX || 0, 
        a = s.shadowOffsetY || 0, o = s.shadowBlur, r = s.shadowColor; else {
            if (!s.textShadowBlur) return void this.removeDom(e, s);
            n = s.textShadowOffsetX || 0, a = s.textShadowOffsetY || 0, o = s.textShadowBlur, 
            r = s.textShadowColor;
        }
        i.setAttribute("dx", n / l), i.setAttribute("dy", a / h), i.setAttribute("flood-color", r);
        var u = o / 2 / l + " " + o / 2 / h;
        i.setAttribute("stdDeviation", u), e.setAttribute("x", "-100%"), e.setAttribute("y", "-100%"), 
        e.setAttribute("width", Math.ceil(o / 2 * 200) + "%"), e.setAttribute("height", Math.ceil(o / 2 * 200) + "%"), 
        e.appendChild(i), s._shadowDom = e;
    }, rp.prototype.markUsed = function(t) {
        var e = t.style;
        e && e._shadowDom && np.prototype.markUsed.call(this, e._shadowDom);
    };
    var tC = function(t, e, i, n) {
        this.root = t, this.storage = e, this._opts = i = P({}, i || {});
        var a = Yf("svg");
        a.setAttribute("xmlns", "http://www.w3.org/2000/svg"), a.setAttribute("version", "1.1"), 
        a.setAttribute("baseProfile", "full"), a.style.cssText = "user-select:none;position:absolute;left:0;top:0;", 
        this.gradientManager = new ap(n, a), this.clipPathManager = new op(n, a), this.shadowManager = new rp(n, a);
        var o = document.createElement("div");
        o.style.cssText = "overflow:hidden;position:relative", this._svgRoot = a, this._viewport = o, 
        t.appendChild(o), o.appendChild(a), this.resize(i.width, i.height), this._visibleList = [];
    };
    tC.prototype = {
        constructor: tC,
        getType: function() {
            return "svg";
        },
        getViewportRoot: function() {
            return this._viewport;
        },
        getViewportRootOffset: function() {
            var t = this.getViewportRoot();
            if (t) return {
                offsetLeft: t.offsetLeft || 0,
                offsetTop: t.offsetTop || 0
            };
        },
        refresh: function() {
            var t = this.storage.getDisplayList(!0);
            this._paintList(t);
        },
        setBackgroundColor: function(t) {
            this._viewport.style.background = t;
        },
        _paintList: function(t) {
            this.gradientManager.markAllUnused(), this.clipPathManager.markAllUnused(), this.shadowManager.markAllUnused();
            var e, i, n = this._svgRoot, a = this._visibleList, o = t.length, r = [];
            for (e = 0; e < o; e++) {
                var s = (i = v = t[e]) instanceof Wi ? YA : i instanceof Be ? qA : i instanceof Nv ? KA : YA, l = pp(v) || fp(v);
                v.invisible || (v.__dirty && (s && s.brush(v), this.clipPathManager.update(v), v.style && (this.gradientManager.update(v.style.fill), 
                this.gradientManager.update(v.style.stroke), this.shadowManager.update(l, v)), v.__dirty = !1), 
                r.push(v));
            }
            var h, u, c, d, f = (u = a, c = r, QA.diff(u, c, d));
            for (e = 0; e < f.length; e++) if ((g = f[e]).removed) for (m = 0; m < g.count; m++) {
                l = pp(v = a[g.indices[m]]);
                var p = fp(v);
                dp(n, l), dp(n, p);
            }
            for (e = 0; e < f.length; e++) {
                var g = f[e];
                if (g.added) for (m = 0; m < g.count; m++) {
                    l = pp(v = r[g.indices[m]]), p = fp(v);
                    h ? up(n, l, h) : cp(n, l), l ? up(n, p, l) : h ? up(n, p, h) : cp(n, p), up(n, p, l), 
                    h = p || l || h, this.gradientManager.addWithoutUpdate(l, v), this.shadowManager.addWithoutUpdate(h, v), 
                    this.clipPathManager.markUsed(v);
                } else if (!g.removed) for (var m = 0; m < g.count; m++) {
                    var v = r[g.indices[m]];
                    h = l = fp(v) || pp(v) || h, this.gradientManager.markUsed(v), this.gradientManager.addWithoutUpdate(l, v), 
                    this.shadowManager.markUsed(v), this.shadowManager.addWithoutUpdate(l, v), this.clipPathManager.markUsed(v);
                }
            }
            this.gradientManager.removeUnused(), this.clipPathManager.removeUnused(), this.shadowManager.removeUnused(), 
            this._visibleList = r;
        },
        _getDefs: function(t) {
            var e = this._svgRoot, n = this._svgRoot.getElementsByTagName("defs");
            return 0 === n.length ? t ? ((n = e.insertBefore(Yf("defs"), e.firstChild)).contains || (n.contains = function(t) {
                var e = n.children;
                if (!e) return !1;
                for (var i = e.length - 1; 0 <= i; --i) if (e[i] === t) return !0;
                return !1;
            }), n) : null : n[0];
        },
        resize: function(t, e) {
            var i = this._viewport;
            i.style.display = "none";
            var n = this._opts;
            if (null != t && (n.width = t), null != e && (n.height = e), t = this._getSize(0), 
            e = this._getSize(1), i.style.display = "", this._width !== t || this._height !== e) {
                this._width = t, this._height = e;
                var a = i.style;
                a.width = t + "px", a.height = e + "px";
                var o = this._svgRoot;
                o.setAttribute("width", t), o.setAttribute("height", e);
            }
        },
        getWidth: function() {
            return this._width;
        },
        getHeight: function() {
            return this._height;
        },
        _getSize: function(t) {
            var e = this._opts, i = [ "width", "height" ][t], n = [ "clientWidth", "clientHeight" ][t], a = [ "paddingLeft", "paddingTop" ][t], o = [ "paddingRight", "paddingBottom" ][t];
            if (null != e[i] && "auto" !== e[i]) return parseFloat(e[i]);
            var r = this.root, s = document.defaultView.getComputedStyle(r);
            return (r[n] || lp(s[i]) || lp(r.style[i])) - (lp(s[a]) || 0) - (lp(s[o]) || 0) | 0;
        },
        dispose: function() {
            this.root.innerHTML = "", this._svgRoot = this._viewport = this.storage = null;
        },
        clear: function() {
            this._viewport && this.root.removeChild(this._viewport);
        },
        pathToDataUrl: function() {
            return this.refresh(), "data:image/svg+xml;charset=UTF-8," + this._svgRoot.outerHTML;
        }
    }, R([ "getLayer", "insertLayer", "eachLayer", "eachBuiltinLayer", "eachOtherLayer", "getLayers", "modLayer", "delLayer", "clearLayer", "toDataURL", "pathToImage" ], function(t) {
        var e;
        tC.prototype[t] = (e = t, function() {
            vg('In SVG mode painter not support method "' + e + '"');
        });
    }), Je("svg", tC), t.version = "4.0.4", t.dependencies = {
        zrender: "4.0.3"
    }, t.PRIORITY = Zx, t.init = function(t, e, i) {
        var n = Bo(t);
        if (n) return n;
        var a = new So(t, e, i);
        return a.id = "ec_" + s_++, o_[a.id] = a, ui(t, h_, a.id), function(n) {
            function a(t, e) {
                for (var i = 0; i < t.length; i++) t[i][o] = e;
            }
            var o = "__connectUpdateStatus";
            Gx(Jx, function(t, e) {
                n._messageCenter.on(e, function(t) {
                    if (r_[n.group] && 0 !== n[o]) {
                        if (t && t.escapeConnect) return;
                        var e = n.makeActionFromEvent(t), i = [];
                        Gx(o_, function(t) {
                            t !== n && t.group === n.group && i.push(t);
                        }), a(i, 0), Gx(i, function(t) {
                            1 !== t[o] && t.dispatchAction(e);
                        }), a(i, 2);
                    }
                });
            });
        }(a), a;
    }, t.connect = function(e) {
        if (N(e)) {
            var t = e;
            e = null, Gx(t, function(t) {
                null != t.group && (e = t.group);
            }), e = e || "g_" + l_++, Gx(t, function(t) {
                t.group = e;
            });
        }
        return r_[e] = !0, e;
    }, t.disConnect = zo, t.disconnect = c_, t.dispose = function(t) {
        "string" == typeof t ? t = o_[t] : t instanceof So || (t = Bo(t)), t instanceof So && !t.isDisposed() && t.dispose();
    }, t.getInstanceByDom = Bo, t.getInstanceById = function(t) {
        return o_[t];
    }, t.registerTheme = Vo, t.registerPreprocessor = Go, t.registerProcessor = Wo, 
    t.registerPostUpdate = function(t) {
        e_.push(t);
    }, t.registerAction = Fo, t.registerCoordinateSystem = Ho, t.getCoordinateSystemDimensions = function(t) {
        var e = Ma.get(t);
        if (e) return e.getDimensionsInfo ? e.getDimensionsInfo() : e.dimensions.slice();
    }, t.registerLayout = Zo, t.registerVisual = Uo, t.registerLoading = Xo, t.extendComponentModel = Yo, 
    t.extendComponentView = qo, t.extendSeriesModel = Ko, t.extendChartView = $o, t.setCanvasCreator = function(t) {
        e("createCanvas", t);
    }, t.registerMap = function(t, e, i) {
        e.geoJson && !e.features && (i = e.specialAreas, e = e.geoJson), "string" == typeof e && (e = "undefined" != typeof JSON && JSON.parse ? JSON.parse(e) : new Function("return (" + e + ");")()), 
        u_[t] = {
            geoJson: e,
            specialAreas: i
        };
    }, t.getMap = Jo, t.dataTool = {}, t.zrender = vm, t.graphic = iy, t.number = gy, 
    t.format = Sy, t.throttle = oo, t.helper = Q_, t.matrix = Kp, t.vector = Hp, t.color = dg, 
    t.parseGeoJSON = ew, t.parseGeoJson = ow, t.util = rw, t.List = x_, t.Model = Pn, 
    t.Axis = aw, t.env = Sp;
});